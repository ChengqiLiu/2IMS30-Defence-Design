/***************************************************************************//**
 * @file
 * @brief Network Tcp Layer - (Transmission Control Protocol)
 *******************************************************************************
 * # License
 * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
 *******************************************************************************
 *
 * The licensor of this software is Silicon Laboratories Inc.  Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement.
 * The software is governed by the sections of the MSLA applicable to Micrium
 * Software.
 *
 ******************************************************************************/

/********************************************************************************************************
 ********************************************************************************************************
 *                                       DEPENDENCIES & AVAIL CHECK(S)
 ********************************************************************************************************
 *******************************************************************************************************/

#include  <rtos_description.h>

#if (defined(RTOS_MODULE_NET_AVAIL))

#include  <net/include/net_cfg_net.h>

#ifdef  NET_TCP_MODULE_EN

/********************************************************************************************************
 ********************************************************************************************************
 *                                               INCLUDE FILES
 ********************************************************************************************************
 *******************************************************************************************************/

#include  <em_core.h>

#include  <net/include/net_util.h>

#include  "net_tcp_priv.h"
#include  "net_priv.h"
#include  "net_buf_priv.h"
#include  "net_conn_priv.h"
#include  "net_util_priv.h"
#include  "net_if_priv.h"

#ifdef  NET_IPv4_MODULE_EN
#include  "net_icmpv4_priv.h"
#endif
#ifdef  NET_IPv6_MODULE_EN
#include  "net_ipv6_priv.h"
#include  "net_icmpv6_priv.h"
#endif

#include  <common/include/lib_utils.h>
#include  <common/source/rtos/rtos_utils_priv.h>

/********************************************************************************************************
 ********************************************************************************************************
 *                                               LOCAL DEFINES
 ********************************************************************************************************
 *******************************************************************************************************/

#define  LOG_DFLT_CH                     (NET)
#define  RTOS_MODULE_CUR                  RTOS_CFG_MODULE_NET

#define  NET_TCP_RX_Q_NAME               "Net TCP Rx Q signal"
#define  NET_TCP_TX_Q_NAME               "Net TCP Tx Q signal"

/********************************************************************************************************
 *                               TCP CONNECTION CONFIGURATION CODE DEFINES
 *
 * Note(s) : (1) (a) TCP connection configuration codes used as arguments for various NetTCP_ConnCfg() functions.
 *
 *               (b) TCP connection configuration codes bit-field flags logically OR'd.
 *******************************************************************************************************/

#define  NET_TCP_CONN_CFG_NONE                           DEF_BIT_NONE

#define  NET_TCP_CONN_CFG_MAX_SEG_SIZE_LOCAL             DEF_BIT_00
#define  NET_TCP_CONN_CFG_MAX_SEG_SIZE_REMOTE            DEF_BIT_01
#define  NET_TCP_CONN_CFG_MAX_SEG_SIZE_CONN              DEF_BIT_02
#define  NET_TCP_CONN_CFG_MAX_SEG_SIZE_ALL              (NET_TCP_CONN_CFG_MAX_SEG_SIZE_LOCAL    \
                                                         | NET_TCP_CONN_CFG_MAX_SEG_SIZE_REMOTE \
                                                         | NET_TCP_CONN_CFG_MAX_SEG_SIZE_CONN)

#define  NET_TCP_CONN_CFG_MAX_SEG_SIZE_MASK              NET_TCP_CONN_CFG_MAX_SEG_SIZE_ALL

#define  NET_TCP_CONN_CFG_WIN_SIZE_RX                    DEF_BIT_02
#define  NET_TCP_CONN_CFG_WIN_SIZE_TX                    DEF_BIT_03
#define  NET_TCP_CONN_CFG_WIN_SIZE_CONN                 (NET_TCP_CONN_CFG_WIN_SIZE_RX \
                                                         | NET_TCP_CONN_CFG_WIN_SIZE_TX)
#define  NET_TCP_CONN_CFG_WIN_SIZE_ALL                   NET_TCP_CONN_CFG_WIN_SIZE_CONN

#define  NET_TCP_CONN_CFG_WIN_SIZE_MASK                  NET_TCP_CONN_CFG_WIN_SIZE_ALL

#define  NET_TCP_CONN_CFG_TX_RTT_RTO                     DEF_BIT_04

#define  NET_TCP_CONN_CFG_ALL                           (NET_TCP_CONN_CFG_NONE               \
                                                         | NET_TCP_CONN_CFG_MAX_SEG_SIZE_ALL \
                                                         | NET_TCP_CONN_CFG_WIN_SIZE_ALL     \
                                                         | NET_TCP_CONN_CFG_TX_RTT_RTO)

/********************************************************************************************************
 *                               TCP CONNECTION CLOSE/FREE CODE DEFINES
 *
 * Note(s) : (1) (a) TCP connection close codes used as arguments for various NetTCP_ConnClose() functions.
 *
 *               (b) TCP connection close codes bit-field flags logically OR'd.
 *
 *           (2) Available TCP connection free codes are identical to TCP connection close codes.
 *******************************************************************************************************/

#define  NET_TCP_CONN_CLOSE_NONE                         DEF_BIT_NONE

#define  NET_TCP_CONN_CLOSE_CONN_NONE                    DEF_BIT_NONE
#define  NET_TCP_CONN_CLOSE_CONN_TX_RESET                DEF_BIT_00
#define  NET_TCP_CONN_CLOSE_CONN_ALL                    (NET_TCP_CONN_CLOSE_CONN_NONE \
                                                         | NET_TCP_CONN_CLOSE_CONN_TX_RESET)

#define  NET_TCP_CONN_CLOSE_CONN_MASK                    NET_TCP_CONN_CLOSE_CONN_ALL

#define  NET_TCP_CONN_CLOSE_TMR_NONE                     DEF_BIT_NONE
#define  NET_TCP_CONN_CLOSE_TMR_TIMEOUT                  DEF_BIT_04
#define  NET_TCP_CONN_CLOSE_TMR_TX_IDLE                  DEF_BIT_05
#define  NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN             DEF_BIT_06
#define  NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN              DEF_BIT_07
#define  NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY               DEF_BIT_08
#define  NET_TCP_CONN_CLOSE_TMR_RE_TX                    DEF_BIT_09

#define  NET_TCP_CONN_CLOSE_TMR_ALL                     (NET_TCP_CONN_CLOSE_TMR_NONE           \
                                                         | NET_TCP_CONN_CLOSE_TMR_TIMEOUT      \
                                                         | NET_TCP_CONN_CLOSE_TMR_TX_IDLE      \
                                                         | NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN \
                                                         | NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN  \
                                                         | NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY   \
                                                         | NET_TCP_CONN_CLOSE_TMR_RE_TX)

#define  NET_TCP_CONN_CLOSE_TMR_MASK                     NET_TCP_CONN_CLOSE_TMR_ALL

#define  NET_TCP_CONN_CLOSE_ALL                         (NET_TCP_CONN_CLOSE_NONE       \
                                                         | NET_TCP_CONN_CLOSE_CONN_ALL \
                                                         | NET_TCP_CONN_CLOSE_TMR_ALL)

#define  NET_TCP_CONN_FREE_NONE                          NET_TCP_CONN_CLOSE_NONE

#define  NET_TCP_CONN_FREE_TMR_NONE                      NET_TCP_CONN_CLOSE_TMR_NONE
#define  NET_TCP_CONN_FREE_TMR_TIMEOUT                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT
#define  NET_TCP_CONN_FREE_TMR_TX_IDLE                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE
#define  NET_TCP_CONN_FREE_TMR_TX_SILLY_WIN              NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN
#define  NET_TCP_CONN_FREE_TMR_TX_ZERO_WIN               NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN
#define  NET_TCP_CONN_FREE_TMR_TX_ACK_DLY                NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY
#define  NET_TCP_CONN_FREE_TMR_RE_TX                     NET_TCP_CONN_CLOSE_TMR_RE_TX
#define  NET_TCP_CONN_FREE_TMR_ALL                       NET_TCP_CONN_CLOSE_TMR_ALL
#define  NET_TCP_CONN_FREE_TMR_MASK                      NET_TCP_CONN_CLOSE_TMR_MASK

#define  NET_TCP_CONN_FREE_ALL                           NET_TCP_CONN_CLOSE_ALL

/********************************************************************************************************
 ********************************************************************************************************
 *                                           LOCAL DATA TYPES
 ********************************************************************************************************
 *******************************************************************************************************/

/********************************************************************************************************
 *                                       TCP SEQUENCE CODE DATA TYPE
 *******************************************************************************************************/

typedef  CPU_INT08U NET_TCP_SEQ_CODE;

/********************************************************************************************************
 *                                   TCP ACKNOWLEDGEMENT CODE DATA TYPE
 *******************************************************************************************************/

typedef  CPU_INT08U NET_TCP_ACK_CODE;

/********************************************************************************************************
 *                                   TCP CONNECTION RESET CODE DATA TYPE
 *******************************************************************************************************/

typedef  CPU_INT08U NET_TCP_RESET_CODE;

/********************************************************************************************************
 *                                       TCP WINDOW CODE DATA TYPE
 *******************************************************************************************************/

typedef  CPU_INT08U NET_TCP_WIN_CODE;

/********************************************************************************************************
 *                                   TCP CALCULATION CODE DATA TYPE
 *******************************************************************************************************/

typedef  CPU_INT08U NET_TCP_CALC_CODE;

/********************************************************************************************************
 *                                   TCP CONFIGURATION CODE DATA TYPE
 *******************************************************************************************************/

typedef  CPU_INT08U NET_TCP_CFG_CODE;

/********************************************************************************************************
 *                                       TCP CLOSE CODE DATA TYPE
 *******************************************************************************************************/

typedef  CPU_INT16U NET_TCP_CLOSE_CODE;

/********************************************************************************************************
 *                                       TCP FREE CODE DATA TYPE
 *******************************************************************************************************/

typedef  NET_TCP_CLOSE_CODE NET_TCP_FREE_CODE;

/********************************************************************************************************
 ********************************************************************************************************
 *                                       LOCAL GLOBAL VARIABLES
 ********************************************************************************************************
 *******************************************************************************************************/

NET_TCP_CONN *NetTCP_ConnTbl;

#if (NET_STAT_POOL_TCP_CONN_EN == DEF_ENABLED)
NET_STAT_POOL NetTCP_ConnPoolStat;
#endif

static NET_TCP_CONN *NetTCP_ConnPoolPtr;                        // Ptr to pool of free TCP conns.

static NET_TCP_SEQ_NBR NetTCP_TxSeqNbrCtr;                      // Global tx seq nbr ctr.

/********************************************************************************************************
 ********************************************************************************************************
 *                                       LOCAL FUNCTION PROTOTYPES
 *
 * Note(s) : (1) NetTCP_RxPktConnHandlerState&&&() abbreviated to NetTCP_RxPktConnHandler&&&() to enforce
 *               ANSI-compliance of 31-character symbol length uniqueness.
 ********************************************************************************************************
 *******************************************************************************************************/

//                                                                 --------------------- RX FNCTS ---------------------
static void NetTCP_RxPktValidate(NET_BUF     *p_buf,
                                 NET_BUF_HDR *p_buf_hdr,
                                 NET_TCP_HDR *p_tcp_hdr,
                                 RTOS_ERR    *p_err);

static void NetTCP_RxPktValidateOpt(NET_BUF_HDR *p_buf_hdr,
                                    NET_TCP_HDR *p_tcp_hdr,
                                    CPU_INT08U  tcp_hdr_len_size,
                                    RTOS_ERR    *p_err);

static CPU_BOOLEAN NetTCP_RxPktValidateOptMaxSegSize(NET_BUF_HDR *p_buf_hdr,
                                                     CPU_INT08U  *p_opt,
                                                     CPU_INT08U  *p_opt_len,
                                                     RTOS_ERR    *p_err);

static void NetTCP_RxPktDemuxSeg(NET_BUF     *p_buf,
                                 NET_BUF_HDR *p_buf_hdr,
                                 RTOS_ERR    *p_err);

static void NetTCP_RxPktConnHandler(NET_BUF     *p_buf,
                                    NET_BUF_HDR *p_buf_hdr,
                                    RTOS_ERR    *p_err);

//                                                                 See Note #1.
static NET_TCP_STATUS NetTCP_RxPktConnHandlerListen(NET_TCP_CONN *p_conn,
                                                    NET_BUF      *p_buf,
                                                    NET_BUF_HDR  *p_buf_hdr,
                                                    RTOS_ERR     *p_err);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerSyncRxd(NET_TCP_CONN *p_conn,
                                                     NET_BUF      *p_buf,
                                                     NET_BUF_HDR  *p_buf_hdr,
                                                     RTOS_ERR     *p_err);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerSyncTxd(NET_TCP_CONN *p_conn,
                                                     NET_BUF      *p_buf,
                                                     NET_BUF_HDR  *p_buf_hdr,
                                                     RTOS_ERR     *p_err);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerConn(NET_TCP_CONN *p_conn,
                                                  NET_BUF      *p_buf,
                                                  NET_BUF_HDR  *p_buf_hdr,
                                                  RTOS_ERR     *p_err);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerFinWait1(NET_TCP_CONN *p_conn,
                                                      NET_BUF      *p_buf,
                                                      NET_BUF_HDR  *p_buf_hdr,
                                                      RTOS_ERR     *p_err);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerFinWait2(NET_TCP_CONN *p_conn,
                                                      NET_BUF      *p_buf,
                                                      NET_BUF_HDR  *p_buf_hdr,
                                                      RTOS_ERR     *p_err);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerClosing(NET_TCP_CONN *p_conn,
                                                     NET_BUF      *p_buf,
                                                     NET_BUF_HDR  *p_buf_hdr,
                                                     RTOS_ERR     *p_err);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerTimeWait(NET_TCP_CONN *p_conn,
                                                      NET_BUF      *p_buf,
                                                      NET_BUF_HDR  *p_buf_hdr,
                                                      RTOS_ERR     *p_err);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerCloseWait(NET_TCP_CONN *p_conn,
                                                       NET_BUF      *p_buf,
                                                       NET_BUF_HDR  *p_buf_hdr,
                                                       RTOS_ERR     *p_err);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerLastAck(NET_TCP_CONN *p_conn,
                                                     NET_BUF      *p_buf,
                                                     NET_BUF_HDR  *p_buf_hdr,
                                                     RTOS_ERR     *p_err);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerSeg(NET_TCP_CONN     *p_conn,
                                                 NET_TCP_ACK_CODE ack_code,
                                                 NET_BUF          *p_buf,
                                                 NET_BUF_HDR      *p_buf_hdr,
                                                 RTOS_ERR         *p_err);

static void NetTCP_RxPktConnHandlerCfgConn(NET_TCP_CONN *p_conn);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerRxQ_Sync(NET_TCP_CONN *p_conn,
                                                      NET_BUF      *p_buf,
                                                      NET_BUF_HDR  *p_buf_hdr);

static NET_TCP_STATUS NetTCP_RxPktConnHandlerRxQ_Conn(NET_TCP_CONN *p_conn,
                                                      NET_BUF      *p_buf,
                                                      NET_BUF_HDR  *p_buf_hdr);

static void NetTCP_RxPktConnHandlerRxQ_AppData(NET_TCP_CONN *p_conn);

static void NetTCP_RxPktConnHandlerTxWinRemote(NET_TCP_CONN     *p_conn,
                                               NET_TCP_ACK_CODE ack_code,
                                               NET_BUF_HDR      *p_buf_hdr,
                                               RTOS_ERR         *p_err);

static void NetTCP_RxPktConnHandlerReTxQ(NET_TCP_CONN     *p_conn,
                                         NET_TCP_ACK_CODE ack_code,
                                         NET_BUF_HDR      *p_buf_hdr,
                                         RTOS_ERR         *p_err);

static CPU_BOOLEAN NetTCP_RxPktConnHandlerListenQ_IsAvail(NET_TCP_CONN *p_conn,
                                                          RTOS_ERR     *p_err);

static void NetTCP_RxPktConnHandlerSignalConn(NET_TCP_CONN       *p_conn,
                                              NET_TCP_CONN_STATE state,
                                              RTOS_ERR           *p_err);

static void NetTCP_RxPktConnHandlerSignalClose(NET_TCP_CONN *p_conn,
                                               CPU_BOOLEAN  data_avail,
                                               RTOS_ERR     *p_err);

static NET_TCP_SEQ_CODE NetTCP_RxPktConnIsValidSeq(NET_TCP_CONN *p_conn,
                                                   NET_BUF_HDR  *p_buf_hdr);

static NET_TCP_ACK_CODE NetTCP_RxPktConnIsValidAck(NET_TCP_CONN *p_conn,
                                                   NET_BUF_HDR  *p_buf_hdr);

static NET_TCP_RESET_CODE NetTCP_RxPktConnIsValidReset(NET_TCP_CONN *p_conn,
                                                       NET_BUF_HDR  *p_buf_hdr);

static NET_BUF_QTY NetTCP_RxPktFree(NET_BUF *p_buf_q);

static void NetTCP_RxConnWinSizeCfg(NET_TCP_CONN *p_conn);

static void NetTCP_RxConnWinSizeHandler(NET_TCP_CONN     *p_conn,
                                        NET_BUF_HDR      *p_buf_hdr,
                                        CPU_INT16U       nbr_buf,
                                        NET_TCP_WIN_CODE win_update_code);

//                                                                 --------------------- TX FNCTS ---------------------

static void NetTCP_TxConnWinSizeCfg(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnWinSizeCfgCongCtrl(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnWinSizeCfgMinTh(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnWinSizeHandlerCfgd(NET_TCP_CONN     *p_conn,
                                            NET_TCP_WIN_SIZE win_update_size,
                                            NET_TCP_WIN_CODE win_update_code);

static void NetTCP_TxConnWinSizeHandlerCongCtrl(NET_TCP_CONN     *p_conn,
                                                NET_BUF_HDR      *p_buf_hdr,
                                                NET_TCP_ACK_CODE ack_code,
                                                NET_TCP_WIN_SIZE win_update_size,
                                                NET_TCP_WIN_CODE win_update_code,
                                                RTOS_ERR         *p_err);

static void NetTCP_TxConnWinSizeCalcSlowStartTh(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnWinSizeCongSet(NET_TCP_CONN     *p_conn,
                                        NET_TCP_WIN_CODE win_inc_code);

static void NetTCP_TxConnWinSizeCongInc(NET_TCP_CONN     *p_conn,
                                        NET_BUF_HDR      *p_buf_hdr,
                                        NET_TCP_WIN_SIZE win_update_size,
                                        NET_TCP_WIN_CODE win_inc_code);

static void NetTCP_TxConnWinSizeUpdateAvail(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnWinSizeDupAckCtrlReset(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnWinSizeDupAckCtrlUpdate(NET_TCP_CONN *p_conn,
                                                 NET_BUF_HDR  *p_buf_hdr,
                                                 CPU_BOOLEAN  reset_ctr);

static void NetTCP_TxConnWinSizeZeroWinHandler(NET_TCP_CONN       *p_conn,
                                               NET_TCP_WIN_CODE   win_update_code,
                                               NET_TCP_CLOSE_CODE close_code);

static void NetTCP_TxConnWinSizeZeroWinTimeout(void *p_conn_timeout);

static void NetTCP_TxConnSync(NET_TCP_CONN       *p_conn,
                              NET_BUF_HDR        *p_buf_hdr,
                              NET_TCP_CONN_STATE state,
                              RTOS_ERR           *p_err);

static void NetTCP_TxConnClose(NET_TCP_CONN       *p_conn,
                               NET_TCP_CONN_STATE state,
                               RTOS_ERR           *p_err);

static NET_TCP_ACK_STATUS NetTCP_TxConnAck(NET_TCP_CONN       *p_conn,
                                           NET_BUF_HDR        *p_buf_hdr,
                                           NET_TCP_ACK_CODE   tx_ack_code,
                                           NET_TCP_CLOSE_CODE close_code,
                                           RTOS_ERR           *p_err);

static void NetTCP_TxConnAckDlyReset(NET_TCP_CONN *p_conn,
                                     CPU_BOOLEAN  tmr_free);

static void NetTCP_TxConnAckDlyTimeout(void *p_conn_timeout);

static void NetTCP_TxConnReset(NET_TCP_CONN       *p_conn,
                               NET_BUF_HDR        *p_buf_hdr,
                               NET_TCP_RESET_CODE tx_reset_code,
                               NET_TCP_CLOSE_CODE close_code,
                               RTOS_ERR           *p_err);

static void NetTCP_TxConnProbe(NET_TCP_CONN       *p_conn,
                               CPU_BOOLEAN        tx_probe_data_octet,
                               NET_TCP_CLOSE_CODE close_code,
                               RTOS_ERR           *p_err);

static void NetTCP_TxConnKeepAlive(NET_TCP_CONN       *p_conn,
                                   NET_TCP_CLOSE_CODE close_code,
                                   RTOS_ERR           *p_err);

static void NetTCP_TxConnKeepAliveReset(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnTxQ(NET_TCP_CONN       *p_conn,
                             NET_BUF_HDR        *p_buf_hdr,
                             NET_TCP_ACK_CODE   tx_ack_code,
                             CPU_BOOLEAN        tx_q_timeout,
                             NET_TCP_CLOSE_CODE close_code,
                             CPU_BOOLEAN        tx_suspend_en,
                             RTOS_ERR           *p_err);

static void NetTCP_TxConnTxQ_TimeoutIdle(void *p_conn_timeout);

static void NetTCP_TxConnTxQ_TimeoutIdleSet(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnTxQ_TimeoutIdleClr(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnTxQ_TimeoutSillyWin(void *p_conn_timeout);

static void NetTCP_TxConnReTxQ(NET_TCP_CONN       *p_conn,
                               CPU_BOOLEAN        re_tx_q_timeout,
                               NET_TCP_CLOSE_CODE close_code,
                               RTOS_ERR           *p_err);

static void NetTCP_TxConnReTxQ_Timeout(void *p_conn_timeout);

static void NetTCP_TxConnReTxQ_TimeoutSet(NET_TCP_CONN       *p_conn,
                                          CPU_BOOLEAN        re_tx_q_timeout,
                                          NET_TCP_CLOSE_CODE close_code,
                                          RTOS_ERR           *p_err);

static void NetTCP_TxConnPrepareSegAddrs(NET_TCP_CONN *p_conn,
                                         CPU_INT08U   *p_src_addr,
                                         CPU_INT08U   *p_src_port,
                                         CPU_INT16U   src_addr_len,
                                         CPU_INT16U   src_port_len,
                                         CPU_INT08U   *p_dest_addr,
                                         CPU_INT08U   *p_dest_port,
                                         CPU_INT16U   dest_addr_len,
                                         CPU_INT16U   dest_port_len,
                                         RTOS_ERR     *p_err);

static void NetTCP_TxConnRTT_Init(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnRTT_Reset(NET_TCP_CONN *p_conn);

#if 0
static void NetTCP_TxConnRTT_CalcUpdate(NET_TCP_CONN *p_conn);
#endif

static void NetTCP_TxConnRTO_Init(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnRTO_CfgMaxTimeout(NET_TCP_CONN *p_conn);

#if 0
static void NetTCP_TxConnRTO_CalcUpdate(NET_TCP_CONN *p_conn);
#endif

static void NetTCP_TxConnRTO_CalcUpdate_ms(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnRTO_CalcUpdate_ms_scaled(NET_TCP_CONN *p_conn);

static NET_TCP_TIMEOUT_MS NetTCP_TxConnRTO_CalcBackOff(NET_TCP_CONN       *p_conn,
                                                       NET_TCP_TIMEOUT_MS rto_ms);

static void NetTCP_TxConnRTT_RTO_Init(NET_TCP_CONN *p_conn);

static void NetTCP_TxConnRTT_RTO_Calc(NET_TCP_CONN         *p_conn,
                                      NET_TCP_CALC_CODE    calc_code,
                                      NET_TCP_TX_RTT_TS_MS rtt_ts_txd_ms,
                                      NET_TCP_TX_RTT_TS_MS rtt_ts_rxd_ms);

#ifdef  NET_IPv4_MODULE_EN
static void NetTCP_TxPktHandlerIPv4(NET_BUF          *p_buf,
                                    NET_IPv4_ADDR    src_addr,
                                    NET_TCP_PORT_NBR src_port,
                                    NET_IPv4_ADDR    dest_addr,
                                    NET_TCP_PORT_NBR dest_port,
                                    NET_TCP_SEQ_NBR  seq_nbr,
                                    NET_TCP_SEQ_NBR  ack_nbr,
                                    NET_TCP_WIN_SIZE win_size,
                                    NET_IPv4_TOS     TOS,
                                    NET_IPv4_TTL     TTL,
                                    NET_TCP_FLAGS    flags_tcp,
                                    NET_IPv4_FLAGS   flags_ip,
                                    void             *p_opts_tcp,
                                    void             *p_opts_ip,
                                    RTOS_ERR         *p_err);
#endif

#ifdef  NET_IPv6_MODULE_EN
static void NetTCP_TxPktHandlerIPv6(NET_BUF                *p_buf,
                                    NET_IPv6_ADDR          *p_src_addr,
                                    NET_TCP_PORT_NBR       src_port,
                                    NET_IPv6_ADDR          *p_dest_addr,
                                    NET_TCP_PORT_NBR       dest_port,
                                    NET_TCP_SEQ_NBR        seq_nbr,
                                    NET_TCP_SEQ_NBR        ack_nbr,
                                    NET_TCP_WIN_SIZE       win_size,
                                    NET_IPv6_TRAFFIC_CLASS traffic_class,
                                    NET_IPv6_FLOW_LABEL    flow_label,
                                    NET_IPv6_HOP_LIM       hop_lim,
                                    NET_TCP_FLAGS          flags_tcp,
                                    void                   *p_opts_tcp,
                                    RTOS_ERR               *p_err);
#endif

#ifdef  NET_IPv4_MODULE_EN
static void NetTCP_TxPktIPv4(NET_BUF          *p_buf,
                             NET_BUF_HDR      *p_buf_hdr,
                             NET_IPv4_ADDR    src_addr,
                             NET_TCP_PORT_NBR src_port,
                             NET_IPv4_ADDR    dest_addr,
                             NET_TCP_PORT_NBR dest_port,
                             NET_TCP_SEQ_NBR  seq_nbr,
                             NET_TCP_SEQ_NBR  ack_nbr,
                             NET_TCP_WIN_SIZE win_size,
                             NET_IPv4_TOS     TOS,
                             NET_IPv4_TTL     TTL,
                             NET_TCP_FLAGS    flags_tcp,
                             NET_IPv4_FLAGS   flags_ip,
                             void             *p_opts_tcp,
                             void             *p_opts_ip,
                             RTOS_ERR         *p_err);
#endif

#ifdef  NET_IPv6_MODULE_EN
static void NetTCP_TxPktIPv6(NET_BUF                *p_buf,
                             NET_BUF_HDR            *p_buf_hdr,
                             NET_IPv6_ADDR          *p_src_addr,
                             NET_TCP_PORT_NBR       src_port,
                             NET_IPv6_ADDR          *p_dest_addr,
                             NET_TCP_PORT_NBR       dest_port,
                             NET_TCP_SEQ_NBR        seq_nbr,
                             NET_TCP_SEQ_NBR        ack_nbr,
                             NET_TCP_WIN_SIZE       win_size,
                             NET_IPv6_TRAFFIC_CLASS traffic_class,
                             NET_IPv6_FLOW_LABEL    flow_label,
                             NET_IPv6_HOP_LIM       hop_lim,
                             NET_TCP_FLAGS          flags_tcp,
                             void                   *p_opts_tcp,
                             RTOS_ERR               *p_err);
#endif

static CPU_INT08U NetTCP_TxPktPrepareOpt(void       *p_opts_tcp,
                                         CPU_INT08U *p_opt_hdr,
                                         RTOS_ERR   *p_err);

static void NetTCP_TxPktPrepareOptMaxSegSize(void       *p_opts_tcp,
                                             CPU_INT08U *p_opt_hdr,
                                             CPU_INT08U *p_opt_len,
                                             void       **p_opt_next);

static void NetTCP_TxPktPrepareHdr(NET_BUF          *p_buf,
                                   NET_BUF_HDR      *p_buf_hdr,
                                   CPU_INT16U       tcp_hdr_len_tot,
                                   CPU_INT08U       tcp_opt_len_tot,
                                   CPU_INT16U       addr_size,
                                   void             *p_src_addr,
                                   NET_TCP_PORT_NBR src_port,
                                   void             *p_dest_addr,
                                   NET_TCP_PORT_NBR dest_port,
                                   NET_TCP_SEQ_NBR  seq_nbr,
                                   NET_TCP_SEQ_NBR  ack_nbr,
                                   NET_TCP_WIN_SIZE win_size,
                                   NET_TCP_FLAGS    flags_tcp,
                                   CPU_INT32U       *p_tcp_hdr_opts);

static NET_BUF_QTY NetTCP_TxPktFree(NET_BUF *p_buf_q);

static void NetTCP_TxPktDiscard(NET_BUF *p_buf);

//                                                                 ------------------ TCP CONN FNCTS ------------------

static void NetTCP_ConnCfg(NET_TCP_CONN     *p_conn,
                           NET_TCP_CFG_CODE cfg_code);

static void NetTCP_ConnCfgMaxSegSize(NET_TCP_CONN *p_conn);

static void NetTCP_ConnIdleTimeout(void *p_conn_timeout);

static void NetTCP_ConnClose(NET_TCP_CONN       *p_conn,
                             NET_BUF_HDR        *p_buf_hdr,
                             CPU_BOOLEAN        close_conn_app,
                             NET_TCP_CLOSE_CODE close_code);

static void NetTCP_ConnCloseHandler(NET_TCP_CONN       *p_conn,
                                    CPU_BOOLEAN        close_conn_app,
                                    NET_TCP_CLOSE_CODE close_code);

static void NetTCP_ConnClosingTimeoutDataAvail(void *p_conn_timeout);

static void NetTCP_ConnFreeHandler(NET_TCP_CONN      *p_conn,
                                   NET_TCP_FREE_CODE free_code);

static void NetTCP_ConnFreeTmr(NET_TCP_CONN      *p_conn,
                               NET_TCP_FREE_CODE free_code);

static void NetTCP_ConnFreeBufQ(NET_BUF **p_buf_q_head,
                                NET_BUF **p_buf_q_tail);

static void NetTCP_ConnClr(NET_TCP_CONN *p_conn);

static void NetTCP_ConnCopy(NET_TCP_CONN *p_conn_dest,
                            NET_TCP_CONN *p_conn_src);

static void NetTCP_GetTxDataIx(NET_IF_NBR        if_nbr,
                               NET_PROTOCOL_TYPE protocol,
                               CPU_INT16U        additial_hdr_size,
                               CPU_INT16U        data_len,
                               NET_TCP_CONN      *p_conn,
                               CPU_INT16U        *p_ix);

/********************************************************************************************************
 ********************************************************************************************************
 *                                           PUBLIC FUNCTIONS
 ********************************************************************************************************
 *******************************************************************************************************/

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgIdleTimeout()
 *
 * @brief    Configure TCP connection's idle timeout.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure connection idle timeout.
 *
 * @param    timeout_sec     Desired value for TCP connection idle timeout (in seconds).
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function :
 *                               - RTOS_ERR_NONE
 *                               - RTOS_ERR_INVALID_HANDLE
 *
 * @return   DEF_OK,   TCP connection idle timeout successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) Configured timeout does NOT reschedule any current idle timeout in progress but
 *               becomes effective the next time a TCP connection sets its idle timeout.
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgIdleTimeout(NET_TCP_CONN_ID     conn_id_tcp,
                                      NET_TCP_TIMEOUT_SEC timeout_sec,
                                      RTOS_ERR            *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgIdleTimeout);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               ----------- CFG TCP CONN TX IDLE TIMEOUT -----------
  cfg_valid = NetTCP_ConnCfgIdleTimeoutHandler(conn_id_tcp, timeout_sec);

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgMaxSegSizeLocal()
 *
 * @brief    Configure TCP connection's local maximum segment size.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure local maximum segment size.
 *
 * @param    max_seg_size    Desired maximum segment size.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function :
 *                               - RTOS_ERR_NONE
 *                               - RTOS_ERR_INVALID_HANDLE
 *                               - RTOS_ERR_INVALID_STATE
 *
 * @return   DEF_OK,   TCP connection local maximum segment size successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) RFC #793, Section 3.1 'Header Format : Options : Maximum Segment Size' states that
 *               a TCP connection advertises its "maximum receive segment size ... only ... in the
 *               initial connection request (i.e., in segments with the SYN control bit set)".
 *               Thus any configuration of the local receive maximum segment size MUST be performed
 *               by the application layer PRIOR to any TCP connection request/synchronization either
 *               from a :
 *               - (a) Actively- connected TCP connection
 *               - (b) Passively-connected TCP connection, which is cloned from its previously-
 *                     configured LISTEN-state TCP connection
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgMaxSegSizeLocal(NET_TCP_CONN_ID  conn_id_tcp,
                                          NET_TCP_SEG_SIZE max_seg_size,
                                          RTOS_ERR         *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)(void *)NetTCP_ConnCfgMaxSegSizeLocal);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               --------- CFG TCP CONN LOCAL MAX SEG SIZE ----------
  cfg_valid = NetTCP_ConnCfgMaxSegSizeLocalHandler(conn_id_tcp, max_seg_size, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit_release;
  }

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnCfgRxWinSize()
 *
 * @brief    Configure TCP connection's receive window size.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure receive window size.
 *
 * @param    win_size        Desired receive window size.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function :
 *                               - RTOS_ERR_NONE
 *                               - RTOS_ERR_INVALID_HANDLE
 *                               - RTOS_ERR_INVALID_STATE
 *
 * @return   DEF_OK,   TCP connection receive window size successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) A TCP connection's receive window size SHOULD NOT be updated after the TCP
 *               connection is connected. Thus any configuration of the local receive window size MUST
 *               be performed by the application layer PRIOR to any TCP connection request/synchronization
 *               either from a :
 *                   - (a) Actively- connected TCP connection
 *                   - (b) Passively-connected TCP connection, which is cloned from its previously-
 *                         configured LISTEN-state TCP connection
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgRxWinSize(NET_TCP_CONN_ID  conn_id_tcp,
                                    NET_TCP_WIN_SIZE win_size,
                                    RTOS_ERR         *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgRxWinSize);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               ------------- CFG TCP CONN RX WIN SIZE -------------
  cfg_valid = NetTCP_ConnCfgRxWinSizeHandler(conn_id_tcp, win_size, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    cfg_valid = DEF_FAIL;
    goto exit_release;
  }

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnCfgTxWinSize()
 *
 * @brief    Configure TCP connection's transmit window size.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure transmit window size.
 *
 * @param    win_size        Desired transmit window size.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function :
 *                               - RTOS_ERR_NONE
 *                               - RTOS_ERR_INVALID_HANDLE
 *                               - RTOS_ERR_INVALID_STATE
 *
 * @return   DEF_OK,   TCP connection transmit window size successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) A TCP connection's transmit window size SHOULD NOT be updated after the TCP connection is
 *               connected.  Thus any configuration of the local transmit window size MUST be performed by
 *               the application layer PRIOR to any TCP connection request/synchronization either from a :
 *                   - (a) Actively- connected TCP connection
 *                   - (b) Passively-connected TCP connection, which is cloned from its previously-
 *                         configured LISTEN-state TCP connection
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxWinSize(NET_TCP_CONN_ID  conn_id_tcp,
                                    NET_TCP_WIN_SIZE win_size,
                                    RTOS_ERR         *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgTxWinSize);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               ------------- CFG TCP CONN TX WIN SIZE -------------
  cfg_valid = NetTCP_ConnCfgTxWinSizeHandler(conn_id_tcp, win_size, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit_release;
  }

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnCfgTxNagleEn()
 *
 * @brief    Configure TCP connection's transmit Nagle algorithm enable.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure transmit Nagle enable.
 *
 * @param    nagle_en        Desired value for TCP connection transmit Nagle enable :
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function :
 *                               - RTOS_ERR_NONE
 *                               - RTOS_ERR_INVALID_HANDLE
 *
 * @return   DEF_OK,   TCP connection transmit Nagle enable successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) RFC #1122, Section 4.2.3.4 also states that "a TCP SHOULD implement the Nagle
 *               Algorithm ... However, there MUST be a way for an application to disable the
 *               Nagle algorithm on an individual connection".
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxNagleEn(NET_TCP_CONN_ID conn_id_tcp,
                                    CPU_BOOLEAN     nagle_en,
                                    RTOS_ERR        *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgTxNagleEn);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               ------------- CFG TCP CONN TX NAGLE EN -------------
  cfg_valid = NetTCP_ConnCfgTxNagleEnHandler(conn_id_tcp, nagle_en);

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                   NetTCP_ConnCfgTxAckImmedRxdPushEn()
 *
 * @brief    Configure TCP connection's transmit immediate acknowledgement for received & pushed
 *           TCP segments enable.
 *
 * @param    conn_id_tcp         Handle identifier of TCP connection to configure transmit immediate
 *
 * @param    tx_immed_ack_en     Desired value for TCP connection transmit immediate acknowledgement
 *
 * @param    p_err               Pointer to variable that will receive the return error code from this function :
 *                                   - RTOS_ERR_NONE
 *                                   - RTOS_ERR_INVALID_HANDLE
 *
 * @return   DEF_OK,   TCP connection transmit immediate acknowledgement for received & pushed TCP
 *                           segments enable successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) RFC #813, Section 5 states that "the receiver of data will refrain from sending an
 *               acknowledgement under certain circumstances ... The most obvious event on which to
 *               depend is the arrival of another segment.  So, if a segment arrives, postpone sending
 *               an acknowledgement if ... the push bit is not set in the segment, since it is a
 *               reasonable assumption that there is more data coming in a subsequent segment."
 *
 * @note     (3) [INTENRAL] TCP connections' 'TxAckImmedRxdPushEn' variables MUST ALWAYS be accessed
 *               with the global network lock already acquired (see Note #2b).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxAckImmedRxdPushEn(NET_TCP_CONN_ID conn_id_tcp,
                                              CPU_BOOLEAN     tx_immed_ack_en,
                                              RTOS_ERR        *p_err)
{
  NET_TCP_CONN *p_conn = DEF_NULL;
  CPU_BOOLEAN  rtn_val = DEF_FAIL;
  CPU_BOOLEAN  is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

#if (RTOS_ARG_CHK_EXT_EN == DEF_ENABLED)
  //                                                               ------------- VALIDATE TX IMMED ACK EN -------------
  switch (tx_immed_ack_en) {
    case DEF_ENABLED:
    case DEF_DISABLED:
      break;

    default:
      RTOS_DBG_FAIL_EXEC_ERR(*p_err, RTOS_ERR_INVALID_ARG, DEF_FAIL);
  }
#endif

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgTxAckImmedRxdPushEn);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               ----------- CFG TCP CONN TX IMMED ACK EN -----------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  p_conn->TxAckImmedRxdPushEn = tx_immed_ack_en;

  rtn_val = DEF_OK;

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (rtn_val);
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgTxAckDlyTimeout()
 *
 * @brief    Configure TCP connection's transmit acknowledgement delay timeout.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure transmit acknowledgement
 *
 * @param    timeout_ms      Desired value for TCP connection transmit acknowledgement delay timeout
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function :
 *                               - RTOS_ERR_NONE
 *                               - RTOS_ERR_INVALID_HANDLE
 *
 * @return   DEF_OK,   TCP connection transmit acknowledgement delay timeout successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @endinternal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) RFC #1122, Section 4.2.3.2 states that "an ACK should not be excessively delayed;
 *               in particular, the delay MUST be less than 0.5 seconds".
 *               RFC #2581, Section 4.2 reiterates that "an ACK ... MUST be generated within 500 ms
 *               of the arrival of the first unacknowledged packet".
 *
 * @note     (3) Configured timeout does NOT reschedule any current acknowledgement delay timeout in
 *               progress but becomes effective the next time a TCP connection sets an acknowledgement
 *               delay timeout.
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxAckDlyTimeout(NET_TCP_CONN_ID    conn_id_tcp,
                                          NET_TCP_TIMEOUT_MS timeout_ms,
                                          RTOS_ERR           *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgTxAckDlyTimeout);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               --------- CFG TCP CONN TX ACK DLY TIMEOUT ----------
  cfg_valid = NetTCP_ConnCfgTxAckDlyTimeoutHandler(conn_id_tcp, timeout_ms);

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgTxKeepAliveEn()
 *
 * @brief    Configure TCP connection's transmit keep-alive algorithm enable.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure transmit keep-alive enable.
 *
 * @param    keep_alive_en   Desired value for TCP connection transmit keep-alive enable.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function :
 *                               - RTOS_ERR_NONE
 *                               - RTOS_ERR_INVALID_HANDLE
 *
 * @return   DEF_OK,   TCP connection transmit keep-alive enable successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) RFC #1122, Section 4.2.3.6 states that "if keep-alives are included, the application
 *               MUST be able to turn them on or off for each TCP connection".
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxKeepAliveEn(NET_TCP_CONN_ID conn_id_tcp,
                                        CPU_BOOLEAN     keep_alive_en,
                                        RTOS_ERR        *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgTxKeepAliveEn);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               ---------- CFG TCP CONN TX KEEP-ALIVE EN -----------
  cfg_valid = NetTCP_ConnCfgTxKeepAliveEnHandler(conn_id_tcp, keep_alive_en);

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                   NetTCP_ConnCfgTxKeepAliveRetryTimeout()
 *
 * @brief    Configure TCP connection's transmit keep-alive retry timeout.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure transmit keep-alive retry
 *                           timeout.
 *
 * @param    timeout_sec     Desired value for TCP connection transmit keep-alive retry timeout (in seconds).
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function :
 *                               - RTOS_ERR_NONE
 *                               - RTOS_ERR_INVALID_HANDLE
 *
 * @return   DEF_OK,   TCP connection transmit keep-alive retry timeout successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) Configured timeout does NOT reschedule any current keep-alive retry timeout in progress
 *               but becomes effective the next time a TCP connection sets its keep-alive retry timeout.
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxKeepAliveRetryTimeout(NET_TCP_CONN_ID     conn_id_tcp,
                                                  NET_TCP_TIMEOUT_SEC timeout_sec,
                                                  RTOS_ERR            *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgTxKeepAliveRetryTimeout);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               ----- CFG TCP CONN TX KEEP-ALIVE RETRY TIMEOUT -----
  cfg_valid = NetTCP_ConnCfgTxKeepAliveRetryHandler(conn_id_tcp, timeout_sec);

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgTxKeepAliveTh()
 *
 * @brief    Configure TCP connection's maximum number of consecutive keep-alives to transmit.
 *
 * @param    conn_id_tcp         Handle identifier of TCP connection to configure transmit
 *
 * @param    nbr_max_keep_alive  Desired maximum number of consecutive keep-alives to transmit.
 *
 * @param    p_err               Pointer to variable that will receive the return error code from this function :
 *                                   - RTOS_ERR_NONE
 *                                   - RTOS_ERR_INVALID_HANDLE
 *
 * @return   DEF_OK,   TCP connection transmit keep-alive threshold successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.3 'Other End Crashes',
 *               Pages 334-335 states "that the [remote host] ... send[s] ... [N] keepalive probes ...
 *               before declaring the connection dead".
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxKeepAliveTh(NET_TCP_CONN_ID conn_id_tcp,
                                        NET_PKT_CTR     nbr_max_keep_alive,
                                        RTOS_ERR        *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgTxKeepAliveTh);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               ---------- CFG TCP CONN TX KEEP-ALIVE TH -----------
  cfg_valid = NetTCP_ConnCfgTxKeepAliveThHandler(conn_id_tcp, nbr_max_keep_alive);

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnCfgReTxMaxTh()
 *
 * @brief    Configure TCP connection's maximum number of same segment retransmissions.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure maximum number of
 *
 * @param    nbr_max_re_tx   Desired maximum number of same segment retransmissions.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function:
 *                               - RTOS_ERR_NONE
 *                               - RTOS_ERR_INVALID_HANDLE
 *
 * @return   DEF_OK,   TCP connection maximum number of same segment retransmissions successfully
 *                     configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) RFC #1122, Section 4.2.3.5 states that "when the number of transmissions of the
 *               same segment reaches a threshold ... close the connection".
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgReTxMaxTh(NET_TCP_CONN_ID conn_id_tcp,
                                    NET_PKT_CTR     nbr_max_re_tx,
                                    RTOS_ERR        *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgReTxMaxTh);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               -------------- CFG TCP CONN RE-TX TH ---------------
  cfg_valid = NetTCP_ConnCfgReTxMaxThHandler(conn_id_tcp, nbr_max_re_tx);

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgReTxMaxTimeout()
 *
 * @brief    Configure TCP connection's   maximum retransmission timeout.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure maximum retransmission
 *
 * @param    timeout_sec     Desired value for TCP connection maximum retransmission timeout (in seconds).
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function :
 *                               - RTOS_ERR_NONE
 *                               - RTOS_ERR_INVALID_HANDLE
 *
 * @return   DEF_OK,   TCP connection maximum retransmission timeout successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *
 * @note     (2) RFC #2988, Section 2.4 states that "a maximum value MAY be placed on RTO provided
 *               it is at least 60 seconds".
 *               RFC #1122, Section 4.2.3.1 states that "the recommended ... RTO ... upper bound
 *               should be 2*MSL".
 *               Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2, Page 299 states
 *               that "the timeout value ... [has] an upper limit of 64 seconds".
 *
 * @note     (3) Configured timeout does NOT reschedule any current retransmission timeout in progress
 *               but becomes effective the next time a TCP connection sets its retransmission timeout.
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgReTxMaxTimeout(NET_TCP_CONN_ID     conn_id_tcp,
                                         NET_TCP_TIMEOUT_SEC timeout_sec,
                                         RTOS_ERR            *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgReTxMaxTimeout);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               --------------- CFG TCP CONN RTO MAX ---------------
  cfg_valid = NetTCP_ConnCfgReTxMaxTimeoutHandler(conn_id_tcp, timeout_sec);

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgMSL_Timeout()
 *
 * @brief    Configure TCP connection's maximum segment lifetime (MSL) timeout.
 *
 * @param    conn_id_tcp         Handle identifier of TCP connection to configure MSL value.
 *
 * @param    msl_timeout_sec     Desired value for TCP connection MSL timeout (in seconds).
 *
 * @param    p_err               Pointer to variable that will receive the return error code from this function :
 *                                   - RTOS_ERR_NONE
 *                                   - RTOS_ERR_INVALID_HANDLE
 *
 * @return   DEF_OK,   TCP connection MSL timeout successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgMSL_Timeout(NET_TCP_CONN_ID     conn_id_tcp,
                                      NET_TCP_TIMEOUT_SEC msl_timeout_sec,
                                      RTOS_ERR            *p_err)
{
  CPU_BOOLEAN cfg_valid = DEF_FAIL;
  CPU_BOOLEAN is_used = DEF_NO;

  //                                                               ---------------- VALIDATE ARGUMENTS ----------------
  RTOS_ASSERT_DBG_ERR_PTR_VALIDATE(p_err, DEF_FAIL);

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               ----------------- ACQUIRE NET LOCK -----------------
  //                                                               See Note #2b.
  Net_GlobalLockAcquire((void *)NetTCP_ConnCfgMSL_Timeout);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit_release;
  }

  //                                                               ----------------- CFG TCP CONN MSL -----------------
  cfg_valid = NetTCP_ConnCfgMSL_TimeoutHandler(conn_id_tcp, msl_timeout_sec);

exit_release:
  //                                                               ----------------- RELEASE NET LOCK -----------------
  Net_GlobalLockRelease();

  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnPoolStatGet()
 *
 * @brief    Get TCP connection statistics pool.
 *
 * @return   TCP connection statistics pool, if NO error(s).
 *           NULL           statistics pool, otherwise.
 *******************************************************************************************************/
NET_STAT_POOL NetTCP_ConnPoolStatGet(void)
{
  NET_STAT_POOL stat_pool;
#if (NET_STAT_POOL_TCP_CONN_EN == DEF_ENABLED)
  CORE_DECLARE_IRQ_STATE;
#endif

  NetStat_PoolClr(&stat_pool);                                  // Init rtn pool stat for err.

#if (NET_STAT_POOL_TCP_CONN_EN == DEF_ENABLED)
  CORE_ENTER_ATOMIC();
  stat_pool = NetTCP_ConnPoolStat;
  CORE_EXIT_ATOMIC();
#endif

  return (stat_pool);
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnPoolStatResetMaxUsed()
 *
 * @brief    Reset TCP connection's statistics pool's maximum number of entries used.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *******************************************************************************************************/
void NetTCP_ConnPoolStatResetMaxUsed(void)
{
#if (NET_STAT_POOL_TCP_CONN_EN == DEF_ENABLED)
  //                                                               Acquire net lock.
  Net_GlobalLockAcquire((void *)NetTCP_ConnPoolStatResetMaxUsed);

  NetStat_PoolResetUsedMax(&NetTCP_ConnPoolStat);               // Reset TCP conn stat pool.

  Net_GlobalLockRelease();                                      // Release net lock.
#endif
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnStateGet()
 *
 * @brief    Retrieve the TCP Connection State.
 *
 * @param    conn_id     TCP Connection ID number.
 *
 * @return   TCP Connection State.
 *
 * @internal
 * @note     (1) [INTERNAL] This function is called by application function(s) :
 *               - (a) MUST NOT be called with the global network lock already acquired;
 *               - (b) MUST block ALL other network protocol tasks by pending on & acquiring the global
 *                     network lock.
 *               This is required since an application's network protocol suite API function access is
 *               asynchronous to other network protocol tasks.
 * @endinternal
 *******************************************************************************************************/
NET_TCP_CONN_STATE NetTCP_ConnStateGet(NET_TCP_CONN_ID conn_id)
{
  NET_TCP_CONN       *p_conn_tcp = DEF_NULL;
  NET_TCP_CONN_STATE state = NET_TCP_CONN_STATE_NONE;

  //                                                               Acquire net lock.
  Net_GlobalLockAcquire((void *)NetTCP_ConnStateGet);

  p_conn_tcp = &NetTCP_ConnTbl[conn_id];
  state = p_conn_tcp->ConnState;                                // Get TCP Connection State.

  Net_GlobalLockRelease();                                      // Release net lock.

  return (state);
}

/********************************************************************************************************
 ********************************************************************************************************
 *                                           GLOBAL FUNCTIONS
 ********************************************************************************************************
 *******************************************************************************************************/

/****************************************************************************************************//**
 *                                               NetTCP_Init()
 *
 * @brief    (1) Initialize Transmission Control Protocol Layer :
 *               - (a) Perform TCP Module/OS  initialization
 *               - (b) Perform TCP Module/BSP initialization
 *               - (c) Initialize TCP connection pool
 *               - (d) Initialize TCP connection table
 *
 * @param    p_err   Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) The following TCP initialization MUST be sequenced as follows :
 *               - (a) TCP connection pool MUST be initialized PRIOR to initializing the pool with pointers
 *                     to TCP connections
 *******************************************************************************************************/
void NetTCP_Init(MEM_SEG  *p_mem_seg,
                 RTOS_ERR *p_err)
{
  NET_TCP_CONN     *p_conn;
  NET_TCP_CONN_QTY i;

  //                                                               ------ GET MEMORY SEGMENT FOR TCP CONN TABLE -------
  NetTCP_ConnTbl = (NET_TCP_CONN *)Mem_SegAlloc("TCP Connection table",
                                                p_mem_seg,
                                                sizeof(NET_TCP_CONN) * NET_TCP_NBR_CONN,
                                                p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    return;
  }
  //                                                               --------------- PERFORM TCP/BSP INIT ---------------
  NetTCP_TxSeqNbrCtr = NetUtil_InitSeqNbrGet();                 // Init tx seq nbr ctr.

  //                                                               ------------- INIT TCP CONN POOL/STATS -------------
  NetTCP_ConnPoolPtr = DEF_NULL;                                // Init-clr TCP conn pool (see Note #2b).

#if (NET_STAT_POOL_TCP_CONN_EN == DEF_ENABLED)
  NetStat_PoolInit(&NetTCP_ConnPoolStat,
                   NET_TCP_NBR_CONN);
#endif

  //                                                               ---------------- INIT TCP CONN TBL -----------------
  for (i = 0; i < (NET_TCP_CONN_QTY)NET_TCP_NBR_CONN; i++) {
    p_conn = &NetTCP_ConnTbl[i];
    p_conn->ID = (NET_TCP_CONN_ID)i;

    p_conn->ConnState = NET_TCP_CONN_STATE_FREE;                // Init each TCP conn as free/NOT used.
    p_conn->Flags = NET_TCP_FLAG_NONE;

    //                                                             Initialize TCP connection receive queue.
    //                                                             Create     TCP connection receive queue signals ...
    //                                                             ... with NO pending signal.
    p_conn->RxQ_SignalObj = KAL_SemCreate(NET_TCP_RX_Q_NAME,
                                          DEF_NULL,
                                          p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      RTOS_ERR_SET(*p_err, RTOS_ERR_CODE_GET(*p_err));
      goto exit;
    }

    //                                                             Initialize TCP connection receive queue timeout values.
    NetTCP_RxQ_TimeoutDflt(i);

    //                                                             Initialize TCP connection transmit queue.
    //                                                             Create     TCP connection transmit queue signals ...
    //                                                             ... with NO pending signal.
    p_conn->TxQ_SignalObj = KAL_SemCreate(NET_TCP_TX_Q_NAME,
                                          DEF_NULL,
                                          p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      RTOS_ERR_SET(*p_err, RTOS_ERR_CODE_GET(*p_err));
      goto exit;
    }

    //                                                             Initialize TCP connection transmit queue timeout values.
    NetTCP_TxQ_TimeoutDflt(i);

#if (NET_DBG_CFG_MEM_CLR_EN == DEF_ENABLED)
    NetTCP_ConnClr(p_conn);
#endif
    //                                                             Free each TCP conn to TCP conn pool (see Note #2).
    p_conn->NextPtr = NetTCP_ConnPoolPtr;
    NetTCP_ConnPoolPtr = p_conn;
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                               NetTCP_RxQ_Clr()
 *
 * @brief    Clear TCP connection receive queue signal.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to clear receive queue signal.
 *******************************************************************************************************/
void NetTCP_RxQ_Clr(NET_TCP_CONN_ID conn_id_tcp)
{
  NET_TCP_CONN *p_conn;
  RTOS_ERR     local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  KAL_SemSet(p_conn->RxQ_SignalObj, 0u, &local_err);            // Clear TCP connection receive queue signal.
  RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
}

/****************************************************************************************************//**
 *                                               NetTCP_RxQ_Wait()
 *
 * @brief    Wait on TCP connection receive queue.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to wait on receive queue.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @note     (1) (a) If timeouts NOT desired, wait on TCP connection receive queue forever
 *                   (i.e. do NOT exit).
 *               - (b) If timeout      desired, return RTOS_ERR_TIMEOUT error on TCP connection
 *                     receive queue timeout.  Implement timeout with OS-dependent functionality.
 *******************************************************************************************************/
void NetTCP_RxQ_Wait(NET_TCP_CONN_ID conn_id_tcp,
                     RTOS_ERR        *p_err)
{
  CPU_INT32U   timeout_ms;
  NET_TCP_CONN *p_conn;
  CORE_DECLARE_IRQ_STATE;

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  CORE_ENTER_ATOMIC();
  timeout_ms = p_conn->RxQ_SignalTimeout_ms;
  CORE_EXIT_ATOMIC();

  //                                                               Wait on TCP connection receive queue ...
  //                                                               ... with configured timeout.
  KAL_SemPend(p_conn->RxQ_SignalObj, KAL_OPT_PEND_NONE, timeout_ms, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_CODE_GET(*p_err));
  }
}

/****************************************************************************************************//**
 *                                           NetTCP_RxQ_Signal()
 *
 * @brief    Signal TCP connection receive queue.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to signal receive queue.
 *******************************************************************************************************/
void NetTCP_RxQ_Signal(NET_TCP_CONN_ID conn_id_tcp)
{
  NET_CONN     *p_net_conn;
  NET_TCP_CONN *p_tcp_conn;
  RTOS_ERR     local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  p_tcp_conn = &NetTCP_ConnTbl[conn_id_tcp];

  //                                                               Signal TCP connection receive queue.
  KAL_SemPost(p_tcp_conn->RxQ_SignalObj, KAL_OPT_PEND_NONE, &local_err);
  RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );

  p_net_conn = &NetConn_Tbl[p_tcp_conn->ID_Conn];
  if (p_net_conn->ID_App != NET_CONN_ID_NONE) {
    p_tcp_conn->FnctAppPostRx(p_net_conn->ID_App);
  } else if (p_net_conn->ID_AppClone != NET_CONN_ID_NONE) {
    p_tcp_conn->FnctAppPostRx(p_net_conn->ID_AppClone);
  }
}

/****************************************************************************************************//**
 *                                           NetTCP_RxQ_Abort()
 *
 * @brief    Abort wait on TCP connection receive queue.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to abort wait on socket receive queue.
 *******************************************************************************************************/
void NetTCP_RxQ_Abort(NET_TCP_CONN_ID conn_id_tcp)
{
  NET_CONN     *p_net_conn;
  NET_TCP_CONN *p_tcp_conn;
  NET_CONN_ID  net_conn_id;
  RTOS_ERR     local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  p_tcp_conn = &NetTCP_ConnTbl[conn_id_tcp];

  //                                                               Abort wait on TCP connection receive queue ...
  //                                                               ... for ALL waiting tasks.
  KAL_SemPendAbort(p_tcp_conn->RxQ_SignalObj, &local_err);
  RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );

  net_conn_id = p_tcp_conn->ID_Conn;
  if (net_conn_id != NET_CONN_ID_NONE) {
    p_net_conn = &NetConn_Tbl[p_tcp_conn->ID_Conn];
    p_tcp_conn->FnctAppPostRx(p_net_conn->ID_App);
  }
}

/****************************************************************************************************//**
 *                                           NetTCP_RxQ_TimeoutDflt()
 *
 * @brief    Set TCP connection receive queue to configured-default timeout value.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to set receive queue configured-default
 *                           timeout.
 *
 * @note     (1) NetTCP_RxQ_TimeoutDflt() is called by network protocol suite function(s) &
 *               may be called either with OR without the global network lock already acquired.
 *******************************************************************************************************/

#ifdef  NET_TCP_MODULE_EN
void NetTCP_RxQ_TimeoutDflt(NET_TCP_CONN_ID conn_id_tcp)
{
  CPU_INT32U timeout_ms;
  //                                                               Set TCP connection receive queue timeout ...
  //                                                               ... to configured-default        timeout value.
  timeout_ms = NET_TCP_DFLT_TIMEOUT_CONN_RX_Q_MS;

  NetTCP_RxQ_TimeoutSet(conn_id_tcp, timeout_ms);
}
#endif

/****************************************************************************************************//**
 *                                           NetTCP_RxQ_TimeoutSet()
 *
 * @brief    Set TCP connection receive queue timeout value.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to set receive queue timeout.
 *
 * @param    timeout_ms      Timeout value :
 *                           NET_TMR_TIME_INFINITE,     if infinite (i.e. NO timeout) value desired.
 *                           In number of milliseconds, otherwise.
 *
 * @note     (1) NetTCP_RxQ_TimeoutSet() is called by network protocol suite function(s) & may be
 *               called either with OR without the global network lock already acquired.
 *
 * @note     (2) 'NetTCP_RxQ_TimeoutTbl_tick[]' variables MUST ALWAYS be accessed exclusively in
 *               critical sections.
 *******************************************************************************************************/
void NetTCP_RxQ_TimeoutSet(NET_TCP_CONN_ID conn_id_tcp,
                           CPU_INT32U      timeout_ms)
{
  NET_TCP_CONN *p_conn;
  CORE_DECLARE_IRQ_STATE;

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  CORE_ENTER_ATOMIC();
  //                                                               Set TCP connection receive queue timeout value.
  p_conn->RxQ_SignalTimeout_ms = timeout_ms;
  CORE_EXIT_ATOMIC();
}

/****************************************************************************************************//**
 *                                       NetTCP_RxQ_TimeoutGet_ms()
 *
 * @brief    Get TCP connection receive queue timeout value.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to get receive queue timeout.
 *
 * @return   TCP connection receive queue network timeout value :
 *           NET_TMR_TIME_INFINITE,     if infinite (i.e. NO timeout) value configured.
 *           In number of milliseconds, otherwise.
 *
 * @note     (1) NetTCP_RxQ_TimeoutGet_ms() is called by network protocol suite function(s) & may
 *               be called either with OR without the global network lock already acquired.
 *
 * @note     (2) 'NetTCP_RxQ_TimeoutTbl_tick[]' variables MUST ALWAYS be accessed exclusively in
 *               critical sections.
 *******************************************************************************************************/
CPU_INT32U NetTCP_RxQ_TimeoutGet_ms(NET_TCP_CONN_ID conn_id_tcp)
{
  NET_TCP_CONN *p_conn;
  CPU_INT32U   timeout_ms;
  CORE_DECLARE_IRQ_STATE;

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  //                                                               Get TCP connection receive queue timeout value ...
  //                                                               ... (in OS ticks).
  CORE_ENTER_ATOMIC();
  timeout_ms = p_conn->RxQ_SignalTimeout_ms;
  CORE_EXIT_ATOMIC();

  return (timeout_ms);
}

/****************************************************************************************************//**
 *                                               NetTCP_TxQ_Clr()
 *
 * @brief    Clear TCP connection transmit queue signal.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to clear transmit queue signal.
 *******************************************************************************************************/
void NetTCP_TxQ_Clr(NET_TCP_CONN_ID conn_id_tcp)
{
  NET_TCP_CONN *p_conn;
  RTOS_ERR     local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  KAL_SemSet(p_conn->TxQ_SignalObj, 0u, &local_err);            // Clear TCP connection transmit queue signal.
  RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
}

/****************************************************************************************************//**
 *                                               NetTCP_TxQ_Wait()
 *
 * @brief    Wait on TCP connection transmit queue.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to wait on transmit queue.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @note     (1) (a) If timeouts NOT desired, wait on TCP connection transmit queue forever
 *                   (i.e. do NOT exit).
 *               - (b) If timeout      desired, return RTOS_ERR_TIMEOUT error on TCP connection
 *                     transmit queue timeout.  Implement timeout with OS-dependent functionality.
 *******************************************************************************************************/
void NetTCP_TxQ_Wait(NET_TCP_CONN_ID conn_id_tcp,
                     RTOS_ERR        *p_err)
{
  NET_TCP_CONN *p_conn;
  CPU_INT32U   timeout_ms;
  CORE_DECLARE_IRQ_STATE;

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  CORE_ENTER_ATOMIC();
  timeout_ms = p_conn->TxQ_SignalTimeout_ms;
  CORE_EXIT_ATOMIC();
  //                                                               Wait on TCP connection transmit queue ...
  //                                                               ... with configured timeout (see Note #1b).
  KAL_SemPend(p_conn->TxQ_SignalObj, KAL_OPT_PEND_NONE, timeout_ms, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_CODE_GET(*p_err));
  }
}

/****************************************************************************************************//**
 *                                           NetTCP_TxQ_Signal()
 *
 * @brief    Signal TCP connection transmit queue.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to signal transmit queue.
 *******************************************************************************************************/
void NetTCP_TxQ_Signal(NET_TCP_CONN_ID conn_id_tcp)
{
  NET_CONN     *p_net_conn;
  NET_TCP_CONN *p_tcp_conn;
  RTOS_ERR     local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  p_tcp_conn = &NetTCP_ConnTbl[conn_id_tcp];

  //                                                               Signal TCP connection transmit queue.
  KAL_SemPost(p_tcp_conn->TxQ_SignalObj, KAL_OPT_PEND_NONE, &local_err);
  RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );

  p_net_conn = &NetConn_Tbl[p_tcp_conn->ID_Conn];
  p_tcp_conn->FnctAppPostTx(p_net_conn->ID_App);
}

/****************************************************************************************************//**
 *                                           NetTCP_TxQ_Abort()
 *
 * @brief    Abort wait on TCP connection transmit queue.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to abort wait on socket transmit queue.
 *******************************************************************************************************/
void NetTCP_TxQ_Abort(NET_TCP_CONN_ID conn_id_tcp)
{
  NET_CONN     *p_net_conn;
  NET_TCP_CONN *p_tcp_conn;
  NET_CONN_ID  net_conn_id;
  RTOS_ERR     local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  p_tcp_conn = &NetTCP_ConnTbl[conn_id_tcp];

  //                                                               Abort wait on TCP connection transmit queue ...
  //                                                               ... for ALL waiting tasks.
  KAL_SemPendAbort(p_tcp_conn->TxQ_SignalObj, &local_err);
  RTOS_ASSERT_CRITICAL((RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE), RTOS_ERR_ASSERT_CRITICAL_FAIL,; );

  net_conn_id = p_tcp_conn->ID_Conn;
  if (net_conn_id != NET_CONN_ID_NONE) {
    p_net_conn = &NetConn_Tbl[p_tcp_conn->ID_Conn];
    p_tcp_conn->FnctAppPostRx(p_net_conn->ID_App);
  }
}

/****************************************************************************************************//**
 *                                           NetTCP_TxQ_TimeoutDflt()
 *
 * @brief    Set TCP connection transmit queue to configured-default timeout value.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to set transmit queue configured-default
 *
 * @param    -----------     timeout.
 *
 * @note     (1) NetTCP_TxQ_TimeoutDflt() is called by network protocol suite function(s) &
 *               may be called either with OR without the global network lock already acquired.
 *******************************************************************************************************/
void NetTCP_TxQ_TimeoutDflt(NET_TCP_CONN_ID conn_id_tcp)
{
  CPU_INT32U timeout_ms;
  //                                                               Set TCP connection transmit queue timeout ...
  //                                                               ... to configured-default         timeout value.
  timeout_ms = NET_TCP_DFLT_TIMEOUT_CONN_TX_Q_MS;

  NetTCP_TxQ_TimeoutSet(conn_id_tcp, timeout_ms);
}

/****************************************************************************************************//**
 *                                           NetTCP_TxQ_TimeoutSet()
 *
 * @brief    Set TCP connection transmit queue timeout value.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to set transmit queue timeout.
 *
 * @param    timeout_ms      Timeout value :
 *                           NET_TMR_TIME_INFINITE,     if infinite (i.e. NO timeout) value desired.
 *                           In number of milliseconds, otherwise.
 *
 * @note     (1) NetTCP_TxQ_TimeoutSet() is called by network protocol suite function(s) & may be
 *               called either with OR without the global network lock already acquired.
 *
 * @note     (2) 'NetTCP_TxQ_TimeoutTbl_tick[]' variables MUST ALWAYS be accessed exclusively in
 *               critical sections.
 *******************************************************************************************************/
void NetTCP_TxQ_TimeoutSet(NET_TCP_CONN_ID conn_id_tcp,
                           CPU_INT32U      timeout_ms)
{
  NET_TCP_CONN *p_conn;
  CORE_DECLARE_IRQ_STATE;

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  //                                                               Set TCP connection transmit queue timeout value ...
  //                                                               ... (in OS ticks).
  CORE_ENTER_ATOMIC();
  p_conn->TxQ_SignalTimeout_ms = timeout_ms;
  CORE_EXIT_ATOMIC();
}

/****************************************************************************************************//**
 *                                       NetTCP_TxQ_TimeoutGet_ms()
 *
 * @brief    Get TCP connection transmit queue timeout value.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to get transmit queue timeout.
 *
 * @return   TCP connection transmit queue network timeout value :
 *           NET_TMR_TIME_INFINITE,     if infinite (i.e. NO timeout) value configured.
 *           In number of milliseconds, otherwise.
 *
 * @note     (1) NetTCP_TxQ_TimeoutGet_ms() is called by network protocol suite function(s) & may
 *               be called either with OR without the global network lock already acquired.
 *
 * @note     (2) 'NetTCP_TxQ_TimeoutTbl_tick[]' variables MUST ALWAYS be accessed exclusively in
 *               critical sections.
 *******************************************************************************************************/
CPU_INT32U NetTCP_TxQ_TimeoutGet_ms(NET_TCP_CONN_ID conn_id_tcp)
{
  NET_TCP_CONN *p_conn;
  CPU_INT32U   timeout_ms;
  CORE_DECLARE_IRQ_STATE;

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  CORE_ENTER_ATOMIC();
  //                                                               Get TCP connection transmit queue timeout value ...
  //                                                               ... (in OS ticks).
  timeout_ms = p_conn->TxQ_SignalTimeout_ms;
  CORE_EXIT_ATOMIC();

  return (timeout_ms);
}

/****************************************************************************************************//**
 *                                               NetTCP_Rx()
 *
 * @brief    (1) Process received segments & demultiplex to socket or application layer connection :
 *               - (a) Validate    TCP packet
 *               - (b) Demultiplex TCP packet to TCP connection
 *               - (c) Handle/Process TCP segment
 *               - (d) Return TCP error code(s)
 *
 *       - (2) Although TCP data units are typically referred to as 'segments' (see RFC #793, Section 3.1),
 *             the term 'TCP packet' (see RFC #1983, 'packet') is used for TCP Receive until the packet is
 *             validated as a TCP segment.
 *
 * @param    p_buf   Pointer to network buffer that received TCP packet.
 *
 *
 * Argument(s) : p_buf        Pointer to network buffer that received TCP packet.
 *
 *               p_err        Pointer to variable that will receive the return error code from this function.
 *
 * Return(s)   : none.
 *
 * Note(s)     : (3) TCP receive statistics already updated in NetTCP_RxPktConnHandler(); do NOT re-update.
 *
 *                   (a) Network buffer already freed & error counter already incremented in previous
 *                       function(s).
 *******************************************************************************************************/
void NetTCP_Rx(NET_BUF  *p_buf,
               RTOS_ERR *p_err)
{
  NET_BUF_HDR *p_buf_hdr;
  NET_TCP_HDR *p_tcp_hdr;

  NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxPktCtr);

  p_buf_hdr = &p_buf->Hdr;

  p_tcp_hdr = (NET_TCP_HDR *)&p_buf->DataPtr[p_buf_hdr->TransportHdrIx];
  NetTCP_RxPktValidate(p_buf, p_buf_hdr, p_tcp_hdr, p_err);     // Validate rx'd pkt.
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit_discard;
  }

  //                                                               -------------- DEMUX PKT TO TCP CONN ---------------
  NetTCP_RxPktDemuxSeg(p_buf, p_buf_hdr, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit_discard;
  }

  //                                                               --------------- HANDLE TCP PKT/CONN ----------------
  NetTCP_RxPktConnHandler(p_buf, p_buf_hdr, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit_discard;
  }

  goto exit;

exit_discard:
  NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxPktDiscardedCtr);

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_RxAppData()
 *
 * @brief    (1) Deframe application data from TCP connection's enqueued TCP segment(s) :
 *                  - (a) Wait on TCP connection application receive queue for packet buffer(s)
 *                  - (b) Deframe application data from enqueued TCP segment(s)
 *                  - (c) Update  TCP connection application receive queue
 *                      - (1) Free TCP packet buffer(s)
 *                  - (d) Update TCP connection receive window
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to receive application data.
 *
 * @param    p_data_buf      Pointer to application buffer to receive application data.
 *
 * @param    data_buf_len    Size    of application receive buffer (in octets).
 *
 * @param    flags           Flags to select receive options; bit-field flags logically OR'd :
 *
 * @param    -----            NET_TCP_FLAG_NONE               No      TCP receive flags selected.
 *                            NET_TCP_FLAG_RX_DATA_PEEK       Receive TCP application data without consuming
 *                                                            the data; i.e. data NOT removed from TCP
 *                                                            connection's application receive queue(s).
 *                            NET_TCP_FLAG_RX_BLOCK           Receive TCP application data with blocking,
 *                                                            if flag set; without blocking, if clear.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @return   Total application data octets deframed into receive buffer, if NO error(s).
 *           0, otherwise.
 *
 * @note     (2) RFC #793, Section 3.9 'Event Processing : RECEIVE Call' specifies how to handle receive
 *               data requests from the application layer :
 *               - (a) For the "CLOSED STATE ... return 'error: connection does not exist'".
 *               - (b) (1) For the "LISTEN STATE, SYN-SENT STATE, SYN-RECEIVED STATE ... queue for processing
 *                           after entering ESTABLISHED state".
 *                   - (2) The application layer may request to receive application data before the TCP
 *                           connection enters the connected state.  Such requests will block or return
 *                           no data.
 *                           See also 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #1bA'
 *                                   &  Note #4b2.
 *               - (c) For the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE" :
 *                   - (1) "If insufficient incoming segments are queued to satisfy the request, queue
 *                           the request."
 *                   - (2) "Reassemble queued incoming segments into receive buffer and return to user."
 *               - (d) For the "CLOSE-WAIT STATE ... since the remote side has already sent FIN, RECEIVEs
 *                       must be satisfied by the text already on hand, but not yet delivered to the user.
 *                       If no text is awaiting delivery, the RECEIVE will get a 'error: connection closing'
 *                       response.  Otherwise, any remaining text can be used to satisfy the RECEIVE".
 *               - (e) (1) For the "CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE ... return 'error:
 *                           connection closing'".
 *                   - (2) Typically, these states will have already received ALL remaining closing
 *                           data from the closing remote host.
 *                       - (A) However, in case all receive data from the remote host has NOT yet been
 *                               received, application layer receives from these states are permitted until
 *                               the TCP connection's sequence receive state is closed & the TCP connection's
 *                               application receive queue is empty.
 *                       - (B) If all receive data from the remote host has NOT yet been received but the
 *                               application receive queue is currently empty, return application receive
 *                               queue empty error(s).
 *                   - (3) Once a TCP connection has closed & ALL receive data has been received by the
 *                           application layer :
 *                       - (A) Close the TCP connection;
 *                       - (B) Return application receive queue closed error.
 *
 * @note     (3) (a) RFC #793, Section 3.3 states that :
 *               - (1) "Every octet of data sent over a TCP connection has a sequence number."
 *               - (2) In addition, "SYN and FIN ... control information ... [is] implicitly assign[ed]
 *                     sequence numbers ... [but] is not physically carried in the segment data space".
 *                   - (A) "For sequence number purposes, the SYN is considered to occur before the
 *                         first actual data octet of the segment in which it occurs," ...
 *                   - (B) "While the FIN is considered to occur after the last actual data octet in
 *                         a segment in which it occurs."
 *               - (3) "The segment length (SEG.LEN) includes both data and sequence space occupying
 *                     controls.
 *                   @verbatim
 *                               -----          -----------------------        Synchronization
 *                               ^            |  Initial SEQ #(SYN) |  <---  Sequence Number
 *                               |            -----------------------        (see Note #3a2A)
 *                               |            |    Data Octet #1    |  ---
 *                               |            |    Data Octet #2    |   ^
 *                                               |    Data Octet #3    |   |
 *                           TCP Connection     |          .          |   |       Data Octet
 *                           Sequences        |          .          |   |   Sequence Number(s)
 *                           (see Note #3a)     |          .          |   |    (see Note #3a1)
 *                                               | Data Octet #(N - 2) |   |
 *                               |            | Data Octet #(N - 1) |   v
 *                               |            | Data Octet #   N    |  ---       Closing
 *                               |            -----------------------        Sequence Number
 *                               v            |   Close SEQ #(FIN)  |  <---  (see Note #3a2B)
 *                               -----          -----------------------
 *
 *                   See also 'NetTCP_TxConnSync()   Note #3'
 *                           & 'NetTCP_TxConnClose()  Note #2'.
 *                   @endverbatim
 *           - (b) Therefore, since TCP synchronization or close sequence numbers are NOT actual data
 *                 sequences or octets that are transmitted or received; segments which include these
 *                 TCP control sequence numbers MUST adjust TCP data sequence numbers & TCP segment
 *                 lengths by these TCP control sequence numbers.
 *               - (1) A TCP data segment MUST adjust its data index by the possible synchronization
 *                     control sequence.
 *                   - (A) On a received TCP segment's first data read, the segment's base data index
 *                         is NOT offset -- even though for a synchronization segment, this base data
 *                         index starts on the sequence number following the synchronization control
 *                         sequence.
 *                   - (B) On any additional received TCP segment data reads, the segment's base data
 *                         index MUST be offset by possible synchronization control sequence.
 *               - (2) TCP connections & TCP data segments MUST advance their sequence numbers & adjust
 *                     their segment lengths by possible TCP control sequences.
 *                   - (A) A TCP connection MUST advance its sequence numbers by :
 *                       - (1) Possible synchronization sequence; but only on the first, initial access
 *                             to a TCP synchronization segment; ...
 *                       - (2) All accessed data sequence(s);    ...
 *                       - (3) Possible closing         sequence; which SHOULD only occur once on the
 *                             last access to a TCP closing segment.
 *                   - (B) (1) A received TCP segment MUST advance its sequence numbers by :
 *                           - (a) Possible synchronization sequence; but only on the first, initial
 *                                 access to a TCP synchronization segment; ...
 *                           - (b) All accessed data sequence(s).
 *                       - (2) (a) A received TCP segment MUST adjust its total segment length by :
 *                               - (1) Possible synchronization sequence; but only on the first, initial
 *                                     access to a TCP synchronization segment; ...
 *                               - (2) All accessed data sequence(s).
 *                               - (3) Possible closing         sequence adjustment MAY be ignored since
 *                                     all effective segment data handling occurs prior to accessing any
 *                                     trailing closing sequence.
 *                           - (b) A received TCP segment MUST adjust its data  segment length ONLY by :
 *                               - (b) All accessed data sequence(s).
 *
 * @note     (4) (a) Stream-type connections receive all data octets in one or more non-distinct packets.
 *                   In other words, the application data is NOT bounded by any specific packet(s); rather,
 *                   it is contiguous & sequenced from one packet to the next.
 *               - (b) Therefore, the TCP connection receive queue is signaled ONLY when data is received for
 *                     a connection where data was previously unavailable.
 *               - (c) Consequently, it is typical -- but NOT absolutely required -- that a single application
 *                     task only receive or request to receive application data from a TCP connection.
 *
 *               See also 'net_sock.c  NetSock_RxDataHandlerStream()  Note #2'.
 *
 * @note     (5) Since pointer arithmetic is based on the specific pointer data type & inherent pointer
 *               data type size, pointer arithmetic operands :
 *               - (a) MUST be in terms of the specific pointer data type & data type size; ...
 *               - (b) SHOULD NOT & in some cases MUST NOT be cast to other data types or data type sizes.
 *
 * @note     (6) RFC #793, Section 3.7 'Data Communication : Managing the Window' states that "the window
 *               sent in each segment indicates the range of sequence numbers the sender of the window
 *               (the data receiver) is currently prepared to accept.  There is an assumption that this
 *               is related to the currently available data buffer space available for this connection
 *               ... One strategy would be to ... [update the] information when the window is larger".
 *
 *               See also 'NetTCP_RxPktConnHandlerRxQ_Sync()  Note #5',
 *                       'NetTCP_RxPktConnHandlerRxQ_Conn()  Note #6',
 *                       & 'NetTCP_RxConnWinSizeHandler()      Note #2a'.
 *
 * @note     (7) (a) Since segments enqueued to a TCP connection's application receive queue have
 *                   already been acknowledged to the remote host & since no mechanism exists for a TCP
 *                   connection to re-request previously acknowledged segments, any TCP connection whose
 *                   application receive queue becomes corrupted MUST be closed to prevent the application
 *                   layer from receiving the corrupted data.
 *               - (b) For any internal errors where the TCP connection's application receive queue is NOT
 *                     corrupted, the TCP connection is NOT closed.  Thus the application layer may try to
 *                     re-receive the application data.
 *                     However, a TCP connection may deadlock due to persistent internal errors -- i.e. the
 *                     internal errors prevent the TCP connection from deframing application data from the
 *                     application receive queue which also prevents the TCP connection from receiving
 *                     additional application data.  Thus exception handling code in the application layer
 *                     SHOULD eventually detect & close any TCP connection deadlocked due to internal errors.
 *******************************************************************************************************/
CPU_INT16U NetTCP_RxAppData(NET_TCP_CONN_ID conn_id_tcp,
                            void            *p_data_buf,
                            CPU_INT16U      data_buf_len,
                            NET_TCP_FLAGS   flags,
                            RTOS_ERR        *p_err)
{
  CPU_BOOLEAN      block = DEF_NO;
  CPU_BOOLEAN      q_closed = DEF_NO;
  CPU_BOOLEAN      q_closed_empty = DEF_NO;
  CPU_BOOLEAN      q_prevly_empty = DEF_NO;
  CPU_BOOLEAN      peek = DEF_NO;
  CPU_BOOLEAN      frag_adv = DEF_NO;
  CPU_BOOLEAN      is_used = DEF_NO;
  NET_TCP_CONN     *p_conn = DEF_NULL;
  NET_BUF          *p_buf_head = DEF_NULL;
  NET_BUF          *p_buf_seg = DEF_NULL;
  NET_BUF          *p_buf_seg_prev = DEF_NULL;
  NET_BUF          *p_buf_seg_next = DEF_NULL;
  NET_BUF          *p_buf_frag = DEF_NULL;
  NET_BUF          *p_buf_frag_next = DEF_NULL;
  NET_BUF_HDR      *p_buf_seg_hdr = DEF_NULL;
  NET_BUF_HDR      *p_buf_seg_prev_hdr = DEF_NULL;
  NET_BUF_HDR      *p_buf_seg_next_hdr = DEF_NULL;
  NET_BUF_HDR      *p_buf_frag_hdr = DEF_NULL;
  CPU_INT08U       *p_data = DEF_NULL;
  NET_BUF_SIZE     data_ix_frag = 0u;
  NET_BUF_SIZE     data_ix_pkt = 0u;
  NET_BUF_SIZE     data_len_pkt = 0u;
  CPU_INT16U       data_len_buf_rem = 0u;
  CPU_INT16U       data_len_tot = 0u;
  NET_TCP_SEG_SIZE seg_len_avail = 0u;
  NET_TCP_SEG_SIZE seg_len_data = 0u;
  NET_TCP_SEG_SIZE seg_len_data_rem = 0u;
  NET_TCP_SEG_SIZE seg_len_data_tot = 0u;
  NET_TCP_SEG_SIZE seg_len_sync = 0u;
  NET_TCP_SEG_SIZE seg_len_sync_init = 0u;
  NET_TCP_SEQ_NBR  seq_nbr_init = 0u;
  NET_TCP_SEQ_NBR  seq_nbr_ix = 0u;
  NET_BUF_QTY      buf_nbr_freed = 0u;

  RTOS_ERR_SET(*p_err, RTOS_ERR_NONE);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit;
  }

  //                                                               ---------------- VALIDATE TCP CONN -----------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  q_closed = DEF_NO;

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_FREE:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
      data_len_tot = 0u;
      goto exit;

    case NET_TCP_CONN_STATE_CLOSED:                             // See Note #2a.
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      data_len_tot = 0u;
      goto exit;

    case NET_TCP_CONN_STATE_LISTEN:                             // See Note #2b.
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_CONN:                               // See Note #2c.
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
      break;

    case NET_TCP_CONN_STATE_CLOSE_WAIT:                         // See Note #2d.
    case NET_TCP_CONN_STATE_CLOSING:                            // See Note #2e.
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:                 // See Note #2e3.
      if (p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSED) {
        q_closed = DEF_YES;
      }
      break;

    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, 0u);
  }

  //                                                               ------------ WAIT ON TCP CONN APP RX Q -------------
  if (p_conn->RxQ_App_Head == DEF_NULL) {                       // If no rx'd data pkts;                           ...
    if (q_closed == DEF_YES) {                                  // ... & rx q closed             (see Note #2e3),  ...
      if (p_conn->ConnState == NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL) {
        //                                                         ... close data-avail TCP conn (see Note #2e3A)  ...
        NetTCP_ConnCloseHandler(p_conn, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      }

      RTOS_ERR_SET(*p_err, RTOS_ERR_NET_CONN_CLOSE_RX);         // ... & rtn rx Q closed err     (see Note #2e3B); ...
      data_len_tot = 0u;
      goto exit;
    }

    block = DEF_BIT_IS_SET(flags, NET_TCP_FLAG_RX_BLOCK);
    if (block != DEF_YES) {                                     // ... & non-blocking rx,                          ...
      RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_BLOCK);               // ... rtn rx Q empty err.
      data_len_tot = 0u;
      goto exit;
    }

    Net_GlobalLockRelease();
    NetTCP_RxQ_Wait(conn_id_tcp, p_err);
    Net_GlobalLockAcquire((void *)NetTCP_RxAppData);

    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      data_len_tot = 0u;
      goto exit;                                                // Rtn err from NetTCP_RxQ_Wait().
    }

    q_prevly_empty = DEF_YES;

    //                                                             Check is Conn state has change during Wait.
    switch (p_conn->ConnState) {
      case NET_TCP_CONN_STATE_CLOSE_WAIT:                       // See Note #2d.
      case NET_TCP_CONN_STATE_CLOSING:                          // See Note #2e.
      case NET_TCP_CONN_STATE_TIME_WAIT:
      case NET_TCP_CONN_STATE_LAST_ACK:
      case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:               // See Note #2e3.
        if (p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSED) {
          q_closed = DEF_YES;
        }
        break;

      default:
        break;
    }
  } else {
    NetTCP_RxQ_Abort(conn_id_tcp);
    NetTCP_RxQ_Clr(conn_id_tcp);                                // Clr any possible async rx Q signal.
    q_prevly_empty = DEF_NO;
  }

  //                                                               ----------- DEFRAME TCP CONN RX APP DATA -----------
  p_buf_head = p_conn->RxQ_App_Head;
  p_buf_seg = p_buf_head;
  p_buf_seg_prev = DEF_NULL;
  p_data = (CPU_INT08U *)p_data_buf;
  data_len_buf_rem = data_buf_len;
  data_len_tot = 0u;
  p_buf_seg_next = DEF_NULL;

  while ((p_buf_seg != DEF_NULL)                                // Copy app rx data from TCP conn q'd seg(s).
         && (data_len_buf_rem > 0)       ) {
    p_buf_seg_hdr = &p_buf_seg->Hdr;
    p_buf_seg_next = p_buf_seg_hdr->NextPrimListPtr;
    p_buf_frag = p_buf_seg;

    //                                                             Init seg lens.
    seg_len_data = p_buf_seg_hdr->TCP_SegLenData;
    seg_len_data_rem = seg_len_data;
    seg_len_data_tot = 0u;

    seg_len_sync = 0u;
    seg_len_sync_init = 0u;
    if (p_buf_seg_hdr->TCP_SegSync == DEF_YES) {
      seg_len_sync = NET_TCP_SEG_LEN_SYNC;
    }
    //                                                             If still init seg len, cfg init sync seg len.
    if (p_buf_seg_hdr->TCP_SegLen == p_buf_seg_hdr->TCP_SegLenInit) {
      seg_len_sync_init = seg_len_sync;
    }

    //                                                             Calc start seq nbr ix into seg data (see Note #3b1).
    seq_nbr_init = (NET_TCP_SEQ_NBR)(p_buf_seg_hdr->TCP_SeqNbrInit + seg_len_sync - seg_len_sync_init);
    seq_nbr_ix = (NET_TCP_SEQ_NBR)(p_buf_seg_hdr->TCP_SeqNbr     - seq_nbr_init);
    data_ix_frag = (NET_BUF_SIZE) seq_nbr_ix;

    frag_adv = DEF_YES;

    while ((p_buf_frag != DEF_NULL)
           && (frag_adv == DEF_YES)) {
      p_buf_frag_hdr = &p_buf_frag->Hdr;
      //                                                           While seg's frag data ix >= cur frag data len ...
      if (data_ix_frag >= p_buf_frag_hdr->DataLen) {
        data_ix_frag -= p_buf_frag_hdr->DataLen;
        p_buf_frag_next = p_buf_frag_hdr->NextBufPtr;
        p_buf_frag = p_buf_frag_next;                           // ... adv to next seg frag.
      } else {
        frag_adv = DEF_NO;
      }
    }

    while ((p_buf_frag != DEF_NULL)                             // Copy app rx data from avail seg pkt buf(s).
           && (data_len_buf_rem > 0)
           && (seg_len_data_rem > 0)       ) {
      p_buf_frag_hdr = &p_buf_frag->Hdr;
      p_buf_frag_next = p_buf_frag_hdr->NextBufPtr;

      seg_len_avail = (NET_TCP_SEG_SIZE)(p_buf_frag_hdr->DataLen - data_ix_frag);
      if (seg_len_avail > seg_len_data_rem) {                   // If seg frag pkt data len > rem seg len, ...
        seg_len_avail = seg_len_data_rem;                       // ... lim copy to rem seg len.
      }

      data_len_pkt = DEF_MIN((NET_BUF_SIZE)data_len_buf_rem,        // Lim copy to min of rem'ing data buf len ...
                             (NET_BUF_SIZE)seg_len_avail);        // ... or avail seg len.
                                                                  // Calc ix into seg frag's data.
      data_ix_pkt = (NET_BUF_SIZE)p_buf_frag_hdr->DataIx + data_ix_frag;
      data_ix_frag = 0u;

      NetBuf_DataRd(p_buf_frag,
                    data_ix_pkt,
                    data_len_pkt,
                    p_data);

      //                                                           Update data ptr & lens.
      p_data += data_len_pkt;                                   // MUST NOT cast ptr operand (see Note #5b).
      data_len_tot += (CPU_INT16U)data_len_pkt;
      data_len_buf_rem -= (CPU_INT16U)data_len_pkt;
      seg_len_data_tot += (CPU_INT16U)data_len_pkt;
      seg_len_data_rem -= (CPU_INT16U)data_len_pkt;

      p_buf_frag = p_buf_frag_next;
    }

    if (data_len_buf_rem > 0) {                                 // If rem data buf len > 0, ...
      p_buf_seg_prev = p_buf_seg;
      p_buf_seg = p_buf_seg_next;                               // ... adv to next q'd seg.
    }
  }

  q_closed_empty = ((q_closed == DEF_YES)                       // Chk rx q closed ...
                    && (data_len_tot < 1)) ? DEF_YES : DEF_NO;  // ... & empty (i.e. no rx'd data).

  //                                                               ------------- UPDATE TCP CONN APP RX Q -------------
  peek = DEF_BIT_IS_SET(flags, NET_TCP_FLAG_RX_DATA_PEEK);
  if (peek == DEF_YES) {                                        // If peek opt req'd                      ...
    if (q_prevly_empty == DEF_YES) {                            // ... & TCP conn app rx Q prev'ly empty, ...
      NetTCP_RxQ_Signal(conn_id_tcp);                           // ...     signal app rx Q                ...
    }
  }

  if ((peek != DEF_YES)                                         // If peek opt NOT req'd                         ..
      || (q_closed_empty != DEF_NO)) {                          // .. or rx q closed & empty, unlink ALL seg pkt ..
                                                                // .. buf(s) whose data was entirely consumed.

    if (p_buf_seg != DEF_NULL) {                                // If TCP conn app rx Q NOT empty after data rd(s)
      if (seg_len_data_rem > 0) {                               // .. & cur seg's rem data len > 0;              ..
        p_buf_seg_hdr->PrevPrimListPtr = DEF_NULL;              // ..   unlink from prev q'd seg(s),             ..
        p_conn->RxQ_App_Head = p_buf_seg;                       // ..   set new TCP conn app rx Q head,          ..
                                                                // .. & update seg's seq nbr  (see Note #3b2B1)  ..
        p_buf_seg_hdr->TCP_SeqNbr += (seg_len_data_tot + seg_len_sync_init);
        //                                                         ..        & seg's seg lens (see Note #3b2B2).
        p_buf_seg_hdr->TCP_SegLen -= (seg_len_data_tot + seg_len_sync_init);
        p_buf_seg_hdr->TCP_SegLenData -= seg_len_data_tot;

        if (p_buf_seg_prev != DEF_NULL) {                       // If prev q'd seg(s) avail, ...
                                                                // ... unlink from app rx Q  ...
          p_buf_seg_prev_hdr = &p_buf_seg_prev->Hdr;
          p_buf_seg_prev_hdr->NextPrimListPtr = DEF_NULL;
          buf_nbr_freed += NetTCP_RxPktFree(p_buf_head);           // ... & free ALL rd seg pkt buf(s).
        }
      } else {                                                  // Else if cur seg's rem data len = 0     ...
        if (p_buf_seg_next != DEF_NULL) {                       // ... &    rem rx q'd seg(s) avail,      ...
                                                                // ... unlink cur seg from rem q'd seg(s) ...
          p_buf_seg_next_hdr = &p_buf_seg_next->Hdr;
          p_buf_seg_next_hdr->PrevPrimListPtr = DEF_NULL;
          p_buf_seg_hdr->NextPrimListPtr = DEF_NULL;
          //                                                       ... set new TCP conn app rx Q head;    ...
          p_conn->RxQ_App_Head = p_buf_seg_next;
        } else {                                                // ... & NO rem rx q'd seg(s) avail,      ...
                                                                // ... unlink  ALL q'd seg(s);            ...
          p_conn->RxQ_App_Head = DEF_NULL;
          p_conn->RxQ_App_Tail = DEF_NULL;
        }

        buf_nbr_freed += NetTCP_RxPktFree(p_buf_head);          // ... & free rd  seg pkt buf(s) from app rx Q.
      }
    } else {                                                    // Else clr app rx Q ...
      p_conn->RxQ_App_Head = DEF_NULL;
      p_conn->RxQ_App_Tail = DEF_NULL;

      buf_nbr_freed += NetTCP_RxPktFree(p_buf_head);            // ... & free ALL seg pkt buf(s) from app rx Q.
    }

    //                                                             ----------- UPDATE TCP CONN RX WIN SIZE ------------
    //                                                             Inc TCP conn's rx win size (see Note #6).
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
    NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, data_len_tot, NET_TCP_CONN_RX_WIN_INC);
#else
    NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, buf_nbr_freed, NET_TCP_CONN_RX_WIN_INC);
#endif
  }

  if (q_closed_empty == DEF_YES) {                              // If rx q closed & empty,                       ..
    if (p_conn->ConnState == NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL) {
      //                                                           .. close data-avail TCP conn (see Note #2e3A) ..
      NetTCP_ConnCloseHandler(p_conn, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
    }

    RTOS_ERR_SET(*p_err, RTOS_ERR_NET_CONN_CLOSE_RX);           // .. & rtn rx Q closed err     (see Note #2e3B).
    data_len_tot = 0u;
    goto exit;
  }

#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
  PP_UNUSED_PARAM(buf_nbr_freed);
#endif

exit:
  return (data_len_tot);
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnReq()
 *
 * @brief    (1) Transmit TCP connection request :
 *
 *           - (a) Update   TCP connection state
 *           - (b) Transmit TCP connection request
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to transmit connection request.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) On ANY error(s), return error to TCP connection caller & allow caller to retry or close
 *                           connection(s) but do NOT close TCP connection.
 *******************************************************************************************************/
void NetTCP_TxConnReq(NET_TCP_CONN_ID conn_id_tcp,
                      RTOS_ERR        *p_err)
{
  NET_TCP_CONN       *p_conn;
  NET_TCP_CONN_STATE state;
  CPU_BOOLEAN        is_used;

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit;
  }

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  //                                                               ------------- VALIDATE TCP CONN STATE --------------
  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
      break;

    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  //                                                               -------------- UPDATE TCP CONN STATE ---------------
  state = p_conn->ConnState;
  p_conn->ConnState = NET_TCP_CONN_STATE_SYNC_TXD;

  //                                                               ----------------- TX TCP CONN REQ ------------------
  NetTCP_TxConnSync(p_conn, DEF_NULL, state, p_err);

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnReqClose()
 *
 * @brief    (1) Transmit TCP connection close :
 *               - (a) Handle TCP connection close                             See Note #2a
 *               - (b) Update TCP connection timer                             See Note #2b
 *
 * @param    conn_id_tcp         Handle identifier of TCP connection to transmit connection close.
 *
 * @param    conn_close_code     Indicate whether to close transport connection :
 *                               NET_CONN_CLOSE_FULL         Close TCP connection but do NOT allow
 *                                                           closing receive data to be available.
 *                               NET_CONN_CLOSE_HALF         Close TCP connection but        allow
 *                                                           closing receive data to be available.
 *
 * @param    p_err               Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) (a) RFC #793, Section 3.9 'Event Processing : CLOSE Call' specifies how to handle
 *                   close requests from the application layer :
 *                   - (1) For the "CLOSED STATE ... return 'error: connection does not exist'".
 *                   - (2) For the "LISTEN STATE ... any outstanding RECEIVEs are returned with 'error:
 *                         closing' responses.  Delete TCB [and] enter CLOSED state".
 *                   - (3) For the "SYN-SENT STATE ... Delete the TCB and return 'error: closing'
 *                         responses to any queued SENDs, or RECEIVEs".
 *                   - (4) For the "SYN-RECEIVED STATE" :
 *                       - (A) "If no SENDs have been issued and there is no pending data to send," ...
 *                           - (1) "then form a FIN segment and send it,"                           ...
 *                           - (2) "and enter FIN-WAIT-1 state;"                                    ...
 *                       - (B) "Otherwise queue for processing after entering ESTABLISHED state."
 *                   - (5) For the "ESTABLISHED STATE" :
 *                       - (A) "Queue this until all preceding SENDs have been segmentized," ...
 *                       - (B) "then form a FIN segment and send it"                         ...
 *                       - (C) "In any case, enter FIN-WAIT-1 state."
 *                   - (6) For the "FIN-WAIT-1 STATE, FIN-WAIT-2 STATE" :
 *                       - (A) "Strictly speaking, this is an error and should receive a 'error: connection
 *                             closing' response."
 *                       - (B) "An 'ok' response would be acceptable, too, as long as a second FIN is not
 *                             emitted (the first FIN may be retransmitted though)."
 *                   - (7) For the "CLOSE-WAIT STATE" :
 *                       - (A) "Queue this request until all preceding SENDs have been segmentized;" ...
 *                       - (B) "then send a FIN segment,"                                            ...
 *                       - (C) (1) "Enter CLOSING state."
 *                           - (2) RFC #1122, Section 4.2.2.20.(a) amends the state transition to "enter
 *                                 LAST-ACK state, not CLOSING".
 *                   - (8) For the "CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE ... respond with 'error:
 *                         connection closing'".
 *             - (b) RFC #793, Section 3.9 'Event Processing : CLOSE Call' does NOT specify which timeout
 *                   values to set for each state transition to closing state(s).
 *                   #### Therefore, the following timeout values will be used for the following close
 *                   state transitions :
 *                 - (1) SYN-RECEIVED STATE  ->  FIN-WAIT-1 STATE                TCP Connection timeout
 *                       See also 'NetTCP_RxPktConnHandlerSyncRxd()  Note #3'.
 *                 - (2) ESTABLISHED  STATE  ->  FIN-WAIT-1 STATE                TCP Connection timeout
 *                       See also 'NetTCP_RxPktConnHandlerConn()     Note #3'.
 *                 - (3) CLOSE-WAIT   STATE  ->  LAST-ACK   STATE                TCP Time-Wait / Two TCP Maximum
 *                       Segment Lifetimes timeout
 *                       See also 'NetTCP_RxPktConnHandlerLastAck()  Note #3'.
 *             - (c) RFC #1122, Section 4.2.2.13 states that "a TCP connection may terminate in two ways" :
 *                 - (1) "The normal TCP close sequence using a FIN handshake."
 *                 - (2) "An 'abort' in which one or more RST segments are sent and the connection state
 *                       is immediately discarded."
 *
 * @note     (3) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                   FIN-WAIT-2 STATE' states that "if the retransmission queue is empty, the user's
 *                   CLOSE can be acknowledged".
 *             - (b) However, TCP connection should signal the application layer that "the user's close
 *                   [is] acknowledged" whenever its re-transmit queue becomes &/or is empty :
 *                 - (1) Transition from LISTEN   to CLOSED
 *                 - (2) Transition from SYN-SENT to CLOSED
 *                   See also 'NetTCP_RxPktConnHandlerSignalClose()  Note #1'.
 *
 * @note     (4) On ANY error(s), network resources MUST be appropriately freed :
 *               - (a) Close the TCP connection.
 *******************************************************************************************************/
void NetTCP_TxConnReqClose(NET_TCP_CONN_ID conn_id_tcp,
                           CPU_INT08U      conn_close_code,
                           RTOS_ERR        *p_err)
{
  NET_TCP_CONN       *p_conn;
  NET_TCP_CONN_STATE state;
  CPU_INT32U         timeout_ms = 0u;
  CPU_BOOLEAN        is_used;
  RTOS_ERR           local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit;
  }

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  //                                                               -------------- HANDLE TCP CONN CLOSE ---------------
  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_FREE:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
      goto exit;

    case NET_TCP_CONN_STATE_CLOSED:                             // See Note #2a1.
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_LISTEN:                             // See Note #2a2.
    case NET_TCP_CONN_STATE_SYNC_TXD:                           // See Note #2a3.
                                                                // Signal app conn close (see Note #3b) ...
      NetTCP_RxPktConnHandlerSignalClose(p_conn, DEF_NO, &local_err);
      //                                                           ... & close TCP conn.
      NetTCP_ConnCloseHandler(p_conn, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;

    case NET_TCP_CONN_STATE_SYNC_RXD:                           // See Note #2a4.
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_CONN:                               // See Note #2a5.
                                                                // Enter fin-wait-1 state  (see Note #2a5C),        ...
      state = p_conn->ConnState;
      p_conn->ConnState = NET_TCP_CONN_STATE_FIN_WAIT_1;
      p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSING;
      p_conn->ConnCloseCode = conn_close_code;
      //                                                           ... reset conn tmr (see Notes #2b1 & #2b2), ...
      timeout_ms = p_conn->TimeoutConn_sec * DEF_TIME_NBR_mS_PER_SEC;

      NetTCP_TxConnClose(p_conn, state, p_err);                 // ... & tx TCP conn close (see Note #2a5B).
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_CLOSE_WAIT:                         // See Note #2a7.
                                                                // Enter last-ack state    (see Note #2a7C2), ...
      state = p_conn->ConnState;
      p_conn->ConnState = NET_TCP_CONN_STATE_LAST_ACK;
      p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSING;
      p_conn->ConnCloseCode = conn_close_code;
      //                                                           ... start time-wait tmr (see Note #2b3),   ...
      timeout_ms = p_conn->TimeoutConn_sec * DEF_TIME_NBR_mS_PER_SEC;

      NetTCP_TxConnClose(p_conn, state, p_err);                 // ... & tx TCP conn close (see Note #2a7B).
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_FIN_WAIT_1:                         // See Note #2a6.
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:                          // See Note #2a8.
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  //                                                               -------------------- UPDATE TMR --------------------
  if (p_conn->TimeoutTmr != DEF_NULL) {
    NetTmr_Set(p_conn->TimeoutTmr,
               NetTCP_ConnIdleTimeout,
               timeout_ms);
  } else {
    p_conn->TimeoutTmr = NetTmr_Get(NetTCP_ConnIdleTimeout,
                                    p_conn,
                                    timeout_ms,
                                    NET_TMR_OPT_NONE,
                                    p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, DEF_NULL, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
    }
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnAppData()
 *
 * @brief    (1) Prepare & transmit data from Application layer(s) via TCP connection :
 *               - (a) Validate application data
 *               - (b) Transmit application data via TCP Transmit :
 *                   - (1) Validate TCP connection
 *                   - (2) Wait on  TCP connection transmit queue
 *                   - (3) Prepare  TCP data segment(s) :
 *                       - (A) TCP segment addresses
 *                       - (B) Prepare application data :
 *                           - (1) Get buffer(s) for application data
 *                           - (2) Copy application data into TCP packet buffer(s)
 *                           - (3) Update TCP segment data controls
 *                           - (4) Update application data controls
 *                   - (4) Update TCP connection transmit window
 *               - (c) Update TCP connection :
 *                   - (1) Append TCP transmit segment(s) to TCP connection transmit queue
 *                   - (2) Update TCP connection sequence number(s)
 *               - (d) Transmit TCP data segment(s) via TCP Transmit
 *
 * @param    conn_id_tcp     Handle identifier of connection to transmit application data.
 *
 * @param    p_data          Pointer to application data.
 *
 * @param    data_len        Length  of application data (in octets) [see Note #4].
 *
 * @param    flags           Flags to select transmit options; bit-field flags logically OR'd :
 *
 * @param    -----           NET_TCP_FLAG_NONE               No       TCP transmit flags selected.
 *                           NET_TCP_FLAG_TX_BLOCK           Transmit TCP application data with blocking,
 *                                                           if flag set; without blocking, if clear.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @return   Number of data octets transmitted, if NO error(s).
 *           0, otherwise.
 *
 * @note     (2) RFC #793, Section 3.9 'Event Processing : SEND Call' specifies how to handle transmit
 *               data requests from the application layer :
 *               - (a) For the "CLOSED STATE ... return 'error: connection does not exist'".
 *               - (b) For the "LISTEN STATE" :
 *                       - (A) TCP Listen state transmit NOT yet implemented;
 *                             see also 'net_sock.c  NetSock_TxDataHandlerStream()  Note #2aA'.
 *                             #### NET-815
 *                   - (1) "If the foreign socket is specified, then" :
 *                       - (A) "Change the connection from passive to active," ...
 *                       - (B) "Select an ISS"                                 ...
 *                       - (C) "Send a SYN segment,"                           ...
 *                       - (D) "Set" :
 *                           - (1) "SND.UNA to ISS," ...
 *                           - (2) "SND.NXT to ISS+1."
 *                       - (E) "Enter SYN-SENT state."
 *                       - (F) "Data associated with SEND may be" ...
 *                           - (1) "sent with SYN segment"        ...
 *                           - (2) (a) "or queued for transmission after entering ESTABLISHED state."
 *                               - (b) "If there is no room to queue the request, respond with 'error:
 *                                     insufficient resources'."
 *                   - (2) "If Foreign [sic] socket was not specified, then return 'error: foreign socket
 *                         unspecified'."
 *               - (c) For the "SYN-SENT STATE, SYN-RECEIVED STATE" :
 *                   - (1) "Queue the data for transmission after entering ESTABLISHED state."
 *                   - (2) "If no space to queue, respond with 'error: insufficient resources'."
 *               - (d) For the "ESTABLISHED STATE, CLOSE-WAIT STATE" :
 *                   - (1) (A) "Segmentize the buffer"                         ...
 *                       - (B) "and send it with a piggybacked acknowledgment" ...
 *                           - (1) "(acknowledgment value = RCV.NXT)"
 *                   - (2) "If there is no insufficient space to remember this buffer, simply return
 *                         'error: insufficient resources'."
 *               - (e) For the "FIN-WAIT-1 STATE, FIN-WAIT-2 STATE, CLOSING STATE, LAST-ACK STATE,
 *                       TIME-WAIT STATE" :
 *                   - (1) "Return 'error: connection closing'" ...
 *                   - (2) "and do not service request."
 *
 * @note     (3) TCP segments with transmit data are sequenced into the TCP connection's transmit
 *               queue to await transmission at the appropriate time(s) [see 'NetTCP_TxConnTxQ()
 *               Note #1b'].
 *               - (a) Transmit TCP segments are inserted into a doubly-linked Transmit Queue, ordered
 *                     consecutively by sequence number(s) [see also Note #3b1].
 *                     In the diagram below, ... :
 *                   - (1) (A) TCP connections' 'TxQ_Head' points to the head of a TCP connections'
 *                             Transmit Queue;
 *                       - (B) TCP connections' 'TxQ_Tail' points to the tail of a TCP connections'
 *                             Transmit Queue.
 *                   - (2) Segment buffers' 'PrevPrimListPtr' & 'NextPrimListPtr' doubly-link each
 *                         segment to form the Transmit Queue.
 *               - (b) (1) Transmit data is packetized into TCP segments in sequence-order.  Therefore,
 *                         new transmit segments are sequenced after previously packetized segments
 *                         starting at the tail of the Transmit Queue.
 *                   - (2) Segments at the head of the Transmit Queue are available & ready to be
 *                         transmitted via the Internet Transmit Layer.
 *                         @verbatim
 *                                       |                                               |
 *                                       |<------- TCP Connection Transmit Queue ------->|
 *                                       |                (see Note #3)                  |
 *
 *                                   Segments Ready                           Segments Sequenced
 *                                   to Transmit                             into Transmit Queue
 *                                   start at head                             starting at tail
 *                               (see Note #3b2)                            (see Note #3b1)
 *
 *                                       |             NextPrimListPtr             |
 *                                       |             (see Note #3a2)             |
 *                                       v                    |                    v
 *                                                            |
 *                     Head of        -------       -------   v   -------       -------  (see Note #3a1B)
 *                     Transmit  ---->|     |------>|     |------>|     |------>|     |
 *                      Queue         |     |       |     |       |     |       |     |       Tail of
 *                                    |     |<------|     |<------|     |<------|     |<----  Transmit
 *                (see Note #3a1A)    |     |       |     |   ^   |     |       |     |        Queue
 *                                    |     |       |     |   |   |     |       |     |
 *                                    -------       -------   |   -------       -------
 *                                                            |
 *                                                    PrevPrimListPtr
 *                                                    (see Note #3a2)
 *                         @endverbatim
 *
 * @note     (4) 'data_len' of 0 octets NOT allowed.
 *
 * @note     (5) Certain network connections MUST periodically suspend network transmit(s) to handle
 *               network receive packet(s).  To protect TCP connections from transmit corruption while
 *               suspended, ALL TCP data transmits & TCP transmit queue handling MUST be blocked for
 *               suspended connections until the connection is no longer suspended.
 *
 *               See also 'NetTCP_TxConnTxQ()  Note #12b2A2'.
 *
 * @note     (6) (a) RFC #793, Section 3.8 'Interfaces : User/TCP Interface : TCP User Commands : Send'
 *                 states that :
 *                 - (1) "If the PUSH flag is set, the data must be transmitted promptly to the receiver,
 *                        and the PUSH bit will be set in the last TCP segment created from the buffer."
 *                 - (2) "If the PUSH flag is not set, the data may be combined with data from subsequent
 *                        SENDs for transmission efficiency."
 *             - (b) RFC #1122, Section 4.2.2.2 states that :
 *                 - (1) "When an application issues a series of SEND calls without setting the PUSH
 *                        flag, the TCP MAY aggregate the data internally without sending it."
 *                 - (2) "The PSH bit is not a record marker and is independent of segment boundaries.
 *                        The transmitter SHOULD collapse successive PSH bits when it packetizes data,
 *                        to send the largest possible segment.
 *                 - (3) (A) "A TCP MAY implement PUSH flags on SEND calls."
 *                     - (B) (1) "If PUSH flags are not implemented, then the sending TCP : ...
 *                             - (a) must not buffer data indefinitely, and ...
 *                             - (b) MUST set the PSH bit in the last buffered segment (i.e., when
 *                                   there is no more queued data to be sent)."
 *                                 - (1) However, NO RFC specifies whether the PUSH bit should be
 *                                       set ONLY in the last buffered segment.  Therefore, is is
 *                                       assumed that the PUSH bit MAY be set in the last buffered
 *                                       segment of each call to SEND.
 *                         - (2) "When the PUSH flag is not implemented on SEND calls, i.e., when
 *                                the application/TCP interface uses a pure streaming model,
 *                                responsibility for aggregating any tiny data fragments to form
 *                                reasonable sized segments is partially borne by the application
 *                                layer."
 *                 - (4) (A) "An application program is logically required to set the PUSH flag in a
 *                            SEND call whenever it needs to force delivery of the data to avoid a
 *                            communication deadlock.  However, a TCP SHOULD send a maximum-sized
 *                            segment whenever possible, to improve performance."
 *                     - (B) "Generally, an interactive application protocol must set the PUSH flag
 *                            at least in the last SEND call in each command or response sequence."
 *
 * @note     (7) Since pointer arithmetic is based on the specific pointer data type & inherent pointer
 *               data type size, pointer arithmetic operands :
 *               - (a) MUST be in terms of the specific pointer data type & data type size; ...
 *               - (b) SHOULD NOT & in some cases MUST NOT be cast to other data types or data type sizes.
 *
 * @note     (8) Network buffers allocated for TCP connection transmit SHOULD be fully used even if
 *               the TCP connection's configured transmit window is zero.
 *               See also 'NetTCP_TxConnWinSizeHandlerCfgd()  Note #2'.
 *
 * @note     (9) Network buffers' reference counters MUST be incremented to include the queued TCP
 *               segments as new  references to the network buffers.  However, these additional references
 *               are handled when the TCP segments are enqueued to the TCP connection's re-transmit queue
 *               (see 'NetTCP_TxConnTxQ()  Note #10').
 *
 *           10) (a) Since segments enqueued to a TCP connection's transmit queue have already been
 *                   reported as transmitted to the application & since no mechanism exists for a TCP
 *                   connection to re-request previously transmitted data, any TCP connection whose
 *                   transmit queue becomes corrupted MUST be closed to force the application layer to
 *                   abort &/or recover from the corrupted data.
 *             - (b) For any internal errors where the TCP connection's transmit queue is NOT corrupted,
 *                   the TCP connection is NOT closed.  Thus the application layer may try to re-transmit
 *                   the application data.
 *
 *             - (c) On ANY transmit error, any remaining application data transmit is immediately aborted.
 *               See also 'NetTCP_TxConnTxQ()    Note #14'.
 *                       & 'NetTCP_TxConnReTxQ()  Note #11'.
 *******************************************************************************************************/
CPU_INT16U NetTCP_TxConnAppData(NET_TCP_CONN_ID conn_id_tcp,
                                void            *p_data,
                                CPU_INT16U      data_len,
                                NET_TCP_FLAGS   flags,
                                RTOS_ERR        *p_err)
{
#ifdef  NET_IPv4_MODULE_EN
  NET_IPv4_ADDR src_addrv4 = NET_IPv4_ADDR_NONE;
  NET_IPv4_ADDR dest_addrv4 = NET_IPv4_ADDR_NONE;
#endif
#ifdef  NET_IPv6_MODULE_EN
  NET_IPv6_ADDR src_addrv6 = NET_IPv6_ADDR_NONE;
  NET_IPv6_ADDR dest_addrv6 = NET_IPv6_ADDR_NONE;
#endif
  NET_TCP_CONN       *p_conn = DEF_NULL;
  NET_TCP_PORT_NBR   src_port = NET_PORT_NBR_NONE;
  NET_TCP_PORT_NBR   dest_port = NET_PORT_NBR_NONE;
  NET_TCP_TX_Q_STATE wait_state = NET_TCP_TX_Q_STATE_NONE;
  NET_CONN_ID        conn_id = NET_CONN_ID_NONE;
  NET_CONN           *p_net_conn = DEF_NULL;
  NET_IF_NBR         if_nbr = NET_IF_NBR_NONE;
  NET_BUF            *p_buf = DEF_NULL;
  NET_BUF            *p_buf_head = DEF_NULL;
  NET_BUF            *p_buf_tail = DEF_NULL;
  NET_BUF            *p_buf_q_tail = DEF_NULL;
  NET_BUF_HDR        *p_buf_hdr = DEF_NULL;
  NET_BUF_HDR        *p_buf_hdr_head = DEF_NULL;
  NET_BUF_HDR        *p_buf_hdr_tail = DEF_NULL;
  NET_BUF_HDR        *p_buf_hdr_q_tail = DEF_NULL;
  NET_BUF_SIZE       buf_size_max = 0u;
  NET_BUF_SIZE       buf_size_max_data = 0u;
  NET_BUF_SIZE       buf_size_max_tail = 0u;
  NET_BUF_SIZE       buf_size_max_tail_data = 0u;
  NET_BUF_SIZE       data_ix_pkt = 0u;
  NET_BUF_SIZE       data_ix_pkt_offset = 0u;
  NET_BUF_SIZE       data_ix_pkt_tail = 0u;
  NET_BUF_SIZE       data_len_pkt_tail = 0u;
  NET_BUF_SIZE       data_len_pkt = 0u;
  NET_BUF_SIZE       data_len_pkt_rem = 0u;
  NET_BUF_SIZE       data_len_rem_min = 0u;
  NET_BUF_SIZE       data_len_mss = 0u;
  CPU_INT16U         data_len_rem = 0u;
  CPU_INT16U         data_len_tot = 0u;
  CPU_INT08U         *p_data_pkt = DEF_NULL;
  NET_TCP_FLAGS      flags_tcp = NET_TCP_FLAG_NONE;
  CPU_BOOLEAN        tx_q_append = DEF_NO;
  CPU_BOOLEAN        tx_data = DEF_NO;
  CPU_BOOLEAN        tx_err = DEF_NO;
  CPU_BOOLEAN        block = DEF_NO;
  CPU_BOOLEAN        is_used = DEF_NO;
  NET_TCP_SEQ_NBR    seq_nbr = 0u;
  NET_PROTOCOL_TYPE  proto_type = NET_PROTOCOL_TYPE_NONE;

  RTOS_ASSERT_DBG_ERR_SET(p_data != DEF_NULL, *p_err, RTOS_ERR_NULL_PTR, 0u);
  RTOS_ASSERT_DBG_ERR_SET(data_len >= 1, *p_err, RTOS_ERR_INVALID_ARG, 0u);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit;
  }

  //                                                               ---------------- VALIDATE TCP CONN -----------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  switch (p_conn->ConnState) {                                  // Validate conn state.
    case NET_TCP_CONN_STATE_CLOSED:                             // See Note #2a.
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_LISTEN:                             // See Note #2b.
                                                                // NOT yet implemented (see Note #2bA).
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_SYNC_RXD:                           // See Note #2c.
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
      tx_data = DEF_NO;
      break;

    case NET_TCP_CONN_STATE_CONN:                               // See Note #2d.
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
      tx_data = DEF_YES;
      break;

    case NET_TCP_CONN_STATE_FIN_WAIT_1:                         // See Note #2e.
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, 0u);
  }

  switch (p_conn->TxQ_State) {                                  // Validate tx Q state.
    case NET_TCP_TX_Q_STATE_CONN:
    case NET_TCP_TX_Q_STATE_CLOSING:
      block = DEF_NO;
      break;

    case NET_TCP_TX_Q_STATE_SUSPEND:                            // See Note #5.
    case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
    case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
      block = DEF_BIT_IS_SET(flags, NET_TCP_FLAG_TX_BLOCK);
      if (block == DEF_YES) {
        wait_state = p_conn->TxQ_State;
      } else {
        RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_BLOCK);
        goto exit;
      }
      break;

    case NET_TCP_TX_Q_STATE_CLOSED:                             // TODO_NET : Should not happen. Check if Assert would
                                                                // be better. Would mean that connState can be
                                                                // NET_TCP_CONN_STATE_CONN and TxQ_State can be
                                                                // NET_TCP_TX_Q_STATE_CLOSED.
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_TX_Q_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, 0u);
  }

  if (block == DEF_YES) {
    RTOS_ERR local_err;

    while (p_conn->TxQ_State == wait_state) {
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      Net_GlobalLockRelease();
      NetTCP_TxQ_Wait(conn_id_tcp, &local_err);
      Net_GlobalLockAcquire((void *)NetTCP_TxConnAppData);
    }
  }

  //                                                               -------------- WAIT ON TCP CONN TX Q ---------------
  if (tx_data == DEF_YES) {                                     // If tx rdy,                    ...
    if (data_len < 1) {                                         // ... but  NO tx data avail,    ...
                                                                // ... tx q'd data OR immed ack; ...
      NetTCP_TxConnTxQ(p_conn, 0, NET_TCP_CONN_TX_ACK_IMMED, DEF_NO, NET_TCP_CONN_CLOSE_ALL, DEF_YES, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      goto exit;
    }
    //                                                             ... Else if tx data avail,    ...
    if (p_conn->TxWinSizeCfgdRem < 1) {                         // ... but tx Q full             ...
      block = DEF_BIT_IS_SET(flags, NET_TCP_FLAG_TX_BLOCK);
      if (block != DEF_YES) {                                   // ... & non-blocking tx,        ...
        RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_BLOCK);                 // ... rtn tx Q full err.
        goto exit;
      }

      Net_GlobalLockRelease();
      NetTCP_TxQ_Wait(conn_id_tcp, p_err);
      Net_GlobalLockAcquire((void *)NetTCP_TxConnAppData);

      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;                                              // Rtn err from NetTCP_TxQ_Wait().
      }
    } else {
      NetTCP_TxQ_Abort(conn_id_tcp);
      NetTCP_TxQ_Clr(conn_id_tcp);                              // Clr any possible async tx Q signal.
    }
  }

  //                                                               ------- PREPARE APP TX DATA INTO TCP SEG(S) --------
  //                                                               Prepare seg addrs.
  conn_id = p_conn->ID_Conn;
  p_net_conn = &NetConn_Tbl[conn_id];

  if (p_net_conn->Family == NET_SOCK_FAMILY_IP_V4) {
#ifdef  NET_IPv4_MODULE_EN
    NetTCP_TxConnPrepareSegAddrs(p_conn,
                                 (CPU_INT08U *)&src_addrv4,
                                 (CPU_INT08U *)&src_port,
                                 sizeof(src_addrv4),
                                 sizeof(src_port),
                                 (CPU_INT08U *)&dest_addrv4,
                                 (CPU_INT08U *)&dest_port,
                                 sizeof(dest_addrv4),
                                 sizeof(dest_port),
                                 p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
#endif
  } else if (p_net_conn->Family == NET_SOCK_FAMILY_IP_V6) {
#ifdef  NET_IPv6_MODULE_EN
    NetTCP_TxConnPrepareSegAddrs(p_conn,
                                 (CPU_INT08U *)&src_addrv6,
                                 (CPU_INT08U *)&src_port,
                                 sizeof(src_addrv6),
                                 sizeof(src_port),
                                 (CPU_INT08U *)&dest_addrv6,
                                 (CPU_INT08U *)&dest_port,
                                 sizeof(dest_addrv6),
                                 sizeof(dest_port),
                                 p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
#endif
  }

  conn_id = p_conn->ID_Conn;
  if_nbr = NetConn_IF_NbrGet(conn_id);

  p_buf_head = DEF_NULL;
  p_buf_tail = DEF_NULL;
  p_data_pkt = (CPU_INT08U *)p_data;
  tx_q_append = DEF_YES;

  data_len_mss = p_conn->MaxSegSizeConn;
  data_len_rem = data_len;
  data_len_tot = 0u;
  //                                                               Prepare TCP tx seg hdr ctrls.
  seq_nbr = p_conn->TxSeqNbrNextQ;
  flags_tcp = NET_TCP_FLAG_NONE
              | NET_TCP_FLAG_TX_ACK;

  if (data_len_mss <= 0) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_WOULD_BLOCK);
    goto exit;
  }

  if (p_conn->TxQ_Tail != DEF_NULL) {                           // If tx Q NOT empty;                            ...
    p_buf = p_conn->TxQ_Tail;
    p_buf_hdr = &p_buf->Hdr;

    data_ix_pkt_tail = p_buf_hdr->DataIx;
    data_len_pkt_tail = p_buf_hdr->TCP_SegLenData;
    //                                                             ... calc tail seg's max data size,            ...
    buf_size_max_tail = NetBuf_GetMaxSize(if_nbr, NET_TRANSACTION_TX, p_buf, data_ix_pkt_tail);

    buf_size_max_tail_data = DEF_MIN(buf_size_max_tail, data_len_mss);

    if (data_len_pkt_tail < buf_size_max_tail_data) {           // ... & if avail data space on tx Q's tail seg, ...
                                                                // ... append data on tx Q tail seg (see Note #6b1).
      data_ix_pkt = data_ix_pkt_tail       + data_len_pkt_tail;
      data_len_pkt_rem = buf_size_max_tail_data - data_len_pkt_tail;
      //                                                           Lim pkt data len to min of rem'ing data len, ...
      //                                                           ... pkt data len or cfg'd tx win size.
      data_len_rem_min = DEF_MIN(data_len_pkt_rem, data_len_rem);
      data_len_pkt = DEF_MIN(data_len_rem_min, p_conn->TxWinSizeCfgdRem);

      //                                                           Wr app data into TCP tx buf.
      NetBuf_DataWr(p_buf, data_ix_pkt, data_len_pkt, p_data_pkt);

      //                                                           Update TCP seg tx buf ctrls.
      p_buf_hdr->DataLen += data_len_pkt;
      p_buf_hdr->TotLen += data_len_pkt;

      p_buf_hdr->TCP_SegLenInit += data_len_pkt;
      p_buf_hdr->TCP_SegLen += data_len_pkt;
      p_buf_hdr->TCP_SegLenData += data_len_pkt;

      p_buf_head = p_buf;                                       // Set tx Q tail as first seg in tx app data chain.
      p_buf_tail = p_buf;
      tx_q_append = DEF_NO;

      //                                                           Update data ptr & lens.
      p_data_pkt += data_len_pkt;                               // MUST NOT cast ptr operand (see Note #7b).
      data_len_tot += data_len_pkt;
      data_len_rem -= data_len_pkt;

      seq_nbr += data_len_pkt;
      //                                                           Dec TCP conn's tx win size (see Note #8).
      NetTCP_TxConnWinSizeHandlerCfgd(p_conn, data_len_pkt, NET_TCP_CONN_TX_WIN_DEC);
    }
  }

  //                                                               Calc max data size.
  switch (p_net_conn->Family) {
    case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
      proto_type = NET_PROTOCOL_TYPE_TCP_V4;
      break;

    case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
      proto_type = NET_PROTOCOL_TYPE_TCP_V6;
      break;
  }

  data_ix_pkt = 0u;

  NetTCP_GetTxDataIx(if_nbr,
                     proto_type,
                     0u,
                     data_len,
                     p_conn,
                     &data_ix_pkt);

  buf_size_max = NetBuf_GetMaxSize(if_nbr, NET_TRANSACTION_TX, DEF_NULL, data_ix_pkt);
  buf_size_max_data = DEF_MIN(buf_size_max, data_len_mss);

  tx_err = DEF_NO;
  while ((data_len_rem > 0)                                     // Prepare TCP seg(s) for ALL app data ...
         && (p_conn->TxWinSizeCfgdRem > 0)                      // ... as net rsrc(s)/err(s) permit.
         && (tx_err == DEF_NO)) {
    RTOS_ERR local_err;

    RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
    //                                                             Reinit data_ix_pkt.
    data_ix_pkt = 0u;
    NetTCP_GetTxDataIx(if_nbr,
                       proto_type,
                       0u,
                       data_len,
                       p_conn,
                       &data_ix_pkt);

    //                                                             Lim pkt data len to min of max buf data size or ...
    //                                                             ... rem'ing data len or cfg'd tx win size.
    data_len_rem_min = DEF_MIN(buf_size_max_data, data_len_rem);
    data_len_pkt = DEF_MIN(data_len_rem_min, p_conn->TxWinSizeCfgdRem);
    //                                                             Get app data tx buf.
    p_buf = NetBuf_Get(if_nbr,
                       NET_TRANSACTION_TX,
                       data_len_pkt,
                       data_ix_pkt,
                       &data_ix_pkt_offset,
                       NET_BUF_FLAG_NONE,
                       &local_err);
    if (RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE) {
      data_ix_pkt += data_ix_pkt_offset;
    } else {
      tx_err = DEF_YES;
    }

    if (tx_err == DEF_NO) {                                     // Wr app data into TCP tx buf.
      NetBuf_DataWr(p_buf, data_ix_pkt, data_len_pkt, p_data_pkt);
    }

    if (tx_err == DEF_NO) {
      //                                                           Init TCP seg(s) tx buf ctrls.
      p_buf_hdr = &p_buf->Hdr;
      p_buf_hdr->DataIx = data_ix_pkt;
      p_buf_hdr->DataLen = data_len_pkt;
      p_buf_hdr->TotLen = p_buf_hdr->DataLen;
      p_buf_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_APP;

      switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
        case NET_SOCK_FAMILY_IP_V4:
          p_buf_hdr->IP_AddrSrc = src_addrv4;
          p_buf_hdr->IP_AddrDest = dest_addrv4;
          break;
#endif

        case NET_SOCK_FAMILY_IP_V6:
#ifdef  NET_IPv6_MODULE_EN
          p_buf_hdr->IPv6_AddrSrc = src_addrv6;
          p_buf_hdr->IPv6_AddrDest = dest_addrv6;
          break;
#endif

        default:
          break;
      }

      p_buf_hdr->TransportPortSrc = src_port;
      p_buf_hdr->TransportPortDest = dest_port;

      p_buf_hdr->TCP_SegLenInit = data_len_pkt;
      p_buf_hdr->TCP_SegLen = p_buf_hdr->TCP_SegLenInit;
      p_buf_hdr->TCP_SegLenData = p_buf_hdr->TCP_SegLenInit;
      p_buf_hdr->TCP_SegSync = DEF_NO;
      p_buf_hdr->TCP_SegClose = DEF_NO;
      p_buf_hdr->TCP_SegAck = DEF_YES;
      p_buf_hdr->TCP_SegReset = DEF_NO;

      p_buf_hdr->TCP_SeqNbrInit = seq_nbr;
      p_buf_hdr->TCP_SeqNbr = p_buf_hdr->TCP_SeqNbrInit;

      p_buf_hdr->TCP_Flags = flags_tcp;

      if (p_buf_tail != DEF_NULL) {                             // If tx app data chain NOT empty, ...
                                                                // ... append seg(s) @ Q tail (see Note #3b1).
        p_buf_hdr_tail = &p_buf_tail->Hdr;
        p_buf_hdr_tail->NextPrimListPtr = p_buf;
        p_buf_hdr->PrevPrimListPtr = p_buf_tail;
        p_buf_tail = p_buf;
      } else {                                                  // Else add seg as first seg in tx app data chain.
        p_buf_head = p_buf;
        p_buf_tail = p_buf;
      }

      //                                                           Update data ptr & lens.
      p_data_pkt += data_len_pkt;                               // MUST NOT cast ptr operand (see Note #7b).
      data_len_tot += data_len_pkt;
      data_len_rem -= data_len_pkt;

      seq_nbr += data_len_pkt;

      //                                                           Dec TCP conn's tx win size (see Note #8).
      NetTCP_TxConnWinSizeHandlerCfgd(p_conn, data_len_pkt, NET_TCP_CONN_TX_WIN_DEC);
    }
  }

  if (p_buf_head == DEF_NULL) {                                 // If NO data seg'd, rtn no rsrc(s) err ...
    RTOS_ERR_SET(*p_err, RTOS_ERR_POOL_EMPTY);                      // ... (see Notes #2b1F2b, #2c2, & #2d2).
    goto exit;
  }

  DEF_BIT_SET(p_buf_hdr->TCP_Flags, NET_TCP_FLAG_TX_PUSH);      // Set PUSH flag in last q'd tx seg (see Note #6b3B1b).

  //                                                               ----------------- UPDATE TCP CONN ------------------
  if (p_conn->TxQ_Tail != DEF_NULL) {                           // If tx Q NOT empty                            ...
    if (tx_q_append == DEF_YES) {                               // ... & tx app data chain NOT already on tx Q, ...
                                                                // ... append seg(s) @ Q tail (see Note #3b1).
      p_buf_q_tail = p_conn->TxQ_Tail;
      p_buf_hdr_q_tail = &p_buf_q_tail->Hdr;
      p_buf_hdr_q_tail->NextPrimListPtr = p_buf_head;

      p_buf_hdr_head = &p_buf_head->Hdr;
      p_buf_hdr_head->PrevPrimListPtr = p_buf_q_tail;
    }

    p_conn->TxQ_Tail = p_buf_tail;
  } else {                                                      // Else add seg(s) to empty tx Q.
    p_conn->TxQ_Head = p_buf_head;
    p_conn->TxQ_Tail = p_buf_tail;
  }

  //                                                               Update TCP conn tx seq nbr(s).
  p_conn->TxSeqNbrNextQ = seq_nbr;

  //                                                               ---------------- TX TCP DATA SEG(S) ----------------
  //                                                               Conn will be close in NetTCP_TxConnTxQ() in case of
  //                                                               a TX error and buffers will be free.
  if (tx_data == DEF_YES) {
    NetTCP_TxConnTxQ(p_conn,
                     DEF_NULL,
                     NET_TCP_CONN_TX_ACK_NONE,
                     DEF_NO,
                     NET_TCP_CONN_CLOSE_ALL,
                     DEF_YES,
                     p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
  }

exit:
  return (data_len_tot);
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnIsAvailRx()
 *
 * @brief    (1) Check TCP connection for available receive operation(s) :
 *               - (a) Application receive data
 *               - (b) Receive connection closed
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to check for available receive operation(s).
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @return   DEF_YES, if TCP connection has any available receive operation(s).
 *           DEF_NO,  otherwise.
 *
 * @note     (2) RFC #793, Section 3.9 'Event Processing : RECEIVE Call' specifies how to handle receive
 *               data requests from the application layer :
 *               - (a) For the "CLOSED STATE ... return 'error: connection does not exist'".
 *               - (b) (1) For the "LISTEN STATE, SYN-SENT STATE, SYN-RECEIVED STATE ... queue for processing
 *                         after entering ESTABLISHED state".
 *                   - (2) The application layer may request to receive application data before the TCP
 *                         connection enters the connected state.  Such requests will block or return
 *                         no data.
 *               - (c) For the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE" :
 *                   - (1) "If insufficient incoming segments are queued to satisfy the request, queue
 *                          the request."
 *                   - (2) "Reassemble queued incoming segments into receive buffer and return to user."
 *               - (d) For the "CLOSE-WAIT STATE ... since the remote side has already sent FIN, RECEIVEs
 *                     must be satisfied by the text already on hand, but not yet delivered to the user.
 *                     If no text is awaiting delivery, the RECEIVE will get a 'error: connection closing'
 *                     response.  Otherwise, any remaining text can be used to satisfy the RECEIVE".
 *               - (e) (1) For the "CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE ... return 'error:
 *                         connection closing'".
 *                   - (2) Typically, these states will have already received ALL remaining closing
 *                         data from the closing remote host.
 *                       - (A) However, in case all receive data from the remote host has NOT yet been
 *                             received, application layer receives from these states are permitted until
 *                             the TCP connection's sequence receive state is closed & the TCP connection's
 *                             application receive queue is empty.
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnIsAvailRx(NET_TCP_CONN_ID conn_id_tcp,
                                 RTOS_ERR        *p_err)
{
  NET_TCP_CONN *p_conn = DEF_NULL;
  CPU_BOOLEAN  rx_avail = DEF_NO;
  CPU_BOOLEAN  is_used = DEF_NO;

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit;
  }

  //                                                               -------------- CHK TCP CONN RX AVAIL ---------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_FREE:
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
      goto exit;

    case NET_TCP_CONN_STATE_CLOSED:                             // See Note #2a.
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_LISTEN:                             // See Note #2b.
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
      rx_avail = DEF_NO;                                        // See Note #2b2.
      break;

    case NET_TCP_CONN_STATE_CONN:                               // See Note #2c.
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
      //                                                           Chk TCP conn rx data avail (see Note #2c).
      rx_avail = (p_conn->RxQ_App_Head != DEF_NULL) ? DEF_YES : DEF_NO;
      break;

    case NET_TCP_CONN_STATE_CLOSE_WAIT:                         // See Note #2d.
    case NET_TCP_CONN_STATE_CLOSING:                            // See Note #2e.
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      //                                                           Chk TCP conn rx data avail (see Note #2d) OR ...
      rx_avail = ((p_conn->RxQ_App_Head != DEF_NULL)
                  ||                                            // ... TCP conn rx q closed   (see Note #2e2A).
                  ((p_conn->RxQ_App_Head == DEF_NULL)
                   && (p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSED))) ? DEF_YES : DEF_NO;
      break;

    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, DEF_NO);
  }

exit:
  return (rx_avail);
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnIsRdyTx()
 *
 * @brief    Check if TCP connection ready to transmit.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to check if ready to transmit.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @return   DEF_YES, if TCP connection is ready to transmit.
 *           DEF_NO,  otherwise.
 *
 * @note     (1) RFC #793, Section 3.9 'Event Processing : SEND Call' specifies how to handle transmit
 *               data requests from the application layer :
 *               - (a) For the "CLOSED STATE ... return 'error: connection does not exist'".
 *               - (b) For the "LISTEN STATE" :
 *                         (A)TCP Listen state transmit NOT yet implemented. #### NET-815
 *                   - (1) "If the foreign socket is specified, then" :
 *                       - (F) "Data associated with SEND may be" ...
 *                           - (1) "sent with SYN segment"        ...
 *                           - (2) (a) "or queued for transmission after entering ESTABLISHED state."
 *               - (c) For the "SYN-SENT STATE, SYN-RECEIVED STATE" :
 *                   - (1) "Queue the data for transmission after entering ESTABLISHED state."
 *               - (d) For the "ESTABLISHED STATE, CLOSE-WAIT STATE" :
 *                   - (1) (A) "Segmentize the buffer" ...
 *                       - (B) "and send it with a piggybacked acknowledgment."
 *               - (e) For the "FIN-WAIT-1 STATE, FIN-WAIT-2 STATE, CLOSING STATE, LAST-ACK STATE,
 *                     TIME-WAIT STATE" :
 *                   - (1) "Return 'error: connection closing'" ...
 *                   - (2) "and do not service request."
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnIsRdyTx(NET_TCP_CONN_ID conn_id_tcp,
                               RTOS_ERR        *p_err)
{
  NET_TCP_CONN *p_conn = DEF_NULL;
  CPU_BOOLEAN  tx_rdy = DEF_NO;
  CPU_BOOLEAN  is_used = DEF_NO;

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit;
  }

  //                                                               --------------- CHK TCP CONN TX RDY ----------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_FREE:
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
      goto exit;

    case NET_TCP_CONN_STATE_CLOSED:                             // See Note #1a.
    case NET_TCP_CONN_STATE_LISTEN:                             // NOT yet implemented (see Note #1bA).
    case NET_TCP_CONN_STATE_FIN_WAIT_1:                         // See Note #1e.
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_SYNC_RXD:                           // See Note #1c.
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
      tx_rdy = DEF_NO;
      break;

    case NET_TCP_CONN_STATE_CONN:                               // See Note #1d.
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
      //                                                           Chk TCP conn tx data rdy status.
      tx_rdy = (p_conn->TxWinSizeCfgdRem > 0) ? DEF_YES : DEF_NO;
      break;

    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, DEF_NO);
  }

exit:
  return (tx_rdy);
}

/****************************************************************************************************//**
 *                                               NetTCP_ConnGet()
 *
 * @brief    - (1) Allocate & initialize a TCP connection :
 *               - (a) Get      a TCP connection
 *               - (b) Validate   TCP connection
 *               - (c) Initialize TCP connection
 *               - (d) Update     TCP connection pool statistics
 *               - (e) Return TCP connection handle identifier
 *                       OR
 *                       Null identifier & error code, on failure
 *           - (2) The TCP connection pool is implemented as a stack :
 *               - (a) 'NetTCP_ConnPoolPtr' points to the head of the TCP connection pool.
 *               - (b) TCP connections' 'NextPtr's link each TCP connection to form the TCP connection pool stack.
 *               - (c) TCP connections are inserted & removed at the head of        the TCP connection pool stack.
 *                     @verbatim
 *                                   TCP connections are
 *                                   inserted & removed
 *                                       at the head
 *                                       (see Note #2c)
 *
 *                                           |                 NextPtr
 *                                           |             (see Note #2b)
 *                                           v                    |
 *                                                                |
 *                                        -------       -------   v   -------       -------
 *                   TCP Connection  ---->|     |------>|     |------>|     |------>|     |
 *                    Pool Pointer        |     |       |     |       |     |       |     |
 *                                        |     |       |     |       |     |       |     |
 *                   (see Note #2a)       -------       -------       -------       -------
 *
 *                                        |                                               |
 *                                        |<------- Pool of Free TCP Connections -------->|
 *                                        |                (see Note #2)                  |
 *                     @endverbatim
 *
 * @param    fnct_app_post_rx    Hook function to notify upper application of packet rx.
 *
 * @param    fnct_app_post_tx    Hook function to notify upper application of packet tx.
 *
 * @param    p_err               Error pointer.
 *
 * @return   TCP connection handle identifier, if NO error(s).
 *           NET_TCP_CONN_ID_NONE, otherwise.
 *
 * @note     (3) (a) TCP connection pool is accessed by 'NetTCP_ConnPoolPtr' during execution of
 *                 - (1) NetTCP_Init()
 *                 - (2) NetTCP_ConnGet()
 *                 - (3) NetTCP_ConnFree()
 *             - (b) Since the primary tasks of the network protocol suite are prevented from running
 *                   concurrently (see 'net.h  Note #3'), it is NOT necessary to protect the shared
 *                   resources of the connection pool since no asynchronous access from other network
 *                   tasks is possible.
 *******************************************************************************************************/
NET_TCP_CONN_ID NetTCP_ConnGet(NET_TCP_APP_POST_FNCT fnct_app_post_rx,
                               NET_TCP_APP_POST_FNCT fnct_app_post_tx,
                               RTOS_ERR              *p_err)
{
  NET_TCP_CONN    *p_conn;
  NET_TCP_CONN_ID conn_id_tcp;
  RTOS_ERR        local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  //                                                               ------------------- GET TCP CONN -------------------
  if (NetTCP_ConnPoolPtr != DEF_NULL) {                         // If TCP conn pool NOT empty, get TCP conn from pool.
    p_conn = NetTCP_ConnPoolPtr;
    NetTCP_ConnPoolPtr = p_conn->NextPtr;
  } else {                                                      // If none avail, rtn err.
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NoneAvailCtr);
    conn_id_tcp = NET_TCP_CONN_ID_NONE;
    RTOS_ERR_SET(*p_err, RTOS_ERR_POOL_EMPTY);
    goto exit;
  }

  //                                                               ------------------ INIT TCP CONN -------------------
  NetTCP_ConnClr(p_conn);
  DEF_BIT_SET(p_conn->Flags, NET_TCP_FLAG_USED);                // Set TCP conn as used.
  p_conn->ConnState = NET_TCP_CONN_STATE_CLOSED;

  p_conn->FnctAppPostRx = fnct_app_post_rx;
  p_conn->FnctAppPostTx = fnct_app_post_tx;

#if (NET_STAT_POOL_TCP_CONN_EN == DEF_ENABLED)
  //                                                               ------------ UPDATE TCP CONN POOL STATS ------------
  NetStat_PoolEntryUsedInc(&NetTCP_ConnPoolStat, &local_err);
#endif

  PP_UNUSED_PARAM(local_err);

  //                                                               ----------------- RTN TCP CONN ID ------------------
  conn_id_tcp = p_conn->ID;

exit:
  return (conn_id_tcp);
}

/****************************************************************************************************//**
 *                                               NetTCP_ConnFree()
 *
 * @brief    Free a TCP connection.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to free.
 *
 * @note     (1) #### To prevent freeing a TCP connection already freed via previous TCP connection
 *                    free, NetTCP_ConnFree() checks if the TCP connection is used BEFORE freeing the
 *                    TCP connection.
 *
 *                    This prevention is only best-effort since any invalid duplicate TCP connection frees
 *                    MAY be asynchronous to potentially valid TCP connection gets.  Thus the invalid TCP
 *                    connection free(s) MAY corrupt the TCP connection's valid operation(s).
 *
 *                    However, since the primary tasks of the network protocol suite are prevented from
 *                    running concurrently (see 'net.h  Note #3'), it is NOT necessary to protect TCP
 *                    connection resources from possible corruption since no asynchronous access from
 *                    other network tasks is possible.
 *******************************************************************************************************/
void NetTCP_ConnFree(NET_TCP_CONN_ID conn_id_tcp)
{
  NET_TCP_CONN *p_conn;
  CPU_BOOLEAN  is_used;

  //                                                               ---------------- VALIDATE TCP CONN -----------------
  if (conn_id_tcp == NET_TCP_CONN_ID_NONE) {
    goto exit;
  }

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {                                     // If TCP conn NOT used, ...
    goto exit;                                                  // ... rtn but do NOT free (see Note #1).
  }

  //                                                               ------------------ FREE TCP CONN -------------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  NetTCP_ConnFreeHandler(p_conn, NET_TCP_CONN_FREE_ALL);

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCloseFromConn()
 *
 * @brief    Close a TCP connection via a network connection.
 *            - (1) When a network connection closes a TCP connection, the TCP connection :
 *                - (a) (1) Closes NO other network connection(s),
 *                    - (2) MUST NOT recursively re-close other network connection(s);
 *
 *                - (b) SHOULD clear network connection(s)' handle identifiers.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to close.
 *
 * @note     (2) #### To prevent closing a TCP connection already closed via previous TCP connection
 *                    close, NetTCP_ConnCloseFromConn() checks if the TCP connection is used BEFORE closing
 *                    the TCP connection.
 *
 *                    This prevention is only best-effort since any invalid duplicate TCP connection closes
 *                    MAY be asynchronous to potentially valid TCP connection gets.  Thus the invalid TCP
 *                    connection closes(s) MAY corrupt the TCP connection's valid operation(s).
 *
 *                    However, since the primary tasks of the network protocol suite are prevented from
 *                    running concurrently (see 'net.h  Note #3'), it is NOT necessary to protect TCP
 *                    connection resources from possible corruption since no asynchronous access from
 *                    other network tasks is possible.
 *******************************************************************************************************/
void NetTCP_ConnCloseFromConn(NET_TCP_CONN_ID conn_id_tcp)
{
  NET_TCP_CONN *p_conn;
  CPU_BOOLEAN  is_used;

  //                                                               ---------------- VALIDATE TCP CONN -----------------
  if (conn_id_tcp == NET_TCP_CONN_ID_NONE) {
    goto exit;
  }

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {                                     // If TCP conn NOT used, ...
    goto exit;                                                  // ... rtn but do NOT close (see Note #2).
  }

  //                                                               ------------------ CLOSE TCP CONN ------------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  NetTCP_ConnClose(p_conn, DEF_NULL, DEF_NO, NET_TCP_CONN_CLOSE_ALL);   // See Note #1.

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnSetID_Conn()
 *
 * @brief    Set a TCP connection's network connection handle identifier.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to set.
 *
 * @param    conn_id         _tcp     Handle identifier of TCP connection to set.
 *******************************************************************************************************/
void NetTCP_ConnSetID_Conn(NET_TCP_CONN_ID conn_id_tcp,
                           NET_CONN_ID     conn_id)
{
  NET_TCP_CONN *p_conn;

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  p_conn->ID_Conn = conn_id;                                    // Set TCP conn's conn id.
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnSetStateListen()
 *
 * @brief    Set TCP connection to LISTEN state.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to set LISTEN state.
 *
 * @param    p_err           Error pointer.
 *******************************************************************************************************/
void NetTCP_ConnSetStateListen(NET_TCP_CONN_ID                    conn_id_tcp,
                               NET_TCP_APP_LISTEN_Q_IS_AVAIL_FNCT tcp_app_listen_is_avail_fnct,
                               RTOS_ERR                           *p_err)
{
  NET_TCP_CONN *p_conn;
  CPU_BOOLEAN  is_used;

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit;
  }

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_FREE:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
      goto exit;

    case NET_TCP_CONN_STATE_CLOSED:
      p_conn->FnctAppListenQ_IsAvail = tcp_app_listen_is_avail_fnct;
      p_conn->ConnState = NET_TCP_CONN_STATE_LISTEN;
      break;

    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnAppAcceptRdySignal()
 *
 * @brief    Signal the TCP connection that the connection has been accepted by the application layer.
 *           The Receive window can be configured to let the remote host send data on this connection.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *******************************************************************************************************/
#ifndef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
void NetTCP_ConnAppAcceptRdySignal(NET_CONN_ID     conn_id_parent,
                                   NET_TCP_CONN_ID conn_id_tcp,
                                   RTOS_ERR        *p_err)
{
  NET_CONN     *p_conn_parent;
  NET_TCP_CONN *p_conn_tcp_parent;
  NET_TCP_CONN *p_conn_tcp;
  CPU_BOOLEAN  is_used;

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    return;
  }

  p_conn_tcp = &NetTCP_ConnTbl[conn_id_tcp];

  p_conn_parent = &NetConn_Tbl[conn_id_parent];

  if (p_conn_parent->ID_Transport == NET_TCP_CONN_ID_NONE) {
    NetTCP_RxConnWinSizeHandler(p_conn_tcp, DEF_NULL, NET_TCP_DFLT_RX_WIN_SIZE_OCTET, NET_TCP_CONN_RX_WIN_INIT);
  } else {
    p_conn_tcp_parent = &NetTCP_ConnTbl[p_conn_parent->ID_Transport];

    if (p_conn_tcp_parent->RxWinSizeCfgd != 0) {
      NetTCP_RxConnWinSizeHandler(p_conn_tcp, DEF_NULL, p_conn_tcp_parent->RxWinSizeCfgd, NET_TCP_CONN_RX_WIN_INIT);
    } else {
      NetTCP_RxConnWinSizeHandler(p_conn_tcp, DEF_NULL, NET_TCP_DFLT_RX_WIN_SIZE_OCTET, NET_TCP_CONN_RX_WIN_INIT);
    }
  }
}
#endif

/****************************************************************************************************//**
 *                                   NetTCP_ConnCfgIdleTimeoutHandler()
 *
 * @brief    (1) Configure TCP connection's   idle timeout :
 *               - (a) Validate  TCP connection idle timeout configuration
 *               - (b) Configure TCP connection idle timeout
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure connection idle timeout.
 *
 * @param    timeout_sec     Desired value for TCP connection idle timeout (in seconds).
 *
 * @return   DEF_OK,   TCP connection idle timeout successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgIdleTimeoutHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *
 * @note     (3) Configured timeout does NOT reschedule any current idle timeout in progress but
 *               becomes effective the next time a TCP connection sets its idle timeout.
 *
 * @note     (4) TCP connections' 'TimeoutConn' variables MUST ALWAYS be accessed with the global
 *               network lock already acquired (see Note #2).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgIdleTimeoutHandler(NET_TCP_CONN_ID     conn_id_tcp,
                                             NET_TCP_TIMEOUT_SEC timeout_sec)
{
  NET_TCP_CONN *p_conn;

  //                                                               ---------- VALIDATE TCP CONN IDLE TIMEOUT ----------
#if (NET_TCP_CONN_TIMEOUT_IDLE_MIN_SEC > 0)
  RTOS_ASSERT_DBG((timeout_sec >= NET_TCP_CONN_TIMEOUT_IDLE_MIN_SEC), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

#if ((NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC < DEF_INT_08U_MAX_VAL)                                                                \
  || ((NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC < DEF_INT_16U_MAX_VAL) && (NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC > DEF_INT_08U_MAX_VAL)) \
  || ((NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC < DEF_INT_32U_MAX_VAL) && (NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC > DEF_INT_16U_MAX_VAL)))
  RTOS_ASSERT_DBG((timeout_sec <= NET_TCP_CONN_TIMEOUT_IDLE_MAX_SEC), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

  //                                                               ----------- CFG TCP CONN TX IDLE TIMEOUT -----------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  p_conn->TimeoutConn_sec = timeout_sec;

  return (DEF_OK);
}

/****************************************************************************************************//**
 *                                   NetTCP_ConnCfgMaxSegSizeLocalHandler()
 *
 * @brief    (1) Configure TCP connection's   local maximum segment size :
 *               - (a) Validate  TCP connection local maximum segment size configuration
 *               - (b) Configure TCP connection local maximum segment size                 See Note #3
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure local maximum segment size.
 *
 * @param    max_seg_size    Desired maximum segment size.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @return   DEF_OK,   TCP connection local maximum segment size successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgMaxSegSizeLocalHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *
 * @note     (3) RFC #793, Section 3.1 'Header Format : Options : Maximum Segment Size' states that
 *               a TCP connection advertises its "maximum receive segment size ... only ... in the
 *               initial connection request (i.e., in segments with the SYN control bit set)".
 *
 *               Thus any configuration of the local receive maximum segment size MUST be performed
 *               by the application layer PRIOR to any TCP connection request/synchronization either
 *               from a :
 *               - (a) Actively- connected TCP connection
 *               - (b) Passively-connected TCP connection, which is cloned from its previously-
 *                     configured LISTEN-state TCP connection
 *
 * @note     (4) TCP connections' 'MaxSegSizeLocal' variables MUST ALWAYS be accessed with the global
 *               network lock already acquired (see Note #2).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgMaxSegSizeLocalHandler(NET_TCP_CONN_ID  conn_id_tcp,
                                                 NET_TCP_SEG_SIZE max_seg_size,
                                                 RTOS_ERR         *p_err)
{
  NET_TCP_CONN *p_conn;
  CPU_BOOLEAN  cfg_valid = DEF_FAIL;

  //                                                               -------------- VALIDATE MAX SEG SIZE ---------------
#if ((NET_TCP_MAX_SEG_SIZE_MAX < DEF_INT_08U_MAX_VAL)                                                       \
  || ((NET_TCP_MAX_SEG_SIZE_MAX < DEF_INT_16U_MAX_VAL) && (NET_TCP_MAX_SEG_SIZE_MAX > DEF_INT_08U_MAX_VAL)) \
  || ((NET_TCP_MAX_SEG_SIZE_MAX < DEF_INT_32U_MAX_VAL) && (NET_TCP_MAX_SEG_SIZE_MAX > DEF_INT_16U_MAX_VAL)))
  RTOS_ASSERT_DBG_ERR_SET((max_seg_size <= NET_TCP_MAX_SEG_SIZE_MAX), *p_err, RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  if (RTOS_ARG_CHK_EXT_EN) {
    NET_CONN_ID conn_id;
    NET_CONN    *p_net_conn;

    conn_id = p_conn->ID_Conn;
    p_net_conn = (NET_CONN *)&NetConn_Tbl[conn_id];

    switch (p_net_conn->Family) {
#ifdef   NET_IPv4_MODULE_EN
      case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
        RTOS_ASSERT_DBG_ERR_SET((max_seg_size >= NET_TCP_MAX_SEG_SIZE_DFLT_V4), *p_err, RTOS_ERR_INVALID_ARG, DEF_FAIL);
        break;
#endif

#ifdef   NET_IPv6_MODULE_EN
      case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
        RTOS_ASSERT_DBG_ERR_SET((max_seg_size >= NET_TCP_MAX_SEG_SIZE_DFLT_V6), *p_err, RTOS_ERR_INVALID_ARG, DEF_FAIL);
        break;
#endif

      default:
        RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_ASSERT_CRITICAL_FAIL, DEF_FAIL);
    }
  }

  //                                                               ------------- VALIDATE TCP CONN STATE --------------

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_FREE:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
      goto exit;

    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
      break;

    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, DEF_FAIL);
  }

  //                                                               --------- CFG TCP CONN LOCAL MAX SEG SIZE ----------
  p_conn->MaxSegSizeLocalCfgd = max_seg_size;

  cfg_valid = DEF_OK;

exit:
  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgRxWinSizeHandler()
 *
 * @brief    (1) Configure TCP connection's   receive window size :
 *               - (a) Validate  TCP connection receive window size configuration
 *               - (b) Configure TCP connection receive window size                        See Note #3
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure receive window size.
 *
 * @param    win_size        Desired receive window size.
 *
 * @param    p_err           Error pointer.
 *
 * @return   DEF_OK,   TCP connection receive window size successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgRxWinSizeHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *               See also 'NetTCP_ConnCfgRxWinSize()  Note #2'.
 *
 * @note     (3) A TCP connection's receive window size SHOULD NOT be updated after the TCP
 *               connection is connected (see 'NetTCP_RxConnWinSizeHandler()  Notes #2b & #5').
 *               Thus any configuration of the local receive window size MUST be performed
 *               by the application layer PRIOR to any TCP connection request/synchronization
 *               either from a :
 *               - (a) Actively- connected TCP connection
 *               - (b) Passively-connected TCP connection, which is cloned from its previously-
 *                     configured LISTEN-state TCP connection
 *
 * @note     (4) TCP connections' 'RxWinSizeCfgd' variables MUST ALWAYS be accessed with the global
 *               network lock already acquired (see Note #2).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgRxWinSizeHandler(NET_TCP_CONN_ID  conn_id_tcp,
                                           NET_TCP_WIN_SIZE win_size,
                                           RTOS_ERR         *p_err)
{
  NET_TCP_CONN *p_conn = DEF_NULL;
  CPU_BOOLEAN  cfg_valid = DEF_FAIL;

  //                                                               --------------- VALIDATE RX WIN SIZE ---------------
#if ((NET_TCP_WIN_SIZE_MAX < DEF_INT_08U_MAX_VAL)                                                   \
  || ((NET_TCP_WIN_SIZE_MAX < DEF_INT_16U_MAX_VAL) && (NET_TCP_WIN_SIZE_MAX > DEF_INT_08U_MAX_VAL)) \
  || ((NET_TCP_WIN_SIZE_MAX < DEF_INT_32U_MAX_VAL) && (NET_TCP_WIN_SIZE_MAX > DEF_INT_16U_MAX_VAL)))
  RTOS_ASSERT_DBG_ERR_SET((win_size <= NET_TCP_WIN_SIZE_MAX), *p_err, RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  if (RTOS_ARG_CHK_EXT_EN) {
    NET_CONN_ID conn_id;
    NET_CONN    *p_net_conn;

    conn_id = p_conn->ID_Conn;
    p_net_conn = (NET_CONN *)&NetConn_Tbl[conn_id];

    switch (p_net_conn->Family) {
#ifdef   NET_IPv4_MODULE_EN
      case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
        RTOS_ASSERT_DBG_ERR_SET((win_size >= NET_TCP_MAX_SEG_SIZE_DFLT_V4), *p_err, RTOS_ERR_INVALID_ARG, DEF_FAIL);
        break;
#endif

#ifdef   NET_IPv6_MODULE_EN
      case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
        RTOS_ASSERT_DBG_ERR_SET((win_size >= NET_TCP_MAX_SEG_SIZE_DFLT_V6), *p_err, RTOS_ERR_INVALID_ARG, DEF_FAIL);
        break;
#endif

      default:
        RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_ASSERT_CRITICAL_FAIL, DEF_FAIL);
    }
  }

  //                                                               ------------- VALIDATE TCP CONN STATE --------------
  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_FREE:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
      goto exit;

    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
      break;

    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, DEF_FAIL);
  }

  //                                                               ------------- CFG TCP CONN RX WIN SIZE -------------
  p_conn->RxWinSizeCfgd = win_size;                             // Cfg rx win size.
  NetTCP_RxConnWinSizeCfg(p_conn);                              // Cfg rx win ctrls.

  cfg_valid = DEF_OK;

exit:
  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgTxWinSizeHandler()
 *
 * @brief    (1) Configure TCP connection's   transmit window size :
 *               - (a) Validate  TCP connection transmit window size configuration
 *               - (b) Configure TCP connection transmit window size                       See Note #3
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure transmit window size.
 *
 * @param    win_size        Desired transmit window size.
 *
 * @param    p_err           Error pointer.
 *
 * @return   DEF_OK,   TCP connection transmit window size successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgTxWinSizeHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *               See also 'NetTCP_ConnCfgTxWinSize()  Note #2'.
 *
 * @note     (3) A TCP connection's transmit window size SHOULD NOT be updated after the TCP connection is
 *               connected.  Thus any configuration of the local transmit window size MUST be performed by
 *               the application layer PRIOR to any TCP connection request/synchronization either from a :
 *               - (a) Actively- connected TCP connection
 *               - (b) Passively-connected TCP connection, which is cloned from its previously-
 *                     configured LISTEN-state TCP connection
 *               See also 'NetTCP_TxConnWinSizeHandlerCfgd()  Note #3'.
 *
 * @note     (4) TCP connections' 'TxWinSizeCfgd' variables MUST ALWAYS be accessed with the global
 *               network lock already acquired (see Note #2).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxWinSizeHandler(NET_TCP_CONN_ID  conn_id_tcp,
                                           NET_TCP_WIN_SIZE win_size,
                                           RTOS_ERR         *p_err)
{
  NET_TCP_CONN *p_conn = DEF_NULL;
  CPU_BOOLEAN  cfg_valid = DEF_FAIL;

  //                                                               --------------- VALIDATE TX WIN SIZE ---------------
#if (NET_TCP_WIN_SIZE_MIN > 0)
  RTOS_ASSERT_DBG_ERR_SET((win_size >= NET_TCP_WIN_SIZE_MIN), *p_err, RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

#if ((NET_TCP_WIN_SIZE_MAX < DEF_INT_08U_MAX_VAL)                                                   \
  || ((NET_TCP_WIN_SIZE_MAX < DEF_INT_16U_MAX_VAL) && (NET_TCP_WIN_SIZE_MAX > DEF_INT_08U_MAX_VAL)) \
  || ((NET_TCP_WIN_SIZE_MAX < DEF_INT_32U_MAX_VAL) && (NET_TCP_WIN_SIZE_MAX > DEF_INT_16U_MAX_VAL)))
  RTOS_ASSERT_DBG_ERR_SET((win_size <= NET_TCP_WIN_SIZE_MAX), *p_err, RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

  //                                                               ------------- VALIDATE TCP CONN STATE --------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_FREE:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
      goto exit;

    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
      break;

    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, DEF_FAIL);
  }

  //                                                               ------------- CFG TCP CONN TX WIN SIZE -------------
  p_conn->TxWinSizeCfgd = win_size;                             // Cfg tx win size.
  NetTCP_TxConnWinSizeCfg(p_conn);                              // Cfg tx win ctrls.

  cfg_valid = DEF_OK;

exit:
  return (cfg_valid);
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgTxNagleEnHandler()
 *
 * @brief    (1) Configure TCP connection's   transmit Nagle algorithm enable :
 *               - (a) Validate  TCP connection transmit Nagle algorithm enable configuration
 *               - (b) Configure TCP connection transmit Nagle algorithm enable                See Note #3
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure transmit Nagle enable.
 *
 * @param    nagle_en        Desired value for TCP connection transmit Nagle enable :
 *                           DEF_ENABLED             TCP connections delay transmitting next data
 *                           segment(s) until all unacknowledged data
 *                           is acknowledged OR an MSS-sized segment
 *                           can be transmitted.
 *                           DEF_DISABLED            TCP connections transmit all data segment(s)
 *                           when permitted by local & remote hosts'
 *                           congestion controls.
 *
 * @return   DEF_OK,   TCP connection transmit Nagle enable successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgTxNagleEnHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *
 * @note     (3) RFC #1122, Section 4.2.3.4 also states that "a TCP SHOULD implement the Nagle
 *               Algorithm ... However, there MUST be a way for an application to disable the
 *               Nagle algorithm on an individual connection".
 *
 * @note     (4) TCP connections' 'TxWinSizeNagleEn' variables MUST ALWAYS be accessed with the
 *               global network lock already acquired (see Note #2).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxNagleEnHandler(NET_TCP_CONN_ID conn_id_tcp,
                                           CPU_BOOLEAN     nagle_en)
{
  NET_TCP_CONN *p_conn;

#if (RTOS_ARG_CHK_EXT_EN == DEF_ENABLED)
  //                                                               ---------------- VALIDATE NAGLE EN -----------------
  switch (nagle_en) {
    case DEF_ENABLED:
    case DEF_DISABLED:
      break;

    default:
      RTOS_DBG_FAIL_EXEC(RTOS_ERR_INVALID_ARG, DEF_FAIL);
  }
#endif

  //                                                               ------------- CFG TCP CONN TX NAGLE EN -------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  p_conn->TxWinSizeNagleEn = nagle_en;

  return (DEF_OK);
}

/****************************************************************************************************//**
 *                                   NetTCP_ConnCfgTxAckDlyTimeoutHandler()
 *
 * @brief    (1) Configure TCP connection's   transmit acknowledgement delay timeout :
 *               - (a) Validate  TCP connection transmit acknowledgement delay timeout configuration
 *               - (b) Configure TCP connection transmit acknowledgement delay timeout         See Note #3
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure transmit acknowledgement
 *
 * @param    -----------  delay timeout.
 *
 * @param    timeout_ms      Desired value for TCP connection transmit acknowledgement delay timeout
 *                           (in milliseconds).
 *
 * @return   DEF_OK,   TCP connection transmit acknowledgement delay timeout successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgTxAckDlyTimeoutHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *
 * @note     (3) (a) (1) RFC #1122, Section 4.2.3.2 states that "an ACK should not be excessively
 *                       delayed; in particular, the delay MUST be less than 0.5 seconds".
 *                 - (2) RFC #2581, Section 4.2 reiterates that "an ACK ... MUST be generated
 *                       within 500 ms of the arrival of the first unacknowledged packet".
 *             - (b) If the acknowledgement delay timeout is configured with a non-zero value,
 *                   at least one timer tick MUST be set to ensure that the non-zero timeout
 *                   is implemented.
 *
 * @note     (4) Configured timeout does NOT reschedule any current acknowledgement delay timeout in
 *               progress but becomes effective the next time a TCP connection sets an acknowledgement
 *               delay timeout.
 *
 * @note     (5) TCP connections' 'TxAckDlyTimeout_ms' variables MUST ALWAYS be accessed with the global
 *               network lock already acquired (see Note #2).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxAckDlyTimeoutHandler(NET_TCP_CONN_ID    conn_id_tcp,
                                                 NET_TCP_TIMEOUT_MS timeout_ms)
{
  NET_TCP_CONN *p_conn;

  //                                                               ----------- VALIDATE TX ACK DLY TIMEOUT ------------
#if (NET_TCP_ACK_DLY_TIME_MIN_MS > 0)
  RTOS_ASSERT_DBG((timeout_ms >= NET_TCP_ACK_DLY_TIME_MIN_MS), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

#if ((NET_TCP_ACK_DLY_TIME_MAX_MS < DEF_INT_08U_MAX_VAL)                                                          \
  || ((NET_TCP_ACK_DLY_TIME_MAX_MS < DEF_INT_16U_MAX_VAL) && (NET_TCP_ACK_DLY_TIME_MAX_MS > DEF_INT_08U_MAX_VAL)) \
  || ((NET_TCP_ACK_DLY_TIME_MAX_MS < DEF_INT_32U_MAX_VAL) && (NET_TCP_ACK_DLY_TIME_MAX_MS > DEF_INT_16U_MAX_VAL)))
  RTOS_ASSERT_DBG((timeout_ms <= NET_TCP_ACK_DLY_TIME_MAX_MS), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

  //                                                               --------- CFG TCP CONN TX ACK DLY TIMEOUT ----------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  p_conn->TxAckDlyTimeout_ms = timeout_ms;

  return (DEF_OK);
}

/****************************************************************************************************//**
 *                                   NetTCP_ConnCfgTxKeepAliveEnHandler()
 *
 * @brief    (1) Configure TCP connection's   transmit keep-alive algorithm enable :
 *               - (a) Validate  TCP connection transmit keep-alive algorithm enable configuration
 *               - (b) Configure TCP connection transmit keep-alive algorithm enable           See Note #3
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure transmit keep-alive enable.
 *
 * @param    keep_alive_en   Desired value for TCP connection transmit keep-alive enable :
 *                           DEF_ENABLED             TCP connections transmit periodic keep-alive
 *                                                   segments if NO data segments have been
 *                                                   received within the keep-alive timeout.
 *                           DEF_DISABLED            TCP connections transmit a reset segment &
 *                                                   close    if NO data segments have been
 *                                                   received within the keep-alive timeout.
 *
 * @return   DEF_OK,   TCP connection transmit keep-alive enable successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgTxKeepAliveEnHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *
 * @note     (3) RFC #1122, Section 4.2.3.6 states that "if keep-alives are included, the application
 *               MUST be able to turn them on or off for each TCP connection".
 *
 * @note     (4) TCP connections' 'TxKeepAliveEn' variables MUST ALWAYS be accessed with the global
 *               network lock already acquired (see Note #2).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxKeepAliveEnHandler(NET_TCP_CONN_ID conn_id_tcp,
                                               CPU_BOOLEAN     keep_alive_en)
{
  NET_TCP_CONN *p_conn;

#if (RTOS_ARG_CHK_EXT_EN == DEF_ENABLED)
  //                                                               ------------ VALIDATE TX KEEP-ALIVE EN -------------
  switch (keep_alive_en) {
    case DEF_ENABLED:
    case DEF_DISABLED:
      break;

    default:
      RTOS_DBG_FAIL_EXEC(RTOS_ERR_INVALID_ARG, DEF_FAIL);
  }
#endif

  //                                                               ---------- CFG TCP CONN TX KEEP-ALIVE EN -----------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  p_conn->TxKeepAliveEn = keep_alive_en;

  return (DEF_OK);
}

/****************************************************************************************************//**
 *                                   NetTCP_ConnCfgTxKeepAliveThHandler()
 *
 * @brief    (1) Configure TCP connection's maximum number of consecutive keep-alives to transmit :
 *               - (a) Validate  TCP connection transmit keep-alive threshold configuration
 *               - (b) Configure TCP connection transmit keep-alive threshold                  See Note #3
 *
 * @param    conn_id_tcp         Handle identifier of TCP connection to configure transmit
 *
 * @param    -----------         keep-alive threshold.
 *
 * @param    nbr_max_keep_alive  Desired maximum number of consecutive keep-alives to transmit.
 *
 * @return   DEF_OK,   TCP connection transmit keep-alive threshold successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgTxKeepAliveThHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *
 * @note     (3) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.3 'Other End Crashes',
 *               Pages 334-335 states "that the [remote host] ... send[s] ... [N] keepalive probes ...
 *               before declaring the connection dead".
 *
 * @note     (4) TCP connections' 'TxKeepAliveTh' variables MUST ALWAYS be accessed with the global
 *               network lock already acquired (see Note #2).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxKeepAliveThHandler(NET_TCP_CONN_ID conn_id_tcp,
                                               NET_PKT_CTR     nbr_max_keep_alive)
{
  NET_TCP_CONN *p_conn;

  //                                                               ------------ VALIDATE TX KEEP-ALIVE TH -------------
#if (NET_TCP_TX_KA_TH_MIN > NET_PKT_CTR_MIN)
  RTOS_ASSERT_DBG((nbr_max_keep_alive >= NET_TCP_TX_KA_TH_MIN), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

#if (NET_TCP_TX_KA_TH_MAX < NET_PKT_CTR_MAX)
  RTOS_ASSERT_DBG((nbr_max_keep_alive <= NET_TCP_TX_KA_TH_MAX), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

  //                                                               ---------- CFG TCP CONN TX KEEP-ALIVE TH -----------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  p_conn->TxKeepAliveTh = nbr_max_keep_alive;

  return (DEF_OK);
}

/****************************************************************************************************//**
 *                                   NetTCP_ConnCfgTxKeepAliveRetryHandler()
 *
 * @brief    (1) Configure TCP connection's   transmit keep-alive retry timeout :
 *               - (a) Validate  TCP connection transmit keep-alive retry timeout configuration
 *               - (b) Configure TCP connection transmit keep-alive retry timeout
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure transmit keep-alive retry
 *
 * @param    -----------  timeout.
 *
 * @param    timeout_sec     Desired value for TCP connection transmit keep-alive retry timeout (in seconds).
 *
 * @return   DEF_OK,   TCP connection transmit keep-alive retry timeout successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgTxKeepAliveRetryHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *
 * @note     (3) NetTCP_ConnCfgTxKeepAliveRetryTimeoutHandler() abbreviated to
 *               NetTCP_ConnCfgTxKeepAliveRetryHandler() to enforce ANSI-compliance of 31-character
 *               symbol length uniqueness.
 *
 * @note     (4) Configured timeout does NOT reschedule any current keep-alive retry timeout in progress
 *               but becomes effective the next time a TCP connection sets its keep-alive retry timeout.
 *
 * @note     (5) TCP connections' 'TxKeepAliveRetryTimeout_sec' variables MUST ALWAYS be accessed with
 *               the global network lock already acquired (see Note #2).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgTxKeepAliveRetryHandler(NET_TCP_CONN_ID     conn_id_tcp,
                                                  NET_TCP_TIMEOUT_SEC timeout_sec)
{
  NET_TCP_CONN *p_conn;

  //                                                               ------- VALIDATE TX KEEP-ALIVE RETRY TIMEOUT -------
#if (NET_TCP_TX_KA_RETRY_TIMEOUT_MIN_SEC > 0)
  RTOS_ASSERT_DBG((timeout_sec >= NET_TCP_TX_KA_RETRY_TIMEOUT_MIN_SEC), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

#if ((NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC < DEF_INT_08U_MAX_VAL)                                                                  \
  || ((NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC < DEF_INT_16U_MAX_VAL) && (NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC > DEF_INT_08U_MAX_VAL)) \
  || ((NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC < DEF_INT_32U_MAX_VAL) && (NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC > DEF_INT_16U_MAX_VAL)))
  RTOS_ASSERT_DBG((timeout_sec <= NET_TCP_TX_KA_RETRY_TIMEOUT_MAX_SEC), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

  //                                                               ----- CFG TCP CONN TX KEEP-ALIVE RETRY TIMEOUT -----
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  p_conn->TxKeepAliveRetryTimeout_sec = timeout_sec;

  return (DEF_OK);
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgReTxMaxThHandler()
 *
 * @brief    (1) Configure TCP connection's   maximum number of same segment retransmissions :
 *               - (a) Validate  TCP connection maximum number retransmissions configuration
 *               - (b) Configure TCP connection maximum number retransmissions                 See Note #3
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure maximum number of
 *
 * @param    -----------    same segment retransmissions.
 *
 * @param    nbr_max_re_tx   Desired maximum number of same segment retransmissions.
 *
 * @return   DEF_OK,   TCP connection maximum number of same segment retransmissions successfully
 *                           configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgReTxMaxThHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *
 * @note     (3) RFC #1122, Section 4.2.3.5 states that "when the number of transmissions of the
 *               same segment reaches a threshold ... close the connection".
 *
 * @note     (4) TCP connections' 'TxSegReTxTh' variables MUST ALWAYS be accessed with the global
 *               network lock already acquired (see Note #2).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgReTxMaxThHandler(NET_TCP_CONN_ID conn_id_tcp,
                                           NET_PKT_CTR     nbr_max_re_tx)
{
  NET_TCP_CONN *p_conn;

  //                                                               ---------------- VALIDATE RE-TX TH -----------------
#if (NET_TCP_RE_TX_TH_MIN > NET_PKT_CTR_MIN)
  RTOS_ASSERT_DBG((nbr_max_re_tx >= NET_TCP_RE_TX_TH_MIN), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

#if (NET_TCP_RE_TX_TH_MAX < NET_PKT_CTR_MAX)
  RTOS_ASSERT_DBG((nbr_max_re_tx <= NET_TCP_RE_TX_TH_MAX), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

  //                                                               -------------- CFG TCP CONN RE-TX TH ---------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  p_conn->TxSegReTxTh = nbr_max_re_tx;

  return (DEF_OK);
}

/****************************************************************************************************//**
 *                                   NetTCP_ConnCfgReTxMaxTimeoutHandler()
 *
 * @brief    (1) Configure TCP connection's   maximum retransmission timeout :
 *               - (a) Validate  TCP connection maximum retransmission timeout configuration
 *               - (b) Configure TCP connection maximum retransmission timeout                 See Note #3
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to configure maximum retransmission
 *
 * @param    -----------  timeout value.
 *
 * @param    timeout_sec     Desired value for TCP connection maximum retransmission timeout (in seconds).
 *
 * @return   DEF_OK,   TCP connection maximum retransmission timeout successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgReTxMaxTimeoutHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *
 * @note     (3) (a) RFC #2988, Section 2.4 states that "a maximum value MAY be placed on RTO provided
 *                   it is at least 60 seconds".
 *             - (b) RFC #1122, Section 4.2.3.1 states that "the recommended ... RTO ... upper bound
 *                   should be 2*MSL".
 *             - (c) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2, Page 299 states
 *                   that "the timeout value ... [has] an upper limit of 64 seconds".
 *
 * @note     (4) Configured timeout does NOT reschedule any current retransmission timeout in progress
 *               but becomes effective the next time a TCP connection sets its retransmission timeout.
 *
 * @note     (5) TCP connections' 'TxRTT_RTO_Max_sec' variables MUST ALWAYS be accessed with the global
 *               network lock already acquired (see Note #2).
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgReTxMaxTimeoutHandler(NET_TCP_CONN_ID     conn_id_tcp,
                                                NET_TCP_TIMEOUT_SEC timeout_sec)
{
  NET_TCP_CONN *p_conn;

  //                                                               ----------------- VALIDATE RTO MAX -----------------
  //                                                               See Note #3.
#if (NET_TCP_TX_RTO_MAX_TIMEOUT_MIN_SEC > 0)
  RTOS_ASSERT_DBG((timeout_sec >= NET_TCP_TX_RTO_MAX_TIMEOUT_MIN_SEC), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

#if ((NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC < DEF_INT_08U_MAX_VAL)                                                                 \
  || ((NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC < DEF_INT_16U_MAX_VAL) && (NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC > DEF_INT_08U_MAX_VAL)) \
  || ((NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC < DEF_INT_32U_MAX_VAL) && (NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC > DEF_INT_16U_MAX_VAL)))
  RTOS_ASSERT_DBG((timeout_sec <= NET_TCP_TX_RTO_MAX_TIMEOUT_MAX_SEC), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

  //                                                               --------------- CFG TCP CONN RTO MAX ---------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  p_conn->TxRTT_RTO_Max_sec = timeout_sec;

  NetTCP_TxConnRTO_CfgMaxTimeout(p_conn);                       // Cfg RTO ctrls.

  return (DEF_OK);
}

/****************************************************************************************************//**
 *                                   NetTCP_ConnCfgMSL_TimeoutHandler()
 *
 * @brief    (1) Configure TCP connection's   maximum segment lifetime (MSL):
 *               - (a) Validate  TCP connection MSL configuration
 *               - (b) Configure TCP connection MSL
 *
 * @param    conn_id_tcp         Handle identifier of TCP connection to configure MSL.
 *
 * @param    msl_timeout_sec     Desired value for TCP MSL timeout (in seconds).
 *
 * @return   DEF_OK,   TCP connection maximum retransmission timeout successfully configured.
 *           DEF_FAIL, otherwise.
 *
 * @note     (2) NetTCP_ConnCfgMSL_TimeoutHandler() is called by network protocol suite function(s)
 *               & MUST be called with the global network lock already acquired.
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnCfgMSL_TimeoutHandler(NET_TCP_CONN_ID     conn_id_tcp,
                                             NET_TCP_TIMEOUT_SEC msl_timeout_sec)
{
  NET_TCP_CONN *p_conn;

  //                                                               ------------------- VALIDATE MLS -------------------
#if (NET_TCP_CONN_TIMEOUT_MAX_SEG_MIN_SEC > 0)
  RTOS_ASSERT_DBG((msl_timeout_sec >= NET_TCP_CONN_TIMEOUT_MAX_SEG_MIN_SEC), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

#if ((NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC < DEF_INT_08U_MAX_VAL)                                                                   \
  || ((NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC < DEF_INT_16U_MAX_VAL) && (NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC > DEF_INT_08U_MAX_VAL)) \
  || ((NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC < DEF_INT_32U_MAX_VAL) && (NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC > DEF_INT_16U_MAX_VAL)))
  RTOS_ASSERT_DBG((msl_timeout_sec <= NET_TCP_CONN_TIMEOUT_MAX_SEG_MAX_SEC), RTOS_ERR_INVALID_ARG, DEF_FAIL);
#endif

  //                                                               ----------------- CFG TCP CONN MSL -----------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  p_conn->TimeoutMaxSeg_sec = msl_timeout_sec;

  return (DEF_OK);
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnIsUsed()
 *
 * @brief    Validate TCP connection in use.
 *
 * @param    conn_id_tcp     Handle identifier of TCP connection to validate.
 *
 * @return   DEF_YES, TCP connection   valid &      in use.
 *           DEF_NO,  TCP connection invalid or NOT in use.
 *
 * @note     (1) NetTCP_ConnIsUsed() blocked until network initialization completes.
 *
 * @note     (2) NetTCP_ConnIsUsed() MUST be called with the global network lock already acquired.
 *******************************************************************************************************/
CPU_BOOLEAN NetTCP_ConnIsUsed(NET_TCP_CONN_ID conn_id_tcp)
{
  NET_TCP_CONN *p_conn = DEF_NULL;
  CPU_BOOLEAN  used = DEF_NO;

  if (conn_id_tcp == NET_TCP_CONN_ID_NONE) {
    return (DEF_NO);
  }
  //                                                               --------------- VALIDATE TCP CONN ID ---------------
  RTOS_ASSERT_CRITICAL((conn_id_tcp >= NET_TCP_CONN_ID_MIN), RTOS_ERR_INVALID_ARG, DEF_NO);
  RTOS_ASSERT_CRITICAL((conn_id_tcp <= (NET_TCP_CONN_QTY)NET_TCP_CONN_ID_MAX), RTOS_ERR_INVALID_ARG, DEF_NO);

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];
  used = DEF_BIT_IS_SET(p_conn->Flags, NET_TCP_FLAG_USED);

  return (used);
}

/********************************************************************************************************
 ********************************************************************************************************
 *                                           LOCAL FUNCTIONS
 ********************************************************************************************************
 *******************************************************************************************************/

/****************************************************************************************************//**
 *                                           NetTCP_RxPktValidate()
 *
 * @brief    (1) Validate received TCP packet :
 *
 *           - (a) Get TCP packet RTT timestamp received               See 'NetTCP_TxConnRTT_RTO_Calc()
 *                                                                               Note #2a2A2'
 *
 *           - (b) (1) Validate the received packet's following TCP header fields :
 *
 *                   - (A) Source      Port
 *                   - (B) Destination Port
 *                   - (C) Header  Length
 *                   - (D) Segment Length                              See Note #4
 *                   - (E) Flags
 *                   - (F) Check-Sum                                   See Note #5
 *                   - (G) Options
 *
 *               - (2) Validation ignores the following TCP header fields :
 *
 *                   - (A) Sequence        Number
 *                   - (B) Acknowledgement Number
 *                   - (C) Window Advertisement
 *                   - (D) Urgent Pointer                              See 'net_tcp.c  Note #1b'
 *
 *           - (c) Convert the following TCP header fields from network-order to host-order :
 *
 *               - (1) Source      Port                                See Note #1cB1
 *               - (2) Destination Port                                See Note #1cB2
 *               - (3) Sequence        Number                          See Note #1cB3
 *               - (4) Acknowledgement Number                          See Note #1cB4
 *               - (5) Header Length/Flags                             See Note #1cB5
 *               - (6) Window Advertisement                            See Note #1cB6
 *               - (7) Check-Sum                                       See Note #4f
 *               - (8) Urgent Pointer                                  See 'net_tcp.c  Note #1b'
 *
 *                   - (A) These fields are NOT converted directly in the received packet buffer's
 *                           data area but are converted in local or network buffer variables ONLY.
 *
 *                   - (B) The following TCP header fields are converted & stored in network buffer
 *                           variables :
 *
 *                       - (1) Source      Port
 *                       - (2) Destination Port
 *                       - (3) Sequence        Number
 *                       - (4) Acknowledgement Number
 *                       - (5) Header Length/Flags
 *                       - (6) Window Advertisement
 *
 *           - (d) Update network buffer's protocol controls
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header.
 *
 * @param    p_tcp_hdr   Pointer to received packet's TCP header.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) See 'net_tcp.h  TCP HEADER' for TCP header format.
 *
 * @note     (3) The following TCP header fields MUST be decoded &/or converted from network-order to host-
 *                       order BEFORE any TCP Reset Segments are transmitted (see 'NetTCP_TxConnReset()  Note #2') :
 *
 *                           - (a) Sequence        Number
 *                           - (b) Acknowledgement Number
 *                           - (c) Segment Length
 *
 * @note     (4) Since TCP segment headers do NOT contain a segment length field, the TCP Segment Length
 *                       is assumed to be the remaining IP Datagram Length.
 *
 * @note     (5) (a) TCP header Check-Sum field MUST be validated BEFORE (or AFTER) any multi-octet words
 *                       are converted from network-order to host-order since "the sum of 16-bit integers can
 *                       be computed in either byte order" [RFC #1071, Section 2.(B)].
 *
 *                       In other words, the TCP Segment Check-Sum CANNOT be validated AFTER SOME but NOT ALL
 *                       multi-octet words have been converted from network-order to host-order.
 *
 *                           - (b) However, ALL received packets' multi-octet words are converted in local or network
 *                       buffer variables ONLY (see Note #1cA).  Therefore, TCP Segment Check-Sum may be
 *                       validated at any point.
 *
 *                           - (c) The TCP Segment Check-Sum MUST be validated AFTER the TCP segment length has been
 *                       validated so that the total TCP Segment Length (in octets) will already be calculated
 *                       for the TCP Check-Sum calculation.
 *
 *                       For efficiency, the TCP Segment Check-Sum is validated AFTER all other TCP header
 *                       fields have been validated.  Thus the iteration-intensive TCP Segment Check-Sum is
 *                       calculated only after all other TCP header fields have been quickly validated.
 *
 *                           - (d) (1) In addition to the TCP segment header & data, the TCP Check-Sum calculation
 *                       includes "a 96-bit pseudo header conceptually prefixed to the TCP header ...
 *                       [which] contains the Source Address, the Destination Address, the Protocol,
 *                       and TCP length" (see RFC #793, Section 3.1 'Header Format : Checksum').
 *
 *                           - (2) Since network check-sum functions REQUIRE that 16-bit one's-complement check-
 *                       sum calculations be performed on headers & data arranged in network-order (see
 *                       'net_util.c  NetUtil_16BitOnesCplChkSumDataVerify()  Note #4'), TCP pseudo-header
 *                       values MUST be set or converted to network-order.
 *
 *                           - (e) RFC #793, Section 3.1 'Header Format : Checksum' specifies that "if a segment contains
 *                       an odd number of header and text octets ... the last octet is padded ... with zeros to
 *                       form a 16-bit word for checksum purposes".
 *
 *                       See also 'net_util.c  NetUtil_16BitSumDataCalc()  Note #8'.
 *
 *                           - (f) After the TCP Segment Check-Sum is validated, it is NOT necessary to convert the Check-
 *                       Sum from network-order to host-order since    it is NOT required for further processing.
 *
 * @note     (6) (a) Since the minimum network buffer size MUST be configured such that the entire TCP
 *                       header MUST be received in a single packet (see 'net_buf.h  NETWORK BUFFER INDEX &
 *                       SIZE DEFINES  Note #1c'), after the TCP header size is decremented from the first
 *                       packet buffer's remaining number of data octets, any remaining octets MUST be user
 *                       &/or application data octets.
 *
 *                           - (1) Note that the 'Data' index is updated regardless of a null-size data length.
 *
 *                           - (b) If additional packet buffers exist, the remaining IP datagram 'Data' MUST be user
 *                       &/or application data.  Therefore, the 'Data' length does NOT need to be adjusted
 *                       but the 'Data' index MUST be updated.
 *
 *                           - (c) #### Total TCP Segment Length & Data Length is duplicated in ALL fragmented packet
 *                       buffers (may NOT be necessary; remove if unnecessary).
 *
 * @note     (7) (a) RFC #1122, Section 4.2.2.5 states that "[a] TCP MUST be prepared to handle an
 *                       illegal option length (e.g., zero) without crashing; a suggested procedure is
 *                       to reset the connection".  However, NO RFC specifies how TCP should handle
 *                       received segments with any other invalid TCP option fields.
 *
 *                       Therefore, it seems reasonable & is assumed that ALL TCP segments with ANY
 *                       invalid TCP option fields SHOULD transmit a TCP reset segment.
 *
 *                           - (b) RFC #1122, Sections 3.2.1 & 3.2.2 require that IP & ICMP packets with certain
 *                       invalid header fields be "silently discarded".  However, NO RFC specifies how
 *                       TCP should handle received segments with invalid header fields.
 *
 *                       Therefore, it seems reasonable & is assumed that ALL TCP segments with ANY
 *                       invalid header fields [other than invalid TCP option fields (see Note #7a)]
 *                       SHOULD be silently discarded.
 *
 * @note     (8) (a) RFC #1122, Section 3.2.1.8 states that "all IP options ... received in datagrams
 *                       MUST be passed to the transport layer ... [which] MUST ... interpret those IP
 *                       options that they understand and silently ignore the others".
 *
 *                           - (b) RFC #1122, Section 4.2.3.8 reiterates that "when received options are passed up
 *                       to TCP from the IP layer, TCP MUST ignore options that it does not understand".
 *
 *                       NOT currently implemented. #### NET-814
 *******************************************************************************************************/
static void NetTCP_RxPktValidate(NET_BUF     *p_buf,
                                 NET_BUF_HDR *p_buf_hdr,
                                 NET_TCP_HDR *p_tcp_hdr,
                                 RTOS_ERR    *p_err)
{
#if ((defined(NET_IPv4_MODULE_EN)) \
  && (!defined(NET_TCP_CHK_SUM_OFFLOAD_RX)))
  NET_TCP_PSEUDO_HDR tcp_pseudo_hdrv4;
#endif
#if ((defined(NET_IPv6_MODULE_EN)) \
  && (!defined(NET_TCP_CHK_SUM_OFFLOAD_RX)))
  NET_IPv6_PSEUDO_HDR tcp_pseudo_hdrv6;
#endif
  CPU_INT08U        tcp_hdr_len_tot;
  CPU_INT16U        tcp_hdr_len;
  CPU_INT16U        tcp_tot_len;
  CPU_INT16U        tcp_data_len;
  NET_TCP_HDR_FLAGS tcp_flags;
  CPU_BOOLEAN       tcp_flags_reserved;
  CPU_BOOLEAN       tcp_chk_sum_valid;
  CPU_BOOLEAN       tcp_chk_sum_ipv6;
  NET_BUF           *p_buf_next;
  NET_BUF_HDR       *p_buf_next_hdr;
  RTOS_ERR          local_err;

#ifdef  NET_TCP_CHK_SUM_OFFLOAD_RX
  PP_UNUSED_PARAM(p_buf);
#endif
  //                                                               ---------------- GET TCP RTT RX TS -----------------
  p_buf_hdr->TCP_RTT_TS_Rxd_ms = (NET_TCP_TX_RTT_TS_MS)NetUtil_TS_Get_ms();

  //                                                               ---------------- VALIDATE TCP PORTS ----------------
  NET_UTIL_VAL_COPY_GET_NET_16(&p_buf_hdr->TransportPortSrc, &p_tcp_hdr->PortSrc);
  if (p_buf_hdr->TransportPortSrc == NET_TCP_PORT_NBR_RESERVED) {
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrPortSrcCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  NET_UTIL_VAL_COPY_GET_NET_16(&p_buf_hdr->TransportPortDest, &p_tcp_hdr->PortDest);
  if (p_buf_hdr->TransportPortDest == NET_TCP_PORT_NBR_RESERVED) {
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrPortDestCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  //                                                               --------------- VALIDATE TCP HDR LEN ---------------
  //                                                               See 'net_tcp.h  TCP HEADER  Note #2'.
  NET_UTIL_VAL_COPY_GET_NET_16(&p_buf_hdr->TCP_HdrLen_Flags, &p_tcp_hdr->HdrLen_Flags);
  tcp_hdr_len = (CPU_INT16U)(p_buf_hdr->TCP_HdrLen_Flags & NET_TCP_HDR_LEN_MASK);
  tcp_hdr_len >>= NET_TCP_HDR_LEN_SHIFT;
  if (tcp_hdr_len < NET_TCP_HDR_LEN_MIN) {                      // If hdr len < min hdr len, rtn err.
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrLenCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  if (tcp_hdr_len > NET_TCP_HDR_LEN_MAX) {                      // If hdr len > max hdr len, rtn err.
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrLenCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  tcp_hdr_len_tot = (CPU_INT08U)(tcp_hdr_len * NET_TCP_HDR_LEN_WORD_SIZE);

  //                                                               ------------- VALIDATE TCP SEG TOT LEN -------------
  tcp_tot_len = p_buf_hdr->IP_DatagramLen;                      // See Note #4.
  p_buf_hdr->TransportTotLen = tcp_tot_len;
  if (p_buf_hdr->TransportTotLen < NET_TCP_TOT_LEN_MIN) {       // If seg tot len < min tot len, rtn err.
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrSegLenCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  if (p_buf_hdr->TransportTotLen > NET_TCP_TOT_LEN_MAX) {       // If seg tot len > max tot len, rtn err.
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrSegLenCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  //                                                               ---------------- VALIDATE TCP FLAGS ----------------
  //                                                               See 'net_tcp.h  TCP HEADER  Note #2'.
#if 1                                                           // Allow invalid reserved flags for rx'd segs.
  tcp_flags = p_buf_hdr->TCP_HdrLen_Flags  & NET_TCP_HDR_FLAG_MASK;
  tcp_flags_reserved = DEF_BIT_IS_SET_ANY(tcp_flags, NET_TCP_HDR_FLAG_RESERVED);
  if (tcp_flags_reserved != DEF_NO) {                           // If reserved flag bits set, rtn err.
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagsCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }
#endif

  p_buf_hdr->TCP_SegSync = DEF_BIT_IS_SET(p_buf_hdr->TCP_HdrLen_Flags, NET_TCP_HDR_FLAG_SYNC);
  p_buf_hdr->TCP_SegClose = DEF_BIT_IS_SET(p_buf_hdr->TCP_HdrLen_Flags, NET_TCP_HDR_FLAG_CLOSE);
  p_buf_hdr->TCP_SegAck = DEF_BIT_IS_SET(p_buf_hdr->TCP_HdrLen_Flags, NET_TCP_HDR_FLAG_ACK);
  p_buf_hdr->TCP_SegReset = DEF_BIT_IS_SET(p_buf_hdr->TCP_HdrLen_Flags, NET_TCP_HDR_FLAG_RESET);

  //                                                               --------------- VALIDATE TCP CHK SUM ---------------
  //                                                               See Note #5.

  tcp_chk_sum_ipv6 = DEF_BIT_IS_SET(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);
  if (tcp_chk_sum_ipv6 == DEF_NO) {
#ifdef NET_IPv4_MODULE_EN
#ifdef NET_TCP_CHK_SUM_OFFLOAD_RX
    tcp_chk_sum_valid = DEF_YES;
#else
    //                                                             Prepare TCP chk sum pseudo-hdr (see Note #5d).
    tcp_pseudo_hdrv4.AddrSrc = NET_UTIL_HOST_TO_NET_32(p_buf_hdr->IP_AddrSrc);
    tcp_pseudo_hdrv4.AddrDest = NET_UTIL_HOST_TO_NET_32(p_buf_hdr->IP_AddrDest);
    tcp_pseudo_hdrv4.Zero = 0x00u;
    tcp_pseudo_hdrv4.Protocol = NET_IP_HDR_PROTOCOL_TCP;
    tcp_pseudo_hdrv4.TotLen = NET_UTIL_HOST_TO_NET_16(p_buf_hdr->TransportTotLen);

    tcp_chk_sum_valid = NetUtil_16BitOnesCplChkSumDataVerify(p_buf,
                                                             &tcp_pseudo_hdrv4,
                                                             NET_TCP_PSEUDO_HDR_SIZE);
#endif
#else
    tcp_chk_sum_valid = DEF_FAIL;
#endif
  } else {
#ifdef NET_IPv6_MODULE_EN
#ifdef NET_TCP_CHK_SUM_OFFLOAD_RX
    tcp_chk_sum_valid = DEF_YES;
#else
    tcp_pseudo_hdrv6.AddrSrc = p_buf_hdr->IPv6_AddrSrc;
    tcp_pseudo_hdrv6.AddrDest = p_buf_hdr->IPv6_AddrDest;
    tcp_pseudo_hdrv6.UpperLayerPktLen = (CPU_INT32U)NET_UTIL_HOST_TO_NET_32(p_buf_hdr->TransportTotLen);
    tcp_pseudo_hdrv6.Zero = 0x00u;
    tcp_pseudo_hdrv6.NextHdr = NET_UTIL_NET_TO_HOST_16(NET_IP_HDR_PROTOCOL_TCP);
    tcp_chk_sum_valid = NetUtil_16BitOnesCplChkSumDataVerify(p_buf,
                                                             &tcp_pseudo_hdrv6,
                                                             NET_IPv6_PSEUDO_HDR_SIZE);
#endif
#else
    tcp_chk_sum_valid = DEF_FAIL;
#endif
  }

  if (tcp_chk_sum_valid != DEF_OK) {
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrChkSumCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }
#if 0                                                           // See Note #5f.
  (void)NET_UTIL_VAL_GET_NET_16(&p_tcp_hdr->ChkSum);
#endif

  //                                                               ---------------- UDPATE TCP FIELDS -----------------
  //                                                               See Notes #1c & #3.
  NET_UTIL_VAL_COPY_GET_NET_32(&p_buf_hdr->TCP_SeqNbr, &p_tcp_hdr->SeqNbr);
  NET_UTIL_VAL_COPY_GET_NET_32(&p_buf_hdr->TCP_AckNbr, &p_tcp_hdr->AckNbr);
  NET_UTIL_VAL_COPY_GET_NET_16(&p_buf_hdr->TCP_WinSize, &p_tcp_hdr->WinSize);

  p_buf_hdr->TransportHdrLen = tcp_hdr_len_tot;
  tcp_data_len = tcp_tot_len - p_buf_hdr->TransportHdrLen;
  p_buf_hdr->TransportDataLen = tcp_data_len;
  p_buf_hdr->TCP_SegLenInit = p_buf_hdr->TransportDataLen;
  p_buf_hdr->TCP_SegLen = p_buf_hdr->TCP_SegLenInit;

  //                                                               ---------------- VALIDATE TCP OPTS -----------------
  if (tcp_hdr_len_tot > NET_TCP_HDR_SIZE_MIN) {                 // If hdr len > min, validate/process TCP opts.
    NetTCP_RxPktValidateOpt(p_buf_hdr, p_tcp_hdr, tcp_hdr_len_tot, p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      NetTCP_TxConnReset(DEF_NULL,                              // ... tx TCP conn reset (see Note #7a).
                         p_buf_hdr,
                         NET_TCP_CONN_TX_RESET,
                         NET_TCP_CONN_CLOSE_ALL,
                         &local_err);
      goto exit;
    }
  }

  //                                                               ----------------- UPDATE BUF CTRLS -----------------
  //                                                               Calc TCP data len/ix (see Note #6a).
#if 0                                                           // See Note #3c.
  p_buf_hdr->TransportHdrLen = tcp_hdr_len_tot;
#endif

#if 0                                                           // See Note #3c.
  tcp_data_len = tcp_tot_len - p_buf_hdr->TransportHdrLen;
  p_buf_hdr->TransportDataLen = tcp_data_len;
  p_buf_hdr->TCP_SegLenInit = p_buf_hdr->TransportDataLen;
  p_buf_hdr->TCP_SegLen = p_buf_hdr->TCP_SegLenInit;
#endif
  p_buf_hdr->TCP_SegLenData = p_buf_hdr->TCP_SegLenInit;
  p_buf_hdr->TCP_SeqNbrInit = p_buf_hdr->TCP_SeqNbr;

  p_buf_hdr->DataLen -= (NET_BUF_SIZE) p_buf_hdr->TransportHdrLen;
  p_buf_hdr->DataIx = (CPU_INT16U)(p_buf_hdr->TransportHdrIx + p_buf_hdr->TransportHdrLen);
  p_buf_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_APP;

  p_buf_next = p_buf_hdr->NextBufPtr;
  while (p_buf_next != DEF_NULL) {                              // Calc ALL pkt bufs' data len/ix    (see Note #6b).
    p_buf_next_hdr = &p_buf_next->Hdr;
    p_buf_next_hdr->DataIx = p_buf_next_hdr->TransportHdrIx;
    p_buf_next_hdr->TransportHdrLen = 0u;                       // NULL TCP hdr  len in each pkt buf.
    p_buf_next_hdr->TransportTotLen = tcp_tot_len;              // Dup  TCP tot  len & ...
    p_buf_next_hdr->TransportDataLen = tcp_data_len;            // ...      data len in each pkt buf (see Note #6c).
    p_buf_next_hdr->TCP_SegLenInit = p_buf_next_hdr->TransportDataLen;
    p_buf_next_hdr->TCP_SegLen = p_buf_next_hdr->TCP_SegLenInit;
    p_buf_next_hdr->TCP_SegLenData = p_buf_next_hdr->TCP_SegLenInit;
    p_buf_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_APP;
    p_buf_next = p_buf_next_hdr->NextBufPtr;
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_RxPktValidateOpt()
 *
 * @brief    Validate & process received packet's TCP options.
 *
 * @param    p_buf_hdr           Pointer to network buffer header that received TCP packet.
 *
 * @param    p_tcp_hdr           Pointer to received packet's TCP header.
 *
 * @param    tcp_hdr_len_size    Length  of received packet's TCP header.
 *
 * @param    p_err               Pointer to variable that will receive the return error code from this function.
 *
 * @note     (1) (a) See 'net_tcp.h  TCP HEADER OPTIONS DEFINES' for   supported TCP options' summary.
 *
 *                                   - (b) See 'net_tcp.c  Note #1c'                   for unsupported TCP options.
 *
 *                               See also Note #2b3.
 *
 * @note     (2) (a) RFC # 793, Section 3.1 'Options' states that each option is "a multiple of 8 bits
 *                               in length" and "may begin on any octet boundary".
 *
 *                                   - (1) Since TCP options are NOT required or guaranteed to align multi-octet words on
 *                               appropriate word boundaries, ALL TCP options are decoded & processed a single
 *                               octet at a time.
 *
 *                                   - (b) RFC #1122, Section 4.2.2.5 states that :
 *
 *                                   - (1) "A TCP MUST be able to receive a TCP option in any segment."
 *
 *                                   - (2) "A TCP MUST ignore without error any TCP option it does not implement, assuming
 *                               that the option has a field length" ...
 *
 *                                   - (3) "All TCP options defined in the future will have length fields."
 *
 *                               See also 'net_tcp.h  TCP HEADER OPTIONS DEFINES  Note #2b'.
 *******************************************************************************************************/
static void NetTCP_RxPktValidateOpt(NET_BUF_HDR *p_buf_hdr,
                                    NET_TCP_HDR *p_tcp_hdr,
                                    CPU_INT08U  tcp_hdr_len_size,
                                    RTOS_ERR    *p_err)
{
  CPU_INT08U  *p_opts;
  CPU_INT08U  opt_list_len_size;
  CPU_INT08U  opt_list_len_rem;
  CPU_INT08U  opt_len;
  CPU_INT08U  opt_nbr_max_seg_size;
  CPU_BOOLEAN opt_list_end;

  opt_list_len_size = tcp_hdr_len_size - NET_TCP_HDR_SIZE_MIN;  // Calc opt list len size.

  //                                                               ---------- VALIDATE TCP HDR OPT LIST SIZE ----------
  if (opt_list_len_size > NET_TCP_HDR_OPT_SIZE_MAX) {           // If tot opt len > max opt size, ...
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);                              // ... rtn err.
    goto exit;
  }

  if ((opt_list_len_size % NET_TCP_HDR_OPT_SIZE_WORD) != 0u) {  // If tot opt len NOT multiple of opt size, ...
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);                              // ... rtn err.
    goto exit;
  }

  //                                                               ------------- DECODE/VALIDATE TCP OPTS -------------
  opt_list_end = DEF_NO;
  opt_nbr_max_seg_size = 0u;

  p_opts = (CPU_INT08U *)&p_tcp_hdr->Opts[0];
  opt_list_len_rem = opt_list_len_size;

  while (opt_list_len_rem > 0) {                                // Process each opt in list (see Notes #1 & #2).
    switch (*p_opts) {
      case NET_TCP_HDR_OPT_END_LIST:                            // ------------------- END OPT LIST -------------------
        opt_list_end = DEF_YES;                                 // Mark end of opt list.
        opt_len = NET_TCP_HDR_OPT_LEN_END_LIST;
        break;

      case NET_TCP_HDR_OPT_NOP:                                 // --------------------- NOP OPT ----------------------
#if 1                                                           // NOP's invalid after END.
        if (opt_list_end != DEF_NO) {                           // If opt found AFTER end of opt list, rtn err.
          NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
        }
#endif
        opt_len = NET_TCP_HDR_OPT_LEN_NOP;
        break;

      case NET_TCP_HDR_OPT_MAX_SEG_SIZE:                        // ----------------- MAX SEG SIZE OPT -----------------
        if (opt_list_end != DEF_NO) {                           // If opt found AFTER end of opt list, rtn err.
          NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
        }
        if (opt_nbr_max_seg_size > 0) {                         // If > 1 max seg size opt,            rtn err.
          NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
        }
        opt_nbr_max_seg_size++;

        (void)NetTCP_RxPktValidateOptMaxSegSize(p_buf_hdr, p_opts, &opt_len, p_err);
        if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
          goto exit;
        }
        break;
      //                                                           --------------- UNSUPPORTED TCP OPTS ---------------
      //                                                           See Notes #1b & #2b2.
      case NET_TCP_HDR_OPT_WIN_SCALE:
      case NET_TCP_HDR_OPT_SACK_PERMIT:
      case NET_TCP_HDR_OPT_SACK:
      case NET_TCP_HDR_OPT_ECHO_REQ:
      case NET_TCP_HDR_OPT_ECHO_REPLY:
      case NET_TCP_HDR_OPT_TS:
      default:                                                  // ----------------- INVALID TCP OPTS -----------------
        opt_len = *(p_opts + 1);                                // Ignore unknown opts      (see Note #2b2).
        if (opt_len < NET_TCP_HDR_OPT_LEN_MIN_LEN) {            // If opt len < min opt len (see Note #2b3), rtn err.
          NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
        }
        break;
    }

    if (opt_len > opt_list_len_rem) {                           // If opt len > rem opt list len, rtn err.
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
    }

    opt_list_len_rem -= opt_len;
    p_opts += opt_len;
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                   NetTCP_RxPktValidateOptMaxSegSize()
 *
 * @brief    Validate & process received TCP Maximum Segment Size option.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_opt       Pointer to Maximum Segment Size option.
 *
 * @param    p_opt_len   Pointer to variable that will receive the TCP option length (in octets).
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @return   DEF_OK, If Maximum Segment Size option is validate sucessfully.
 *           DEF_FAIL,  otherwise.
 *
 * @note     (1) See 'net_tcp.h  TCP HEADER OPTIONS DEFINES  Note #2b1' for TCP Maximum Segment Size
 *               option summary.
 *
 * @note     (2) (a) RFC # 793, Section 3.1 'Options' states that each option is "a multiple of 8 bits
 *                   in length" and "may begin on any octet boundary".
 *
 *           - (b) Since TCP options are NOT required or guaranteed to align multi-octet words on
 *                   appropriate word boundaries, ALL TCP options are decoded & processed a single
 *                   octet at a time.
 *******************************************************************************************************/
static CPU_BOOLEAN NetTCP_RxPktValidateOptMaxSegSize(NET_BUF_HDR *p_buf_hdr,
                                                     CPU_INT08U  *p_opt,
                                                     CPU_INT08U  *p_opt_len,
                                                     RTOS_ERR    *p_err)
{
  NET_TCP_SEG_SIZE max_seg_size;
  CPU_BOOLEAN      rtn_val = DEF_FAIL;

  *p_opt_len = NET_TCP_HDR_OPT_LEN_MAX_SEG_SIZE;

  p_opt++;
  if (*p_opt != *p_opt_len) {                                   // If opt len != max seg size opt len, rtn err.
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  //                                                               Calc max seg size (see Note #2b).
  p_opt++;
  max_seg_size = *p_opt;
  max_seg_size <<= DEF_OCTET_NBR_BITS;
  p_opt++;
  max_seg_size += *p_opt;

  if (max_seg_size > NET_TCP_MAX_SEG_SIZE_MAX) {                // If max seg size > max, rtn err.
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrOptsCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  p_buf_hdr->TCP_MaxSegSize = max_seg_size;

  rtn_val = DEF_OK;

exit:
  return (rtn_val);
}

/****************************************************************************************************//**
 *                                           NetTCP_RxPktDemuxSeg()
 *
 * @brief    (1) Demultiplex received packet to appropriate TCP connection :
 *
 *           - (a) Search connection list for connection whose local &/or remote addresses are
 *                   identical to the received packet's destination & source addresses.
 *
 *           - (b) Update network buffer's connection controls.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) The 'SRCH CONN LIST FOR PKT/CONN ADDR(S)' pre-processor 'else'-conditional code will
 *                       never be compiled/linked since 'net_conn.h' ensures that the family type configuration
 *                       constant (NET_CONN_CFG_FAMILY) is configured with an appropriate family type value
 *                       (see 'net_conn.h  CONFIGURATION ERRORS').  The 'else'-conditional code is included for
 *                       completeness & as an extra precaution in case 'net_conn.h' is incorrectly modified.
 *
 * @note     (3) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : CLOSED [State]' states
 *                       that "an incoming segment ... causes a RST to be sent in response".
 *
 *                           - (b) RFC #792, Section 'Destination Unreachable Message : Description' states that
 *                       "if, in the destination host, the IP module cannot deliver the datagram because
 *                       the indicated ... process port is not active, the destination host may send a
 *                       destination unreachable message to the source host".
 *******************************************************************************************************/
static void NetTCP_RxPktDemuxSeg(NET_BUF     *p_buf,
                                 NET_BUF_HDR *p_buf_hdr,
                                 RTOS_ERR    *p_err)
{
  CPU_INT08U           addr_local[NET_CONN_ADDR_LEN_MAX];
  CPU_INT08U           addr_remote[NET_CONN_ADDR_LEN_MAX];
  NET_CONN_ADDR_LEN    addr_len = 0;
  NET_CONN_PROTOCOL_IX protocol_ix = NET_CONN_PROTOCOL_IX_NONE;
  NET_CONN_FAMILY      family = NET_CONN_FAMILY_NONE;
  NET_CONN_ID          conn_id = NET_CONN_ID_NONE;
  NET_CONN_ID          conn_id_transport = NET_CONN_ID_NONE;
  NET_CONN_ID          conn_id_app = NET_CONN_ID_NONE;
  NET_CONN_STATE       conn_state;
  RTOS_ERR             local_err;

  //                                                               ------- SRCH CONN LIST FOR PKT/CONN ADDR(S) --------
  p_buf_hdr = &p_buf->Hdr;

  Mem_Clr(&addr_local, NET_CONN_ADDR_LEN_MAX);

  Mem_Clr(&addr_remote, NET_CONN_ADDR_LEN_MAX);

  if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
    family = NET_CONN_FAMILY_IP_V4_SOCK;
    protocol_ix = NET_CONN_PROTOCOL_IX_IP_V4_TCP;
    //                                                             Cfg srch local  addr as pkt dest addr.
    NET_UTIL_VAL_COPY_SET_NET_16(&addr_local[NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortDest);
    NET_UTIL_VAL_COPY_SET_NET_32(&addr_local[NET_CONN_ADDR_IP_V4_IX_ADDR], &p_buf_hdr->IP_AddrDest);
    //                                                             Cfg srch remote addr as pkt src  addr.
    NET_UTIL_VAL_COPY_SET_NET_16(&addr_remote[NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortSrc);
    NET_UTIL_VAL_COPY_SET_NET_32(&addr_remote[NET_CONN_ADDR_IP_V4_IX_ADDR], &p_buf_hdr->IP_AddrSrc);

    addr_len = NET_SOCK_ADDR_LEN_IP_V4;
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    family = NET_CONN_FAMILY_IP_V6_SOCK;
    protocol_ix = NET_CONN_PROTOCOL_IX_IP_V6_TCP;
    //                                                             Cfg srch local  addr as pkt dest addr.
    NET_UTIL_VAL_COPY_SET_NET_16(&addr_local[NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortDest);
    Mem_Copy(&addr_local[NET_CONN_ADDR_IP_V6_IX_ADDR], &p_buf_hdr->IPv6_AddrDest, NET_IPv6_ADDR_SIZE);
    //                                                             Cfg srch remote addr as pkt src  addr.
    NET_UTIL_VAL_COPY_SET_NET_16(&addr_remote[NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortSrc);
    Mem_Copy(&addr_remote[NET_CONN_ADDR_IP_V6_IX_ADDR], &p_buf_hdr->IPv6_AddrSrc, NET_IPv6_ADDR_SIZE);

    addr_len = NET_SOCK_ADDR_LEN_IP_V6;
#endif
  }

  conn_id = NetConn_Srch(family,                                // Srch for TCP conn.
                         protocol_ix,
                         &addr_local[0],
                         &addr_remote[0],
                         addr_len,
                         &conn_id_transport,
                         &conn_id_app,
                         &conn_state);

  switch (conn_state) {
    case NET_CONN_STATE_FULL:                                   // Complete TCP conn found.
      p_buf_hdr->ConnType = NET_CONN_TYPE_CONN_FULL;
      break;

    case NET_CONN_STATE_HALF:                                   // Half     TCP conn found.
    case NET_CONN_STATE_HALF_WILDCARD:
      p_buf_hdr->ConnType = NET_CONN_TYPE_CONN_HALF;
      break;

    default:
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      NetTCP_TxConnReset(DEF_NULL,                              // ... tx TCP  conn reset   (see Note #3a), ...
                         p_buf_hdr,
                         NET_TCP_CONN_TX_RESET,
                         NET_TCP_CONN_CLOSE_ALL,
                         &local_err);
      if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_ICMPv4_MODULE_EN
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
        NetICMPv4_TxMsgErr(p_buf,                               // ... tx ICMP port unreach (see Note #3b), ...
                           NET_ICMPv4_MSG_TYPE_DEST_UNREACH,
                           NET_ICMPv4_MSG_CODE_DEST_PORT,
                           NET_ICMPv4_MSG_PTR_NONE,
                           &local_err);
#endif
      } else {
#ifdef  NET_ICMPv6_MODULE_EN
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
        NetICMPv6_TxMsgErr(p_buf,                               // ... tx ICMP port unreach (see Note #3b), ...
                           NET_ICMPv6_MSG_TYPE_DEST_UNREACH,
                           NET_ICMPv6_MSG_CODE_DEST_PORT_UNREACHABLE,
                           NET_ICMPv6_MSG_PTR_NONE,
                           &local_err);
#endif
      }
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDestCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_NOT_FOUND);
      goto exit;
  }

  //                                                               -------------- UPDATE BUF CONN CTRLS ---------------
  p_buf_hdr->Conn_ID = conn_id;
  p_buf_hdr->Conn_ID_Transport = conn_id_transport;
  p_buf_hdr->Conn_ID_App = conn_id_app;

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_RxPktConnHandler()
 *
 * @brief    (1) Handle received TCP packets for its TCP connection :
 *
 *           - (a) Demultiplex  TCP packet to appropriate TCP connection state handler
 *           - (b) Free/Discard TCP packet
 *           - (c) Update receive statistics                                           See Note #2
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) (a) SOME   TCP receive statistics already updated when packet is discarded; do NOT
 *                       re-update.
 *
 *                           - (b) Update TCP receive statistics even if any transitory transmit error(s) occur in
 *                       TCP connection state handler functions.
 *
 * @note     (3) RFC #1122, Section 4.2.2.13 states that "a host MAY implement a 'half-duplex' TCP
 *                       close sequence ... i.e., closed in only one direction, and a host is permitted to
 *                       continue sending data in the open direction on a half-closed connection".
 *
 *                           - (a) "A host ... that has called CLOSE cannot continue to read data from the
 *                       connection.  If such a host issues a CLOSE call while received data is
 *                       still pending ... its TCP SHOULD send a RST to show that data was lost."
 *
 *                       However, since it does NOT seem reasonable to allow a half-closed connection
 *                       "to continue sending data in the open direction" (i.e. from the host that did
 *                       NOT issue a CLOSE call) but prevent the receiving host (i.e. the host that DID
 *                       issue the CLOSE call) from receiving the transmitted data; it is assumed that
 *                       the host that issued the CLOSE call MUST be allowed to receive data transmitted
 *                       from the other host that has NOT yet issued its CLOSE.
 *
 *                           - (b) However, "if such a host issues a CLOSE call ... [and] new data is received
 *                       after CLOSE is called, its TCP SHOULD send a RST to show that data was lost".
 *
 *                       In other words, since a TCP connection in the connection-closing-data-available
 *                       state is closed to further TCP data or controls, a TCP reset segment is
 *                       transmitted as for the CLOSED state.
 *
 *                           - (c) "Some systems have not implemented half-closed connections."
 *
 * @note     (4) Network buffer already freed by lower layer/handler function(s).
 *******************************************************************************************************/
static void NetTCP_RxPktConnHandler(NET_BUF     *p_buf,
                                    NET_BUF_HDR *p_buf_hdr,
                                    RTOS_ERR    *p_err)
{
  NET_TCP_CONN    *p_conn;
  NET_TCP_CONN_ID conn_id_tcp;
  NET_TCP_STATUS  rx_status;
  CPU_BOOLEAN     is_used;
  RTOS_ERR        local_err;

  conn_id_tcp = (NET_TCP_CONN_ID)p_buf_hdr->Conn_ID_Transport;

  //                                                               -------------- VALIDATE TCP CONN USED --------------
  is_used = NetTCP_ConnIsUsed(conn_id_tcp);
  if (is_used != DEF_YES) {
    RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_HANDLE);
    goto exit;
  }

  //                                                               ------------ DEMUX TCP PKT TO TCP CONN -------------
  p_conn = &NetTCP_ConnTbl[conn_id_tcp];

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_LISTEN:
      rx_status = NetTCP_RxPktConnHandlerListen(p_conn, p_buf, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      switch (rx_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_VALID:
          NetTCP_RxPktFree(p_buf);
        //                                                         fallthrough

        case NET_TCP_STATUS_DATA:
          NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
          break;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
      rx_status = NetTCP_RxPktConnHandlerSyncRxd(p_conn, p_buf, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      switch (rx_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_VALID:
          NetTCP_RxPktFree(p_buf);
        //                                                         fallthrough

        case NET_TCP_STATUS_DATA:
          NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
          break;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_SYNC_TXD:
      rx_status = NetTCP_RxPktConnHandlerSyncTxd(p_conn, p_buf, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      switch (rx_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_VALID:
          NetTCP_RxPktFree(p_buf);
        //                                                         fallthrough

        case NET_TCP_STATUS_DATA:
          NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
          break;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_CONN:
      rx_status = NetTCP_RxPktConnHandlerConn(p_conn, p_buf, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      switch (rx_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_VALID:
          NetTCP_RxPktFree(p_buf);
        //                                                         fallthrough

        case NET_TCP_STATUS_DATA:
          NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
          break;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_FIN_WAIT_1:
      rx_status = NetTCP_RxPktConnHandlerFinWait1(p_conn, p_buf, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      switch (rx_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_VALID:
          NetTCP_RxPktFree(p_buf);
        //                                                         fallthrough

        case NET_TCP_STATUS_DATA:
          NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
          break;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_FIN_WAIT_2:
      rx_status = NetTCP_RxPktConnHandlerFinWait2(p_conn, p_buf, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      switch (rx_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_VALID:
          NetTCP_RxPktFree(p_buf);
        //                                                         fallthrough

        case NET_TCP_STATUS_DATA:
          NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
          break;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_CLOSING:
      rx_status = NetTCP_RxPktConnHandlerClosing(p_conn, p_buf, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      switch (rx_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_VALID:
          NetTCP_RxPktFree(p_buf);
        //                                                         fallthrough

        case NET_TCP_STATUS_DATA:
          NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
          break;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_TIME_WAIT:
      rx_status = NetTCP_RxPktConnHandlerTimeWait(p_conn, p_buf, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      switch (rx_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_VALID:
          NetTCP_RxPktFree(p_buf);
        //                                                         fallthrough

        case NET_TCP_STATUS_DATA:
          NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
          break;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_CLOSE_WAIT:
      rx_status = NetTCP_RxPktConnHandlerCloseWait(p_conn, p_buf, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      switch (rx_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_VALID:
          NetTCP_RxPktFree(p_buf);
        //                                                         fallthrough

        case NET_TCP_STATUS_DATA:
          NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
          break;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_LAST_ACK:
      rx_status = NetTCP_RxPktConnHandlerLastAck(p_conn, p_buf, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }
      switch (rx_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_VALID:
          NetTCP_RxPktFree(p_buf);
        //                                                         fallthrough

        case NET_TCP_STATUS_DATA:
          NET_CTR_STAT_INC(Net_StatCtrs.TCP.RxSegCompCtr);
          break;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      NetTCP_TxConnReset(DEF_NULL,                              // Tx TCP conn reset (see Note #3b).
                         p_buf_hdr,
                         NET_TCP_CONN_TX_RESET,
                         NET_TCP_CONN_CLOSE_ALL,
                         &local_err);
      NetTCP_RxPktFree(p_buf);
      goto exit;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    case NET_TCP_CONN_STATE_CLOSED:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerListen()
 *
 * @brief    (1) Handle TCP connection in LISTEN state :
 *
 *           - (a) Validate received TCP packet for current TCP connection state :
 *
 *               - (1) Reset           (RST)                                           See Note #2a
 *               - (2) Acknowledgement (ACK)                                           See Note #2b
 *               - (3) Synchronization (SYN)                                           See Note #2c
 *
 *           - (b) Check if TCP connection listen queue is available                   See Note #3
 *
 *           - (c) Prepare/configure TCP connection :
 *
 *               - (1) Clone new TCP connection from current TCP listen connection,    See Note #5a
 *                           if half-connection :
 *
 *                   - (A) Get  connections
 *                   - (B) Set  connection  identification handles
 *                   - (C) Set  connection  addresses
 *                   - (D) Add  connection  into connection list
 *                   - (E) Copy connection  from half-connection
 *
 *               - (2) Reconfigure current TCP listen connection,                      See Note #5b
 *                           if full-connection
 *
 *           - (d) Update TCP connection :
 *               - (1) Handle received TCP segment                                     See Note #2c2
 *               - (2) Configure TCP connection remote host maximum segment size       See Note #7
 *               - (3) Update    TCP connection state                                  See Note #2c
 *
 *           - (e) Transmit TCP connection synchronization for valid received          See Note #2c3
 *                       TCP connection requests
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State]' states that :
 *
 *                           - (a) "An incoming RST should be ignored."
 *
 *                           - (b) "Any acknowledgment is bad if it arrives on a connection still in the LISTEN state.
 *                       An acceptable reset segment should be formed for any arriving ACK-bearing segment."
 *
 *                           - (c) "If the SYN bit is set ... the connection state should be changed to SYN-RECEIVED" :
 *
 *                           - (1) "Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ ..."
 *                           - (A) See Note #2c3
 *
 *                           - (2) "And any other control or text should be queued for processing later."
 *
 *                           - (A) If any control or text is queued for later processing, the next sequence octet to
 *                       receive (RCV.NXT) MUST include the length of this received segment (SEG.LEN) :
 *
 *                           - (1) RCV.NXT = SEG.SEQ + SEG.LEN + 1
 *
 *                           - (3) "ISS should be selected and a SYN segment sent."
 *
 *                           - (d) "Any other control or text-bearing segment (not containing SYN) must have an ACK and
 *                       thus would be discarded by the ACK processing ... So you are unlikely to get here,
 *                       but if you do, drop the segment, and return."
 *
 *                           - (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states to
 *                       "not process the FIN if the state is CLOSED, LISTEN or SYN-SENT since the SEG.SEQ cannot
 *                       be validated; drop the segment".
 *
 * @note     (3) (a) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.11, Pages 257-258 states
 *                       that :
 *
 *                           - (1) "Each listening end point has a fixed length queue of connections that have been
 *                       accepted by TCP (i.e., the three-way handshake is complete), but not yet accepted
 *                       by the application."
 *
 *                           - (3) "When a connection request arrives (i.e., the SYN segment), ... the current number
 *                       of connections already queued for this listening end point [is checked] to see
 *                       whether to accept the connection or not."
 *
 *                           - (4) "If there is room on this listening end point's queue for this new connection, ...
 *                       the TCP module ACKs the SYN and completes the connection."
 *
 *                           - (5) "If there is not room on the queue for the new connection" :
 *
 *                           - (A) "TCP just ignores the received SYN."
 *                           - (B) "Nothing is sent back (i.e., no RST segment)."
 *
 *                           - (b) (A) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 15.9, Page 455
 *                       reiterates that :
 *
 *                           - (2) A "listen ... socket ... limit[s] ... the number of connections that can be
 *                       queued on the socket," ...
 *
 *                           - (5) "after which the socket layer refuses to queue additional connection requests.
 *                       When this occurs, TCP ignores incoming connection requests."
 *
 *                           - (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 28.2, Page 930
 *                       also states that :
 *
 *                           - (5) (A) "By silently dropping the segment" ...
 *                           - (B) "and not replying with an RST,"    ...
 *                           - (C) "The client's connection request should time out, causing the client to
 *                       retransmit the SYN."
 *
 *                           - (C) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.11, Pages 259-260
 *                       summarizes that :
 *
 *                           - (5) (A) "TCP ignores the incoming SYN when the queue is full," ...
 *                           - (B) "and doesn't respond with an RST,"                     ...
 *
 *                           - (C) (1) "because ... this condition could change in a short while ... [and] by
 *                       ignoring the SYN, the server forces the client TCP to re-transmit the
 *                       SYN later, hoping that the queue will then have room for the new
 *                       connection".
 *
 *                           - (2) Whereas page 259-260 counters that "if the server's TCP responded with
 *                       a reset, the client's active open would abort".
 *
 *                       See also 'NetTCP_RxPktConnHandlerListenQ_IsAvail()  Note #1'.
 *
 * @note     (4) The 'NET_CONN_CFG_FAMILY' pre-processor 'else'-conditional code will never be compiled/linked
 *                       since 'net_conn.h' ensures that the family type configuration constant (NET_CONN_CFG_FAMILY)
 *                       is configured with an appropriate family type value (see 'net_conn.h  CONFIGURATION ERRORS').
 *                       The 'else'-conditional code is included for completeness & as an extra precaution in case
 *                       'net_conn.h' is incorrectly modified.
 *
 * @note     (5) (a) (1) If any received TCP connection request to a LISTEN-state connection is a half-connection
 *                           -- i.e. a connection with ONLY the local address specified/configured -- then a new
 *                       connection is cloned from the LISTEN-state connection to handle each unique connection
 *                       request.
 *
 *                           - (2) The following connection parameters are cloned/copied from the LISTEN-state connection :
 *
 *                           - (A) Application connection handle identifier
 *                           - (1) When the cloned connection is fully connected/established, it is queued to the
 *                       LISTEN-state connection's application connection as a cloned network connection
 *                       until the connection is accepted & a new application connection is created.
 *
 *                       See also 'net_sock.c  NetSock_Accept()  Notes #1d & #1e'.
 *
 *                           - (B) (1) TCP connection receive  parameters
 *                           - (2) TCP connection transmit parameters
 *                           - (3) TCP connection timeout  values
 *
 *                       See also 'NetTCP_ConnCopy()  Note #1a'.
 *
 *                           - (b) If any received TCP connection request to a LISTEN-state connection is a full-connection --
 *                       i.e. a connection with BOTH the local & remote addresses specified/configured -- then the
 *                       LISTEN-state connection is reconfigured to handle the received connection request.
 *
 * @note     (6) On ANY TCP LISTEN-connection preparation error(s), network resources MUST be appropriately freed :
 *
 *                           - (a) If NO TCP     connections available, NO           resources  need be freed.
 *                           - (b) If NO network connections available, ONLY the TCP connection need be closed.
 *                           - (c) If    network connection preparation fails, the TCP & network connection MUST both
 *                       be closed.  However, the TCP connection need NOT close application connection(s).
 *
 *                       See also 'NetTCP_ConnCloseHandler()  Note #2b1C1'.
 *
 *                           - (d) If any remaining TCP connection preparation fails, the TCP & network connection MUST
 *                       both be closed.  The application connection(s) SHOULD NOT be closed since it is cloned
 *                       from the LISTEN-state connection (see Note #4), but network connections MAY need to be
 *                       de-referenced from the application connection(s).
 *
 * @note     (7) RFC #1122, Section 4.2.2.6 states that :
 *
 *                           - (a) A "TCP SHOULD send an MSS (Maximum Segment Size) option in every SYN segment".
 *
 *                           - (b) "If an MSS option is not received at connection setup, TCP MUST assume a default
 *                       send MSS of 536."
 *
 * @note     (8) TCP connection timeout for LISTEN state is implemented by TCP connection retransmission
 *                       function(s) (see 'NetTCP_TxConnReTxQ()  Note #3c').
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerListen(NET_TCP_CONN *p_conn,
                                                    NET_BUF      *p_buf,
                                                    NET_BUF_HDR  *p_buf_hdr,
                                                    RTOS_ERR     *p_err)
{
  CPU_INT08U           addr_local[NET_CONN_ADDR_LEN_MAX];
  CPU_INT08U           addr_remote[NET_CONN_ADDR_LEN_MAX];
  CPU_BOOLEAN          q_avail = DEF_NO;
  NET_TCP_SEG_SIZE     mss_dflt_tx = 0u;
  NET_TCP_SEQ_CODE     seq_code = 0u;
  NET_TCP_ACK_CODE     ack_code = 0u;
  NET_TCP_RESET_CODE   reset_code = 0u;
  NET_IF_NBR           if_nbr = NET_IF_NBR_NONE;
  NET_CONN_FAMILY      conn_family = NET_CONN_FAMILY_NONE;
  NET_CONN_PROTOCOL_IX conn_protocol_ix = NET_CONN_PROTOCOL_IX_NONE;
  NET_CONN_ID          conn_id = NET_CONN_ID_NONE;
  NET_CONN_ID          conn_id_clone = NET_CONN_ID_NONE;
  NET_CONN_ID          conn_id_clone_app = NET_CONN_ID_NONE;
  NET_TCP_CONN_ID      conn_id_clone_tcp = NET_CONN_ID_NONE;
  NET_TCP_CONN         *p_conn_clone = DEF_NULL;
  NET_TCP_CONN         *p_conn_tx_sync = DEF_NULL;
  NET_TCP_CONN_STATE   state = NET_TCP_CONN_STATE_NONE;
  NET_TCP_STATUS       rtn_status = NET_TCP_STATUS_INVALID;
  RTOS_ERR             local_err;

  //                                                               - VALIDATE THAT ADDR SRC AND DEST ARE NOT THE SAME -
  if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
    if (p_buf_hdr->IP_AddrDest == p_buf_hdr->IP_AddrSrc) {
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrAddrSrcCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
    }
#else
    RTOS_DBG_FAIL_EXEC_ERR(*p_err, RTOS_ERR_NOT_AVAIL, NET_TCP_STATUS_INVALID);
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    CPU_BOOLEAN is_identical;

    is_identical = NetIPv6_IsAddrsIdentical(&p_buf_hdr->IPv6_AddrDest, &p_buf_hdr->IPv6_AddrSrc);
    if (is_identical == DEF_YES) {
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrAddrSrcCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
    }
#else
    RTOS_DBG_FAIL_EXEC_ERR(*p_err, RTOS_ERR_NOT_AVAIL, NET_TCP_STATUS_INVALID);
#endif
  }

  //                                                               -------------- VALIDATE RX'D TCP PKT ---------------
  //                                                               Chk for rx'd fin/close.
  if (p_buf_hdr->TCP_SegClose == DEF_YES) {                     // If invalid   fin/close rx'd, ...
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagFinCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;                                                  // ... ignore TCP pkt    (see Note #2e).
  }

  //                                                               Chk for rx'd reset.
  reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr);
  if (reset_code != NET_TCP_CONN_RX_RESET_NONE) {               // If reset    rx'd, ...
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagRstCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;                                                  // ... ignore TCP pkt    (see Note #2a).
  }

  //                                                               Chk for rx'd ack.
  ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr);
  if (ack_code != NET_TCP_CONN_RX_ACK_NONE) {                   // If ack      rx'd, ...
                                                                // ... tx TCP conn reset (see Note #2b).
    RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
    NetTCP_TxConnReset(p_conn, p_buf_hdr, NET_TCP_CONN_TX_RESET, NET_TCP_CONN_CLOSE_ALL, &local_err);
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagAckCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  //                                                               Chk     rx'd seq nbr.
  seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr);
  if (seq_code != NET_TCP_CONN_RX_SEQ_SYNC) {                   // If sync NOT rx'd, ...
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagSynCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;                                                  // ... ignore TCP pkt    (see Note #2d).
  }
  //                                                               Else sync avail, update seg lens.
  p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_SYNC;
  p_buf_hdr->TCP_SegLen += NET_TCP_SEG_LEN_SYNC;

  //                                                               -------------- CHK TCP CONN LISTEN Q ---------------
  q_avail = NetTCP_RxPktConnHandlerListenQ_IsAvail(p_conn, p_err);   // Chk TCP listen Q     avail.
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit;
  }

  if (q_avail != DEF_YES) {                                     // If  TCP listen Q NOT avail (see Note #3a5),
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxListenQ_FullCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;                                                  // ... ignore TCP pkt         (see Note #3a5A).
  }

  //                                                               ----------------- PREPARE TCP CONN -----------------
  if (p_buf_hdr->ConnType != NET_CONN_TYPE_CONN_FULL) {         // If pkt demux'd to half-conn, clone new conn
                                                                // .. from LISTEN    half-conn (see Note #5a).
                                                                // -------------------- GET CONNS ---------------------

    conn_id_clone_tcp = NetTCP_ConnGet(p_conn->FnctAppPostRx,
                                       p_conn->FnctAppPostTx,
                                       p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {           // See Note #6a.
      goto exit;
    }

    p_conn_clone = &NetTCP_ConnTbl[conn_id_clone_tcp];

    if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
      conn_family = NET_CONN_FAMILY_IP_V4_SOCK;
      conn_protocol_ix = NET_CONN_PROTOCOL_IX_IP_V4_TCP;
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
      conn_family = NET_CONN_FAMILY_IP_V6_SOCK;
      conn_protocol_ix = NET_CONN_PROTOCOL_IX_IP_V6_TCP;
#endif
    }

    conn_id_clone = NetConn_Get(conn_family, conn_protocol_ix, p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {           // See Note #6b.
      NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_NO, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
    }

    //                                                             SET CONN IDs
    p_conn_clone->ID_Conn = conn_id_clone;
    NetConn_ID_TransportSet(conn_id_clone,
                            conn_id_clone_tcp);

    conn_id = p_conn->ID_Conn;
    conn_id_clone_app = NetConn_ID_AppGet(conn_id);             // Get half-conn's app conn id & ...
    if (conn_id_clone_app == NET_CONN_ID_NONE) {
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
    }

    NetConn_ID_AppCloneSet(conn_id_clone,                       // ... set as cloned conn's      ...
                           conn_id_clone_app);                  // ... app conn clone id (see Note #5a2A1).

    //                                                             ------------------ CFG CONN ADDRS ------------------
    Mem_Clr(&addr_local, NET_CONN_ADDR_LEN_MAX);

    Mem_Clr(&addr_remote, NET_CONN_ADDR_LEN_MAX);

    if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
      //                                                           Cfg local  addr as pkt dest addr.
      NET_UTIL_VAL_COPY_SET_NET_16(&addr_local[NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortDest);
      NET_UTIL_VAL_COPY_SET_NET_32(&addr_local[NET_CONN_ADDR_IP_V4_IX_ADDR], &p_buf_hdr->IP_AddrDest);
      //                                                           Cfg remote addr as pkt src  addr.
      NET_UTIL_VAL_COPY_SET_NET_16(&addr_remote[NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortSrc);
      NET_UTIL_VAL_COPY_SET_NET_32(&addr_remote[NET_CONN_ADDR_IP_V4_IX_ADDR], &p_buf_hdr->IP_AddrSrc);
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
      //                                                           Cfg local  addr as pkt dest addr.
      NET_UTIL_VAL_COPY_SET_NET_16(&addr_local[NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortDest);
      Mem_Copy(&addr_local[NET_CONN_ADDR_IP_V6_IX_ADDR], &p_buf_hdr->IPv6_AddrDest, NET_IPv6_ADDR_SIZE);
      //                                                           Cfg remote addr as pkt src  addr.
      NET_UTIL_VAL_COPY_SET_NET_16(&addr_remote[NET_CONN_ADDR_IP_IX_PORT], &p_buf_hdr->TransportPortSrc);
      Mem_Copy(&addr_remote[NET_CONN_ADDR_IP_V6_IX_ADDR], &p_buf_hdr->IPv6_AddrSrc, NET_IPv6_ADDR_SIZE);
#endif
    }

    if_nbr = p_buf_hdr->IF_Nbr;
    NetConn_AddrLocalSet(conn_id_clone,
                         if_nbr,
                         &addr_local[0],
                         NET_CONN_ADDR_LEN_MAX,
                         DEF_NO,
                         p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {           // See Note #6c.
      NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_NO, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
    }

    NetConn_AddrRemoteSet(conn_id_clone,
                          &addr_remote[0],
                          NET_CONN_ADDR_LEN_MAX,
                          DEF_NO,
                          p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {           // See Note #6c.
      NetTCP_ConnClose(p_conn_clone, p_buf_hdr, DEF_NO, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
    }

    NetConn_ListAdd(conn_id_clone);                             // Add conn into conn list.

    //                                                             Copy half-conn state to full conn.
    NetTCP_ConnCopy(p_conn_clone, p_conn);

#ifndef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
    NetTCP_RxConnWinSizeHandler(p_conn_clone, DEF_NULL, 0, NET_TCP_CONN_RX_WIN_ZERO);
#endif
    p_conn_tx_sync = p_conn_clone;
  } else {                                                      // Else conn to listen TCP conn (see Note #5b).
    p_conn_tx_sync = p_conn;
  }

  //                                                               ----------------- HANDLE RX'D SEG ------------------
  rtn_status = NetTCP_RxPktConnHandlerSeg(p_conn_tx_sync, ack_code, p_buf, p_buf_hdr, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    NetTCP_ConnClose(p_conn_tx_sync, p_buf_hdr, p_conn_tx_sync->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
    goto exit;                                                  // See Note #6d.
  }

  switch (rtn_status) {
    case NET_TCP_STATUS_NONE:
    case NET_TCP_STATUS_DATA:
      break;

    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      NetTCP_ConnClose(p_conn_tx_sync, p_buf_hdr, p_conn_tx_sync->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;                                                // See Note #6d.
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  //                                                               Cfg remote max seg size as advertised ...
  //                                                               ... by remote host (see Note #7).
  if (DEF_BIT_IS_SET(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME) == DEF_YES) {
#ifdef  NET_IPv6_MODULE_EN
    mss_dflt_tx = NET_TCP_MAX_SEG_SIZE_DFLT_V6;
#else
    NetTCP_ConnClose(p_conn_tx_sync, p_buf_hdr, p_conn_tx_sync->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
    RTOS_DBG_FAIL_EXEC_ERR(*p_err, RTOS_ERR_NOT_AVAIL, NET_TCP_STATUS_INVALID);
#endif
  } else {
#ifdef  NET_IPv4_MODULE_EN
    mss_dflt_tx = NET_TCP_MAX_SEG_SIZE_DFLT_V4;

#else
    NetTCP_ConnClose(p_conn_tx_sync, p_buf_hdr, p_conn_tx_sync->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
    RTOS_DBG_FAIL_EXEC_ERR(*p_err, RTOS_ERR_NOT_AVAIL, NET_TCP_STATUS_INVALID);
#endif
  }

  p_conn_tx_sync->MaxSegSizeRemote = (p_buf_hdr->TCP_MaxSegSize != NET_TCP_MAX_SEG_SIZE_NONE)
                                     ?  p_buf_hdr->TCP_MaxSegSize
                                     :  mss_dflt_tx;

  state = p_conn_tx_sync->ConnState;
  p_conn_tx_sync->ConnState = NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE;

  //                                                               ----------------- TX TCP CONN SYNC -----------------
  NetTCP_TxConnSync(p_conn_tx_sync, p_buf_hdr, state, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {             // See Note #6d.
    NetTCP_ConnClose(p_conn_tx_sync, p_buf_hdr, p_conn_tx_sync->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
    goto exit;
  }

  NetSock_ConnChildAdd(conn_id_clone_app, conn_id_clone, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    NetTCP_ConnClose(p_conn_tx_sync, p_buf_hdr, p_conn_tx_sync->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
    goto exit;
  }

exit:
  return (rtn_status);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerSyncRxd()
 *
 * @brief    (1) Handle TCP connection in SYN-RECEIVED state :
 *
 *           - (a) Validate received TCP packet for current TCP connection state :
 *
 *               - (1) Sequence Number (SEQ)                                       See Note  #2a
 *               - (2) Reset           (RST)                                       See Note  #2b
 *               - (3) Synchronization (SYN)                                       See Note  #2c
 *               - (4) Acknowledgement (ACK)                                       See Note  #2d
 *               - (5) Finish/Close    (FIN)                                       See Note  #2e
 *
 *           - (b) Update TCP connection :
 *               - (1) Handle received TCP segment                                 See Note  #2d2A1
 *               - (2) Update    TCP connection state                              See Notes #2d2A1a & #2e4
 *               - (3) Update    TCP connection timer
 *
 *           - (c) Acknowledge   TCP connection
 *               - (1) Signal    TCP/application connection complete
 *               - (2) Handle    TCP connection  received data                     See Note  #2d2A1
 *               - (3) Transmit  TCP connection  data                              See Notes #2d2A2  & #2e3
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) TCP connections in the SYN-RECEIVED state are handled as follows :
 *
 *                           - (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
 *                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
 *                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
 *
 *                           - (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
 *
 *                           - (2) "Initial tests on arrival are used to discard old duplicates."
 *
 *                           - (3) "If a segment's contents straddle the boundary between old and new, only the
 *                       new parts should be processed."
 *
 *                           - (4) (A) "If an incoming segment is not acceptable," ...
 *
 *                           - (B) "an acknowledgment should be sent in reply" ...
 *
 *                           - (C) "(unless the RST bit is set, if so drop the segment)".
 *
 *                       See also Notes #2b2Aa & #2b2C.
 *
 *                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
 *
 *                           - (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit :
 *                       SYN-RECEIVED STATE' states that "if the RST bit is set" and ...
 *
 *                           - (1) "If this connection was initiated with a passive OPEN (i.e., came from
 *                       the LISTEN state), then return this connection to the LISTEN state."
 *
 *                           - (2) "If this connection was initiated with an active OPEN (i.e., came from
 *                       the SYN-SENT state) then the connection was refused, signal the user
 *                       'connection refused' ... enter the CLOSED state."
 *
 *                           - (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing'
 *                       reiterates that "if the receiver ... of a RST ... was in SYN-RECEIVED state
 *                       and had previously been in the LISTEN state, then the receiver returns to
 *                       the LISTEN state, otherwise the receiver aborts the connection and goes to
 *                       the CLOSED state".
 *
 *                           - (C) However, since TCP connections opened from the LISTEN state are cloned from
 *                       the original LISTEN-state TCP connection, it is NOT necessary to return ANY
 *                       reset TCP connection from the SYN-RECEIVED state back to the LISTEN state.
 *
 *                       See also 'NetTCP_RxPktConnIsValidReset()  Note #2a4B'.
 *
 *                           - (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of
 *                       a segment with the RST when in a synchronized state" to "provide some
 *                       protection against ... blind reset attack[s] using the RST bit" :
 *
 *                           - (a) "If the RST bit is set and the sequence number is outside the expected
 *                       window, silently drop the segment."
 *
 *                           - (b) "If the RST bit is exactly the next expected sequence number [sic], reset
 *                       the connection"; it is assumed that this should read "if the RST bit is
 *                       set and the sequence number is exactly the next expected sequence number,
 *                       reset the connection."
 *
 *                           - (c) "If the RST bit is set and the sequence number does not exactly match
 *                       the next expected sequence value, yet is within the acceptable window
 *                       (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
 *
 *                           - (B) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that this
 *                       amendment applies only to the "handling of a ... RST ... when in a synchronized
 *                       state", it is assumed that this should also apply to the SYN-RECEIVED state.
 *
 *                       See also 'NetTCP_RxPktConnIsValidReset()  Note #2a5B'.
 *
 *                           - (C) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
 *                       priority for handling TCP segments received with BOTH the RST & SYN bits set.
 *
 *                       Therefore, since it does NOT seem reasonable to reset a TCP connection
 *                       due to a TCP segment that also attempted to synchronize the  TCP connection,
 *                       it is assumed that the amended handling of the SYN bit should take precedence
 *                       over the amended handling of the RST bit.
 *
 *                       See also Note #2c2.
 *
 *                           - (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
 *                       states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
 *                       FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that :
 *
 *                           - (A) "If the SYN is in the window it is an error, send a reset, any outstanding
 *                       RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
 *                       should be flushed, the user should also receive an unsolicited general
 *                       'connection reset' signal[, and] enter the CLOSED state."
 *
 *                           - (B) But "if the SYN is not in the window this step would not have been reached
 *                       and an ack would have been sent".
 *
 *                           - (2) (A) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
 *                       of a segment with the SYN bit set in the synchronized state ... [by] handling
 *                       ... the SYN bit" as follows :
 *
 *                           - (a) "If the SYN bit is set and the sequence number is outside the
 *                       expected window, send an ACK back to the peer."
 *
 *                           - (b) "If the SYN bit is set and the sequence number is an exact
 *                       match to the next expected sequence (RCV.NXT == SEG.SEQ)
 *                       then send an ACK segment ... but ... subtract one from
 *                       value being acknowledged."
 *
 *                           - (c) "If the SYN bit is set and the sequence number is acceptable,
 *                       i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
 *                       ACK segment."
 *
 *                           - (B) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that this
 *                       amendment applies only to the "handling of a ... SYN ... in a synchronized
 *                       state", it is assumed that this should also apply to the SYN-RECEIVED state.
 *
 *                           - (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field' states
 *                       that :
 *
 *                           - (1) "If the ACK bit is off drop the segment."
 *
 *                           - (2) "If the ACK bit is on [and in the] SYN-RECEIVED STATE" :
 *
 *                           - (A) (1) "If SND.UNA < SEG.ACK <= SND.NXT then" :
 *
 *                           - (a) "Enter the ESTABLISHED state" ...
 *                           - (b) "and continue processing."
 *
 *                           - (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT
 *                       [State]' states to "send ... [any] data or controls which were queued
 *                       for transmission" when the SYN-SENT state transitions to the ESTABLISHED
 *                       state.
 *
 *                       Although this section is the only section to state that any data or
 *                       controls should be sent when transitioning from the SYN-SENT state
 *                       to the ESTABLISHED state, it is assumed that any data or controls
 *                       should also be sent for the transition from the SYN-RECEIVED state
 *                       to the ESTABLISHED state.
 *
 *                           - (B) "If the segment acknowledgment is not acceptable, form a reset segment ...
 *                       and send it."
 *
 *                           - (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
 *                       that "if the FIN bit is set" :
 *
 *                           - (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
 *                       same message," ...
 *
 *                           - (2) "Advance RCV.NXT over the FIN," ...
 *
 *                           - (3) "Send an acknowledgment for the FIN" ...
 *
 *                           - (4) And the "SYN-RECEIVED STATE enter[s] the CLOSE-WAIT state".
 *
 * @note     (3) (a) (1) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
 *                       "for any state if the user timeout expires, flush all queues, signal the user
 *                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
 *
 *                           - (2) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
 *
 *                       Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
 *                       or control segment should reset its connection timer.
 *
 *                           - (b) (1) Once a TCP connection enters the connected state, most of its TCP connection timers
 *                       should be reset.
 *
 *                           - (2) However, the following timers MAY already have been allocated & initialized, & MUST
 *                       NOT be reset :
 *
 *                           - (A)    Transmit Idle timer              'TxQ_IdleTmr'
 *                           - (B) Re-transmit      timer              'ReTxQ_Tmr'
 *
 * @note     (4) Some  transitory errors were ignored &/or not returned from previous handler function(s).
 *                       These transitory errors are included for completeness & as an extra precaution in case
 *                       these transitory errors are returned by handler function(s).
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerSyncRxd(NET_TCP_CONN *p_conn,
                                                     NET_BUF      *p_buf,
                                                     NET_BUF_HDR  *p_buf_hdr,
                                                     RTOS_ERR     *p_err)
{
  NET_TCP_SEQ_CODE   seq_code;
  NET_TCP_ACK_CODE   ack_code;
  NET_TCP_RESET_CODE reset_code;
  NET_TCP_FREE_CODE  free_code;
  NET_TCP_CONN_STATE state;
  NET_TCP_STATUS     rtn_status = NET_TCP_STATUS_INVALID;
  CPU_INT32U         timeout_ms;
  RTOS_ERR           local_err;

  //                                                               -------------- VALIDATE RX'D TCP PKT ---------------
  //                                                               Chk for rx'd fin/close.
  if (p_buf_hdr->TCP_SegClose == DEF_YES) {                     // If fin/close avail, update seg lens.
    p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
    p_buf_hdr->TCP_SegLen += NET_TCP_SEG_LEN_CLOSE;
  }

  //                                                               Chk rx'd seq nbr.
  seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr);
  switch (seq_code) {
    case NET_TCP_CONN_RX_SEQ_VALID:
      break;

    case NET_TCP_CONN_RX_SEQ_SYNC:                              // If invalid sync rx'd, ...
    case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
      //                                                           ... tx TCP conn ack  (see Notes #2c2 & #2b2C).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagSynCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_RX_SEQ_NONE:
    case NET_TCP_CONN_RX_SEQ_INVALID:                           // If invalid seq  rx'd (see Note #2a4A), ...
    default:
      if (p_buf_hdr->TCP_SegReset != DEF_YES) {                 // ... & reset NOT rx'd (see Note #2a4C), ...
                                                                // ... tx TCP conn ack  (see Note #2a4B).
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
        (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      }
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxSeqInvalidCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd reset.
  reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr);
  switch (reset_code) {
    case NET_TCP_CONN_RX_RESET_NONE:
      break;

    case NET_TCP_CONN_RX_RESET_VALID:                           // If   valid reset rx'd, ...
                                                                // ...  close TCP conn (see Note #2b2Ab).
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      rtn_status = NET_TCP_STATUS_VALID;
      goto exit;

    case NET_TCP_CONN_RX_RESET_INVALID:                         // If invalid reset rx'd, ...
    default:
      //                                                           ... tx TCP conn ack (see Note #2b2Ac).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagRstCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd ack.
  ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr);
  switch (ack_code) {
    case NET_TCP_CONN_RX_ACK_VALID:
      break;

    case NET_TCP_CONN_RX_ACK_NONE:                              // If NO      ack rx'd, ...
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckNoneCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);                            // ... ignore TCP pkt    (see Note #2d1).
      goto exit;

    case NET_TCP_CONN_RX_ACK_INVALID:                           // If invalid ack rx'd, ...
    case NET_TCP_CONN_RX_ACK_DUP:
    case NET_TCP_CONN_RX_ACK_PREV:
    default:
      //                                                           ... tx TCP conn reset (see Note #2d2B).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      NetTCP_TxConnReset(p_conn, p_buf_hdr, NET_TCP_CONN_TX_RESET, NET_TCP_CONN_CLOSE_ALL, &local_err);
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagAckCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- HANDLE RX'D SEG ------------------
  rtn_status = NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, p_err);
  switch (RTOS_ERR_CODE_GET(*p_err)) {
    case RTOS_ERR_NONE:
      break;

    case RTOS_ERR_NET_IF_LINK_DOWN:                             // Ignore transitory tx err(s) [see Note #4].
      goto exit;

    default:
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
  }
  switch (rtn_status) {
    case NET_TCP_STATUS_NONE:
    case NET_TCP_STATUS_DATA:
      break;

    case NET_TCP_STATUS_DUP:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataDupCtr);
      goto exit;

    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  state = p_conn->ConnState;
  if (p_buf_hdr->TCP_SegClose != DEF_YES) {                     // If fin/close NOT rx'd, ...
    p_conn->ConnState = NET_TCP_CONN_STATE_CONN;                // ...  chng to conn'd     state (see Note #2d2A1a).
  } else {                                                      // Else chng to close-wait state (see Note #2e4).
    p_conn->ConnState = NET_TCP_CONN_STATE_CLOSE_WAIT;
  }

  p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CONN;

  //                                                               UPDATE TMR's
  free_code = NET_TCP_CONN_FREE_TMR_ALL;                        // See Note #3c1.
                                                                // See Note #3c2A.
  DEF_BIT_CLR(free_code, (NET_TCP_FREE_CODE)NET_TCP_CONN_FREE_TMR_TX_IDLE);
  //                                                               See Note #3c2B.
  DEF_BIT_CLR(free_code, (NET_TCP_FREE_CODE)NET_TCP_CONN_FREE_TMR_RE_TX);

  NetTCP_ConnFreeTmr(p_conn, free_code);                        // Free TCP conn tmr(s) [see Note #3b].

  //                                                               Get  TCP conn tmr.
  //                                                               Start    conn tmr    (see Note #3a2).
  timeout_ms = p_conn->TimeoutConn_sec * DEF_TIME_NBR_mS_PER_SEC;
  p_conn->TimeoutTmr = NetTmr_Get(NetTCP_ConnIdleTimeout,
                                  p_conn,
                                  timeout_ms,
                                  NET_TMR_OPT_NONE,
                                  p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
    goto exit;
  }

  //                                                               ------------------- ACK TCP CONN -------------------
  NetTCP_RxPktConnHandlerSignalConn(p_conn, state, p_err);      // Signal app conn (see Note #1c1).
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
    goto exit;
  }

  NetTCP_RxPktConnHandlerRxQ_AppData(p_conn);                   // Handle TCP conn rx'd data (see Note #2d2A1).

  if (p_conn->ConnState == NET_TCP_CONN_STATE_CONN) {           // If conn'd, tx any tx data (see Note #1c3).
    NetTCP_TxConnTxQ(p_conn,
                     p_buf_hdr,
                     NET_TCP_CONN_TX_ACK_NONE,
                     DEF_NO,
                     NET_TCP_CONN_CLOSE_ALL,
                     DEF_NO,
                     p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
  } else {                                                      // Else tx TCP conn ack (see Note #2e3).
    (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_IMMED, NET_TCP_CONN_CLOSE_ALL, p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
  }

exit:
  return (rtn_status);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerSyncTxd()
 *
 * @brief    (1) Handle TCP connection in SYN-SENT state :
 *
 *           - (a) Validate received TCP packet for current TCP connection state :
 *
 *               - (1) Acknowledgement (ACK)                                           See Note  #2a
 *               - (2) Reset           (RST)                                           See Note  #2b
 *               - (3) Synchronization (SYN)                                           See Note  #2c
 *
 *           - (b) Update TCP connection :
 *               - (1) Configure TCP connection remote host maximum segment size       See Note  #3
 *               - (2) Handle received TCP segment                                     See Note  #2c
 *               - (3) Update    TCP connection state                                  See Notes #2c3A1 & #2c3B1
 *               - (4) Update    TCP connection timer
 *
 *           - (c) Acknowledge   TCP connection
 *               - (1) Signal    TCP/application connection complete
 *               - (2) Handle    TCP connection  received data                         See Note  #2c3A3
 *               - (3) Transmit  TCP connection  acknowledgement & data                See Note  #2c3A2
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State]' states to :
 *
 *                           - (a) "First check the ACK bit[;] if the ACK bit is set" :
 *
 *                           - (1) "If SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send a reset (unless the RST bit is
 *                       set) ... and discard the segment."
 *
 *                           - (2) "If SND.UNA < SEG.ACK =< SND.NXT then the ACK is acceptable."
 *
 *                       See also 'NetTCP_RxPktConnIsValidAck()  Note #1c1A'.
 *
 *                           - (b) "Second check the RST bit[;] if the RST bit is set [and] if the ACK was acceptable
 *                       then signal the user 'error: connection reset', drop the segment, [and] enter
 *                       CLOSED state."
 *
 *                       See also 'NetTCP_RxPktConnIsValidReset()  Notes #2a3 & #2a5C'.
 *
 *                           - (c) "Fourth check the SYN bit[;] if the SYN bit is on and ... acceptable then" :
 *
 *                           - (1) "RCV.NXT is set to SEG.SEQ+1, IRS is set to SEG.SEQ."
 *                           - (A) See also Note #2c3B3a
 *
 *                           - (2) (A) "SND.UNA should be advanced to equal SEG.ACK (if there is an ACK)" ...
 *
 *                           - (B) "and any segments on the retransmission queue which are thereby acknowledged
 *                       should be removed."
 *
 *                           - (3) (A) "If SND.UNA > ISS (our SYN has been ACKed)" :
 *
 *                           - (1) "Change the connection state to ESTABLISHED" :
 *
 *                           - (2) (a) "Form an ACK segment ... and send it."
 *
 *                           - (b) "Data or controls which were queued for transmission may be included."
 *
 *                           - (3) "If there are other controls or text in the segment then continue processing."
 *
 *                           - (4) RFC #1122, Section 4.2.2.20.(c) adds that "when the connection enters
 *                       ESTABLISHED state, the following variables must be set" :
 *
 *                           - (a) SND.WND <- SEG.WND
 *                           - (b) SND.WL1 <- SEG.SEQ
 *                           - (c) SND.WL2 <- SEG.ACK
 *
 *                           - (B) "Otherwise" :
 *
 *                           - (1) "Enter SYN-RECEIVED," ...
 *
 *                           - (2) "Form an SYN,ACK segment ... and send it."
 *
 *                           - (3) "If there are other controls or text in the segment, queue them for later
 *                       processing after the ESTABLISHED state has been reached."
 *
 *                           - (a) If any control or text is queued for later processing, the next sequence
 *                       octet to receive (RCV.NXT) MUST include the length of this received
 *                       segment (SEG.LEN) :
 *
 *                           - (1) RCV.NXT = SEG.SEQ + SEG.LEN + 1
 *
 *                           - (d) "Fifth, if neither of the SYN or RST bits is set then drop the segment."
 *
 *                           - (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
 *                       to "not process the FIN if the state is CLOSED, LISTEN or SYN-SENT since the SEG.SEQ
 *                       cannot be validated; drop the segment".
 *
 * @note     (3) RFC #1122, Section 4.2.2.6 states that :
 *
 *                           - (a) A "TCP SHOULD send an MSS (Maximum Segment Size) option in every SYN segment".
 *
 *                           - (b) "If an MSS option is not received at connection setup, TCP MUST assume a default
 *                       send MSS of 536."
 *
 * @note     (4) (a) TCP connection timeout for SYN-SENT state is implemented by TCP connection retransmission
 *                       function(s) (see 'NetTCP_TxConnReTxQ()  Note #3c').
 *
 *                           - (b) (1) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
 *                       "for any state if the user timeout expires, flush all queues, signal the user
 *                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
 *
 *                           - (2) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
 *
 *                       Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
 *                       or control segment should reset its connection timer.
 *
 *                           - (c) (1) Once a TCP connection enters the connected state, most of its TCP connection
 *                       timers should be reset.
 *
 *                           - (2) However, the following timers MAY already have been allocated & initialized,
 *                       & MUST NOT be reset :
 *
 *                           - (A)    Transmit Idle timer              'TxQ_IdleTmr'
 *                           - (B) Re-transmit      timer              'ReTxQ_Tmr'
 *
 * @note     (5) Some  transitory errors were ignored &/or not returned from previous handler function(s).
 *                       These transitory errors are included for completeness & as an extra precaution in case
 *                       these transitory errors are returned by handler function(s).
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerSyncTxd(NET_TCP_CONN *p_conn,
                                                     NET_BUF      *p_buf,
                                                     NET_BUF_HDR  *p_buf_hdr,
                                                     RTOS_ERR     *p_err)
{
  NET_TCP_SEG_SIZE   mss_dflt_tx;
  NET_TCP_SEQ_CODE   seq_code;
  NET_TCP_ACK_CODE   ack_code;
  NET_TCP_RESET_CODE reset_code;
  NET_TCP_FREE_CODE  free_code;
  NET_TCP_CONN_STATE state;
  NET_TCP_STATUS     rtn_status = NET_TCP_STATUS_INVALID;
  CPU_INT32U         timeout_ms;
  RTOS_ERR           local_err;

  //                                                               -------------- VALIDATE RX'D TCP PKT ---------------
  //                                                               Chk for rx'd fin/close.
  if (p_buf_hdr->TCP_SegClose != DEF_NO) {                      // If invalid   fin/close rx'd, ...
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagFinCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;                                                  // ... ignore TCP pkt (see Note #2e).
  }

  //                                                               Chk for rx'd ack.
  ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr);
  if (ack_code == NET_TCP_CONN_RX_ACK_INVALID) {                // If invalid ack rx'd, ...
                                                                // ... tx TCP conn reset (see Note #2a1).
    RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
    NetTCP_TxConnReset(p_conn, p_buf_hdr, NET_TCP_CONN_TX_RESET, NET_TCP_CONN_CLOSE_ALL, &local_err);
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagAckCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  //                                                               Chk for rx'd reset.
  reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr);
  switch (reset_code) {
    case NET_TCP_CONN_RX_RESET_NONE:
      break;

    case NET_TCP_CONN_RX_RESET_VALID:                           // If valid reset rx'd, close TCP conn (see Note #2b).
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      rtn_status = NET_TCP_STATUS_VALID;
      goto exit;

    case NET_TCP_CONN_RX_RESET_INVALID:
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagRstCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk rx'd seq nbr.
  seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr);
  if (seq_code != NET_TCP_CONN_RX_SEQ_SYNC) {                   // If sync NOT rx'd, ...
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxSeqInvalidCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;                                                  // ... ignore TCP pkt (see Note #2d).
  }
  //                                                               Else sync avail, update seg lens.
  p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_SYNC;
  p_buf_hdr->TCP_SegLen += NET_TCP_SEG_LEN_SYNC;

  //                                                               ----------------- UPDATE TCP CONN ------------------
  //                                                               Cfg remote max seg size ...
  //                                                               ... as advertised by remote host (see Note #3).
  if (DEF_BIT_IS_SET(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME) == DEF_YES) {
#ifdef  NET_IPv6_MODULE_EN
    mss_dflt_tx = NET_TCP_MAX_SEG_SIZE_DFLT_V6;
#else
    NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
    RTOS_DBG_FAIL_EXEC_ERR(*p_err, RTOS_ERR_NOT_AVAIL, NET_TCP_STATUS_INVALID);
#endif
  } else {
#ifdef  NET_IPv4_MODULE_EN
    mss_dflt_tx = NET_TCP_MAX_SEG_SIZE_DFLT_V4;
#else
    NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
    RTOS_DBG_FAIL_EXEC_ERR(*p_err, RTOS_ERR_NOT_AVAIL, NET_TCP_STATUS_INVALID);
#endif
  }

  p_conn->MaxSegSizeRemote = (p_buf_hdr->TCP_MaxSegSize != NET_TCP_MAX_SEG_SIZE_NONE)
                             ?  p_buf_hdr->TCP_MaxSegSize
                             :  mss_dflt_tx;

  //                                                               ----------------- HANDLE RX'D SEG ------------------
  rtn_status = NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, p_err);
  switch (RTOS_ERR_CODE_GET(*p_err)) {
    case RTOS_ERR_NONE:
      break;

    case RTOS_ERR_NET_IF_LINK_DOWN:                             // Ignore transitory tx err(s) [see Note #5].
      goto exit;

    default:
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
  }

  switch (rtn_status) {
    case NET_TCP_STATUS_NONE:
    case NET_TCP_STATUS_DATA:
      break;

    case NET_TCP_STATUS_DUP:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataDupCtr);
      goto exit;

    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  state = p_conn->ConnState;
  if (ack_code == NET_TCP_CONN_RX_ACK_VALID) {                  // If valid ack rx'd        (see Note #2a1), ...
    p_conn->ConnState = NET_TCP_CONN_STATE_CONN;                // ... chng to conn'd state (see Note #2c3A1).
    p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CONN;
  } else {                                                      // Else chng to sync rx'd state (see Note #2c3B1).
    p_conn->ConnState = NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE;
  }

  //                                                               UPDATE TMR's
  free_code = NET_TCP_CONN_FREE_TMR_ALL;                        // See Note #4c1.
                                                                // See Note #4c2A.
  DEF_BIT_CLR(free_code, (NET_TCP_FREE_CODE)NET_TCP_CONN_FREE_TMR_TX_IDLE);
  //                                                               See Note #4c2B.
  DEF_BIT_CLR(free_code, (NET_TCP_FREE_CODE)NET_TCP_CONN_FREE_TMR_RE_TX);

  NetTCP_ConnFreeTmr(p_conn, free_code);                        // Free TCP conn tmr(s) [see Note #4c].

  if (p_conn->ConnState == NET_TCP_CONN_STATE_CONN) {           // If conn'd, get TCP conn tmr.
                                                                // Start conn tmr (see Note #4b2).
    timeout_ms = p_conn->TimeoutConn_sec * DEF_TIME_NBR_mS_PER_SEC;
    p_conn->TimeoutTmr = NetTmr_Get(NetTCP_ConnIdleTimeout,
                                    p_conn,
                                    timeout_ms,
                                    NET_TMR_OPT_NONE,
                                    p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
    }
  }

  //                                                               ------------------- ACK TCP CONN -------------------
  if (p_conn->ConnState == NET_TCP_CONN_STATE_CONN) {           // If conn'd, ...
    NetTCP_RxPktConnHandlerSignalConn(p_conn, state, p_err);     // ... signal app conn           (see Note #1c1);  ...
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
    }

    NetTCP_RxPktConnHandlerRxQ_AppData(p_conn);                 // ... handle TCP conn rx'd data (see Note #2d2A1); ...

    //                                                             ... & tx ack & any tx data    (see Note #1c3).
    NetTCP_TxConnTxQ(p_conn,
                     p_buf_hdr,
                     NET_TCP_CONN_TX_ACK_IMMED,
                     DEF_NO,
                     NET_TCP_CONN_CLOSE_ALL,
                     DEF_NO,
                     p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
  } else {                                                      // Else tx TCP conn sync/ack (see Note #2c3B2).
    NetTCP_TxConnSync(p_conn, p_buf_hdr, state, p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
    }
  }

exit:
  return (rtn_status);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerConn()
 *
 * @brief    (1) Handle TCP connection in ESTABLISHED state :
 *
 *           - (a) Validate received TCP packet for current TCP connection state :
 *
 *               - (1) Sequence Number (SEQ)                                   See Note  #2a
 *               - (2) Reset           (RST)                                   See Note  #2b
 *               - (3) Synchronization (SYN)                                   See Note  #2c
 *               - (4) Acknowledgement (ACK)                                   See Note  #2d
 *               - (5) Finish/Close    (FIN)                                   See Note  #2f
 *
 *           - (b) Update TCP connection :
 *               - (1) Handle received TCP segment                             See Notes #2d & #2e
 *               - (2) Update TCP connection state                             See Note  #2f5
 *               - (3) Update TCP connection timer                             See Note  #3
 *
 *           - (c) Transmit TCP connection acknowledgement & data              See Notes #2e2A & #2f3
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) TCP connections in the ESTABLISHED state are handled as follows :
 *
 *                           - (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
 *                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
 *                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
 *
 *                           - (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
 *
 *                           - (2) "Initial tests on arrival are used to discard old duplicates."
 *
 *                           - (3) "If a segment's contents straddle the boundary between old and new, only the
 *                       new parts should be processed."
 *
 *                           - (4) (A) "If an incoming segment is not acceptable," ...
 *
 *                           - (B) "an acknowledgment should be sent in reply" ...
 *
 *                           - (C) "(unless the RST bit is set, if so drop the segment)".
 *
 *                       See also Notes #2b2Aa & #2b2B.
 *
 *                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
 *
 *                           - (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit' states
 *                       that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states that "if the
 *                       RST bit is set then, any outstanding RECEIVEs and SEND[s] should receive 'reset'
 *                       responses.  All segment queues should be flushed.  Users should also receive an
 *                       unsolicited general 'connection reset' signal[, and] enter the CLOSED state".
 *
 *                           - (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
 *                       that "if the receiver ... of a RST ... was in any other state [other than LISTEN
 *                       or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
 *                       CLOSED state".
 *
 *                           - (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
 *                       with the RST bit when in a synchronized state" to "provide some protection against
 *                       ... blind reset attack[s] using the RST bit" :
 *
 *                           - (a) "If the RST bit is set and the sequence number is outside the expected
 *                       window, silently drop the segment."
 *
 *                           - (b) "If the RST bit is exactly the next expected sequence number [sic], reset
 *                       the connection"; it is assumed that this should read "if the RST bit is
 *                       set and the sequence number is exactly the next expected sequence number,
 *                       reset the connection."
 *
 *                           - (c) "If the RST bit is set and the sequence number does not exactly match
 *                       the next expected sequence value, yet is within the acceptable window
 *                       (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
 *
 *                           - (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
 *                       priority for handling TCP segments received with BOTH the RST & SYN bits set.
 *
 *                       Therefore, since it does NOT seem reasonable to reset a TCP connection
 *                       due to a TCP segment that also attempted to synchronize the  TCP connection,
 *                       it is assumed that the amended handling of the SYN bit should take precedence
 *                       over the amended handling of the RST bit.
 *
 *                       See also Note #2c2.
 *
 *                           - (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
 *                       states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
 *                       FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that :
 *
 *                           - (A) "If the SYN is in the window it is an error, send a reset, any outstanding
 *                       RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
 *                       should be flushed, the user should also receive an unsolicited general
 *                       'connection reset' signal[, and] enter the CLOSED state."
 *
 *                           - (B) But "if the SYN is not in the window this step would not have been reached
 *                       and an ack would have been sent".
 *
 *                           - (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
 *                       of a segment with the SYN bit set in the synchronized state ... [by] handling
 *                       ... the SYN bit" as follows :
 *
 *                           - (a) "If the SYN bit is set and the sequence number is outside the
 *                       expected window, send an ACK back to the peer."
 *
 *                           - (b) "If the SYN bit is set and the sequence number is an exact
 *                       match to the next expected sequence (RCV.NXT == SEG.SEQ)
 *                       then send an ACK segment ... but ... subtract one from
 *                       value being acknowledged."
 *
 *                           - (c) "If the SYN bit is set and the sequence number is acceptable,
 *                       i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
 *                       ACK segment."
 *
 *                           - (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
 *                       states that :
 *
 *                           - (1) "If the ACK bit is off drop the segment."
 *
 *                           - (2) "If the ACK bit is on [and in the] ESTABLISHED STATE" :
 *
 *                           - (A) "If SND.UNA < SEG.ACK <= SND.NXT then" :
 *
 *                           - (1) "Set SND.UNA <- SEG.ACK."
 *
 *                           - (2) "Any segments on the retransmission queue which are thereby entirely
 *                       acknowledged are removed."
 *
 *                           - (3) "The send window should be updated" :
 *
 *                           - (a) (1) (A) "If ((SND.WL1 <  SEG.SEQ) or" ...
 *
 *                           - (B) (1) "(SND.WL1  = SEG.SEQ and" ...
 *                           - (2)  "SND.WL2 <= SEG.ACK)),"  ...
 *
 *                           - (2) (A) "Set SND.WND <- SEG.WND," ...
 *                           - (B) "Set SND.WL1 <- SEG.SEQ," ...
 *                           - (C) "Set SND.WL2 <- SEG.ACK."
 *
 *                           - (b) "Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the
 *                       sequence number of the last segment used to update SND.WND, and that
 *                       SND.WL2 records the acknowledgment number of the last segment used to
 *                       update SND.WND.  The check here prevents using old segments to update
 *                       the window."
 *
 *                           - (B) (1) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
 *
 *                           - (2) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
 *                       for the segment's acknowledgement to include SND.UNA : "The window should
 *                       updated if SND.UNA <= SEG.ACK <= SND.NXT."
 *
 *                       See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1b2'.
 *
 *                           - (C) "If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK
 *                       [and] drop the segment."
 *
 *                           - (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
 *                       states that for the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE ... it
 *                       is possible to deliver segment text to user RECEIVE buffers" :
 *
 *                           - (1) "If the segment ... carries [a] PUSH flag, then the user is informed [and] the
 *                       buffer is returned."
 *
 *                           - (2) (A) (1) "When the TCP takes responsibility for delivering the data to the user it
 *                       must also acknowledge the receipt of the data."
 *
 *                           - (2) "This acknowledgment should be piggybacked on a segment being transmitted
 *                       if possible without incurring undue delay."
 *
 *                           - (B) "Once the TCP takes responsibility for the data" :
 *
 *                           - (1) "It advances RCV.NXT over the data accepted," ...
 *
 *                           - (2) "Adjusts RCV.WND as appropriate to the current buffer availability" ...
 *
 *                           - (3) (a) "The total of RCV.NXT and RCV.WND should not be reduced."
 *
 *                           - (b) RFC #793,  Section 3.7 'Data Communication : Managing the Window' &
 *                       RFC #1122, Section 4.2.2.16 confirm that "a TCP receiver SHOULD NOT
 *                       shrink the window"; i.e. "advertise a much smaller window without
 *                       having accepted that much data".
 *
 *                           - (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
 *                       that "if the FIN bit is set" :
 *
 *                           - (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
 *                       same message," ...
 *
 *                           - (2) "Advance RCV.NXT over the FIN," ...
 *
 *                           - (3) "Send an acknowledgment for the FIN" ...
 *
 *                           - (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
 *
 *                           - (5) And the "ESTABLISHED STATE enter[s] the CLOSE-WAIT state".
 *
 * @note     (3) (a) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
 *                       "for any state if the user timeout expires, flush all queues, signal the user
 *                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
 *
 *                           - (b) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
 *
 *                       Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
 *                       or control segment should reset its connection timer.
 *
 * @note     (4) Some  transitory errors were ignored &/or not returned from previous handler function(s).
 *                       These transitory errors are included for completeness & as an extra precaution in case
 *                       these transitory errors are returned by handler function(s).
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerConn(NET_TCP_CONN *p_conn,
                                                  NET_BUF      *p_buf,
                                                  NET_BUF_HDR  *p_buf_hdr,
                                                  RTOS_ERR     *p_err)
{
  NET_TCP_SEQ_CODE   seq_code;
  NET_TCP_ACK_CODE   ack_code;
  NET_TCP_RESET_CODE reset_code;
  CPU_INT32U         timeout_ms;
  CPU_BOOLEAN        keep_alive_rx = DEF_NO;
  NET_TCP_STATUS     rtn_status = NET_TCP_STATUS_INVALID;
  RTOS_ERR           local_err;

  //                                                               -------------- VALIDATE RX'D TCP PKT ---------------
  //                                                               Chk for rx'd fin/close.
  if (p_buf_hdr->TCP_SegClose == DEF_YES) {                     // If fin/close avail, update seg lens.
    p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
    p_buf_hdr->TCP_SegLen += NET_TCP_SEG_LEN_CLOSE;
  }

  //                                                               Chk rx'd seq nbr.
  seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr);
  switch (seq_code) {
    case NET_TCP_CONN_RX_SEQ_VALID:
      break;

    case NET_TCP_CONN_RX_SEQ_KEEP_ALIVE:
      keep_alive_rx = DEF_YES;
      break;

    case NET_TCP_CONN_RX_SEQ_SYNC:                              // If invalid sync rx'd, ...
    case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
      //                                                           ... tx TCP conn ack  (see Notes #2c2 & #2b2B).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagSynCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_RX_SEQ_NONE:
    case NET_TCP_CONN_RX_SEQ_INVALID:                           // If invalid seq  rx'd (see Note #2a4A), ...
    default:
      if (p_buf_hdr->TCP_SegReset != DEF_YES) {                 // ... & reset NOT rx'd (see Note #2a4C), ...
                                                                // ... tx TCP conn ack  (see Note #2a4B).
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
        (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      }
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxSeqInvalidCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd reset.
  reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr);
  switch (reset_code) {
    case NET_TCP_CONN_RX_RESET_NONE:
      break;

    case NET_TCP_CONN_RX_RESET_VALID:                           // If   valid reset rx'd, ...
                                                                // ...  close TCP conn (see Note #2b1A).
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      rtn_status = NET_TCP_STATUS_VALID;
      goto exit;

    case NET_TCP_CONN_RX_RESET_INVALID:                         // If invalid reset rx'd, ...
    default:
      //                                                           ... tx TCP conn ack (see Note #2b2Ac).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagRstCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd ack.
  ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr);
  switch (ack_code) {
    case NET_TCP_CONN_RX_ACK_VALID:
    case NET_TCP_CONN_RX_ACK_DUP:
    case NET_TCP_CONN_RX_ACK_PREV:
      break;

    case NET_TCP_CONN_RX_ACK_NONE:                              // If NO      ack rx'd, ...
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckNoneCtr);            // ... ignore TCP pkt  (see Note #2d1).
      goto exit;

    case NET_TCP_CONN_RX_ACK_OTW:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckInvalidCtr);
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_OTW, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_RX_ACK_INVALID:                           // If invalid ack rx'd, ...
    default:
      //                                                           ... tx TCP conn ack (see Note #2d2C).
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckInvalidCtr);
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  if (keep_alive_rx == DEF_NO) {
    //                                                             ----------------- HANDLE RX'D SEG ------------------
    rtn_status = NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, p_err);
    switch (RTOS_ERR_CODE_GET(*p_err)) {
      case RTOS_ERR_NONE:
        break;

      case RTOS_ERR_NET_IF_LINK_DOWN:                           // Ignore transitory tx err(s) [see Note #4].
        goto exit;

      default:
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
        goto exit;
    }

    switch (rtn_status) {
      case NET_TCP_STATUS_NONE:
      case NET_TCP_STATUS_DATA:
        break;

      case NET_TCP_STATUS_DUP:
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataDupCtr);
        goto exit;

      default:
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
        RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
        goto exit;
    }
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  if (p_buf_hdr->TCP_SegClose == DEF_YES) {                     // If fin/close rx'd, ...
    p_conn->ConnState = NET_TCP_CONN_STATE_CLOSE_WAIT;          // ... chng to close-wait state (see Note #2f5).
  }

  //                                                               -------------------- UPDATE TMR --------------------
  //                                                               Reset conn idle tmr (see Note #3b).
  timeout_ms = p_conn->TimeoutConn_sec * DEF_TIME_NBR_mS_PER_SEC;
  if (p_conn->TimeoutTmr != DEF_NULL) {
    NetTmr_Set(p_conn->TimeoutTmr,
               NetTCP_ConnIdleTimeout,
               timeout_ms);
  } else {
    p_conn->TimeoutTmr = NetTmr_Get(NetTCP_ConnIdleTimeout,
                                    p_conn,
                                    timeout_ms,
                                    NET_TMR_OPT_NONE,
                                    p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
    }
  }

  //                                                               --------------- TX TCP CONN ACK/DATA ---------------
  ack_code = ((p_buf_hdr->TCP_SegAckTxReqCode == NET_TCP_CONN_TX_ACK_IMMED)
              || (p_buf_hdr->TCP_SegClose == DEF_YES))          // See Note #2f3.
             ?   NET_TCP_CONN_TX_ACK_IMMED
             :   NET_TCP_CONN_TX_ACK;
  //                                                               Tx ack & any tx data (see Note #1c).
  NetTCP_TxConnTxQ(p_conn,
                   p_buf_hdr,
                   ack_code,
                   DEF_NO,
                   NET_TCP_CONN_CLOSE_ALL,
                   DEF_NO,
                   p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit;
  }

exit:
  return (rtn_status);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerFinWait1()
 *
 * @brief    (1) Handle TCP connection in FIN-WAIT-1 state :
 *
 *           - (a) Validate received TCP packet for current TCP connection state :
 *
 *               - (1) Sequence Number (SEQ)                                   See Note  #2a
 *               - (2) Reset           (RST)                                   See Note  #2b
 *               - (3) Synchronization (SYN)                                   See Note  #2c
 *               - (4) Acknowledgement (ACK)                                   See Note  #2d
 *               - (5) Finish/Close    (FIN)                                   See Note  #2f
 *
 *           - (b) Update TCP connection :
 *               - (1) Handle received TCP segment                             See Notes #2d   & #2e
 *               - (2) Signal TCP/application connection close                 See Note  #2d2B2
 *               - (3) Update TCP connection state :                           See Notes #2f5A1, #2f5A2b1, & #2f5B
 *                   - (A) Configure TCP connection timeout value
 *                   - (B) Configure TCP connection timeout function
 *               - (4) Update TCP connection timer(s)                          See Notes #2f5A1, #2f5A2b2, & #3
 *
 *           - (c) Transmit TCP connection acknowledgement & data              See Notes #2e2A & #2f3
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) TCP connections in the FIN-WAIT-1 state are handled as follows :
 *
 *                           - (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
 *                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
 *                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
 *
 *                           - (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
 *
 *                           - (2) "Initial tests on arrival are used to discard old duplicates."
 *
 *                           - (3) "If a segment's contents straddle the boundary between old and new, only the
 *                       new parts should be processed."
 *
 *                           - (4) (A) "If an incoming segment is not acceptable," ...
 *
 *                           - (B) "an acknowledgment should be sent in reply" ...
 *
 *                           - (C) "(unless the RST bit is set, if so drop the segment)".
 *
 *                       See also Notes #2b2Aa & #2b2B.
 *
 *                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
 *
 *                           - (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit' states
 *                       that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states that "if the
 *                       RST bit is set then, any outstanding RECEIVEs and SEND[s] should receive 'reset'
 *                       responses.  All segment queues should be flushed.  Users should also receive an
 *                       unsolicited general 'connection reset' signal[, and] enter the CLOSED state".
 *
 *                           - (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
 *                       that "if the receiver ... of a RST ... was in any other state [other than LISTEN
 *                       or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
 *                       CLOSED state".
 *
 *                           - (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
 *                       with the RST bit when in a synchronized state" to "provide some protection against
 *                       ... blind reset attack[s] using the RST bit" :
 *
 *                           - (a) "If the RST bit is set and the sequence number is outside the expected
 *                       window, silently drop the segment."
 *
 *                           - (b) "If the RST bit is exactly the next expected sequence number [sic], reset
 *                       the connection"; it is assumed that this should read "if the RST bit is
 *                       set and the sequence number is exactly the next expected sequence number,
 *                       reset the connection."
 *
 *                           - (c) "If the RST bit is set and the sequence number does not exactly match
 *                       the next expected sequence value, yet is within the acceptable window
 *                       (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
 *
 *                           - (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
 *                       priority for handling TCP segments received with BOTH the RST & SYN bits set.
 *
 *                       Therefore, since it does NOT seem reasonable to reset a TCP connection
 *                       due to a TCP segment that also attempted to synchronize the  TCP connection,
 *                       it is assumed that the amended handling of the SYN bit should take precedence
 *                       over the amended handling of the RST bit.
 *
 *                       See also Note #2c2.
 *
 *                           - (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
 *                       states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
 *                       FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that :
 *
 *                           - (A) "If the SYN is in the window it is an error, send a reset, any outstanding
 *                       RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
 *                       should be flushed, the user should also receive an unsolicited general
 *                       'connection reset' signal[, and] enter the CLOSED state."
 *
 *                           - (B) But "if the SYN is not in the window this step would not have been reached
 *                       and an ack would have been sent".
 *
 *                           - (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
 *                       of a segment with the SYN bit set in the synchronized state ... [by] handling
 *                       ... the SYN bit" as follows :
 *
 *                           - (a) "If the SYN bit is set and the sequence number is outside the
 *                       expected window, send an ACK back to the peer."
 *
 *                           - (b) "If the SYN bit is set and the sequence number is an exact
 *                       match to the next expected sequence (RCV.NXT == SEG.SEQ)
 *                       then send an ACK segment ... but ... subtract one from
 *                       value being acknowledged."
 *
 *                           - (c) "If the SYN bit is set and the sequence number is acceptable,
 *                       i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
 *                       ACK segment."
 *
 *                           - (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
 *                       states that :
 *
 *                           - (1) "If the ACK bit is off drop the segment."
 *
 *                           - (2) "If the ACK bit is on" :
 *
 *                           - (A) And in the "ESTABLISHED STATE" :
 *
 *                           - (1) "If SND.UNA < SEG.ACK <= SND.NXT then" :
 *
 *                           - (a) "Set SND.UNA <- SEG.ACK."
 *
 *                           - (b) "Any segments on the retransmission queue which are thereby entirely
 *                       acknowledged are removed."
 *
 *                           - (c) "The send window should be updated" :
 *
 *                           - (1) (A) (1) "If ((SND.WL1 <  SEG.SEQ) or" ...
 *
 *                           - (2) (a) "(SND.WL1  = SEG.SEQ and" ...
 *                           - (b)  "SND.WL2 <= SEG.ACK)),"  ...
 *
 *                           - (B) (1) "Set SND.WND <- SEG.WND," ...
 *                           - (2) "Set SND.WL1 <- SEG.SEQ," ...
 *                           - (3) "Set SND.WL2 <- SEG.ACK."
 *
 *                           - (2) "Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the
 *                       sequence number of the last segment used to update SND.WND, and that
 *                       SND.WL2 records the acknowledgment number of the last segment used to
 *                       update SND.WND.  The check here prevents using old segments to update
 *                       the window."
 *
 *                           - (2) (a) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
 *
 *                           - (b) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
 *                       for the segment's acknowledgement to include SND.UNA : "The window should
 *                       updated if SND.UNA <= SEG.ACK <= SND.NXT."
 *
 *                       See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1b2'.
 *
 *                           - (3) "If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK
 *                       [and] drop the segment."
 *
 *                           - (B) (1) For the "FIN-WAIT-1 STATE" :
 *
 *                           - (a) "In addition to the processing for the ESTABLISHED state" ...
 *                           - (b) "If our FIN is now acknowledged then"                     ...
 *                           - (1) "Enter FIN-WAIT-2 [state] and continue processing in that state."
 *
 *                           - (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                       FIN-WAIT-2 STATE' states that "if the retransmission queue is empty, the user's
 *                       CLOSE can be acknowledged".
 *
 *                           - (b) However, a TCP connection transitions into the FIN-WAIT-2 state if & only if
 *                       the TCP connection's close request was previously acknowledged while in the
 *                       FIN-WAIT-1 state.  Thus the TCP connection's re-transmit queue should
 *                       already be empty prior to entering the FIN-WAIT-2 state.
 *
 *                       Therefore, a TCP connection in the FIN-WAIT-1 state should :
 *
 *                           - (1) Signal the application layer that "the user's close [is] acknowledged"
 *                       whenever its re-transmit queue becomes empty.
 *
 *                           - (2) Close all unused timers (see also Note #2f5A1b).
 *
 *                           - (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
 *                       states that for the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE ... it
 *                       is possible to deliver segment text to user RECEIVE buffers" :
 *
 *                           - (1) "If the segment ... carries [a] PUSH flag, then the user is informed [and] the
 *                       buffer is returned."
 *
 *                           - (2) (A) (1) "When the TCP takes responsibility for delivering the data to the user it
 *                       must also acknowledge the receipt of the data."
 *
 *                           - (2) "This acknowledgment should be piggybacked on a segment being transmitted
 *                       if possible without incurring undue delay."
 *
 *                           - (B) "Once the TCP takes responsibility for the data" :
 *
 *                           - (1) "It advances RCV.NXT over the data accepted," ...
 *
 *                           - (2) "Adjusts RCV.WND as appropriate to the current buffer availability" ...
 *
 *                           - (3) (a) "The total of RCV.NXT and RCV.WND should not be reduced."
 *
 *                           - (b) RFC #793,  Section 3.7 'Data Communication : Managing the Window' &
 *                       RFC #1122, Section 4.2.2.16 confirm that "a TCP receiver SHOULD NOT
 *                       shrink the window"; i.e. "advertise a much smaller window without
 *                       having accepted that much data".
 *
 *                           - (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
 *                       that "if the FIN bit is set" :
 *
 *                           - (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
 *                       same message," ...
 *
 *                           - (2) "Advance RCV.NXT over the FIN," ...
 *
 *                           - (3) "Send an acknowledgment for the FIN" ...
 *
 *                           - (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
 *
 *                           - (5) For the "FIN-WAIT-1 STATE" :
 *
 *                           - (A) "If our FIN has been ACKed (perhaps in this segment), then" :
 *
 *                           - (1) "Enter TIME-WAIT [state]" ...
 *                           - (a) "Start the time-wait timer,  ...
 *                           - (1) A TCP connection should be closed WITHOUT fault following a TCP
 *                       connection TIME-WAIT timeout.
 *
 *                           - (b) "Turn off the other timers;" ...
 *
 *                           - (2) However, it is possible that some closing received data from the remote
 *                       host is available but has NOT yet been received by the application layer.
 *
 *                           - (a) Therefore, if the application receive queue is closed, then enter the
 *                       TIME-WAIT state.
 *
 *                           - (b) (1) But if the application receive queue is NOT closed, then enter the
 *                       connection-closing-data-available state to allow the application
 *                       layer to receive the remaining receive data.
 *
 *                           - (2) (A) To satisfy the required time-wait timeout of two maximum segment
 *                       lifetimes (see Note #2f5A1a), the time-wait timeout is initially
 *                       used to provide the application layer sufficient time to receive
 *                       the closing received data.
 *
 *                           - (B) If after the time-wait timeout expires, the application receive
 *                       queue is still not empty, the user connection timeout is used
 *                       to provide the application layer additional time to receive the
 *                       closing received data.
 *
 *                       See also Note #3a.
 *
 *                           - (B) "Otherwise, enter the CLOSING state."
 *
 * @note     (3) (a) (1) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
 *                       "for any state if the user timeout expires, flush all queues, signal the user
 *                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
 *
 *                           - (2) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
 *
 *                       Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
 *                       or control segment should reset its connection timer.
 *
 *                           - (b) (1) (A) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.6 'FIN_WAIT_2
 *                       State', Page 246 states that "in the FIN_WAIT_2 state we have sent our FIN and
 *                       the other end has acknowledged it ... [and] we are waiting for the application
 *                       on the other end to recognize that it has received an end-of-file notification
 *                       and close its end of the connection, which sends us a FIN.  Only when the
 *                       process at the other end does this will our end move from the FIN_WAIT_2 to
 *                       the TIME_WAIT state.  This means our end of the connection can remain in this
 *                       state forever.  The other end is still in the CLOSE_WAIT state, and can remain
 *                       there forever, until the application decides to issue its close".
 *
 *                           - (B) "Many Berkeley-derived implementations prevent this infinite wait in the
 *                       FIN_WAIT_2 state" by :
 *
 *                           - (1) "Mov[ing] the connection into the CLOSED state" ...
 *                           - (2) "if the connection is idle for 10 minutes plus 75 seconds."
 *
 *                           - (2) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.1 'A FIN_WAIT_2
 *                       timer', Page 818 states that "to avoid leaving a connection in the FIN_WAIT_2 state
 *                       forever, if the other end never sends a FIN" :
 *
 *                           - (A) (1) "When a connection moves from the FIN_WAIT_1 state to the FIN_WAIT_2 state" ...
 *                           - (2) "and the connection cannot receive any more data [implying the process called
 *                       close(), instead of ... half-close ... shutdown()]," ...
 *
 *                           - (B) (1)  The TCP connection's "timer is set to 10 minutes ... [and] 75 seconds," ...
 *                           - (2) "and when it expires ... the connection is dropped".
 *
 *                           - (3) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6 'FIN_WAIT_2
 *                       and 2MSL Timers : FIN_WAIT_2 timer', Pages 825-827 adds that "terminating an idle
 *                       connection after more than 10 minutes in the FIN_WAIT_2 state violates the protocol
 *                       specification, but this is practical ... [since] all outstanding data on the connection
 *                       has been sent and acknowledged, the other end has acknowledged the FIN, and TCP is
 *                       waiting for the process at the other end of the connection to issue its close().  If
 *                       the other process never closes its end of the connection, our end can remain in the
 *                       FIN_WAIT_2 [state] forever".
 *
 * @note     (4) Since the mechanisms of TCP connection close are independent of the application layer
 *                       close; any external application layer close error(s) are ignored.
 *
 * @note     (5) Some  transitory errors were ignored &/or not returned from previous handler function(s).
 *                       These transitory errors are included for completeness & as an extra precaution in case
 *                       these transitory errors are returned by handler function(s).
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerFinWait1(NET_TCP_CONN *p_conn,
                                                      NET_BUF      *p_buf,
                                                      NET_BUF_HDR  *p_buf_hdr,
                                                      RTOS_ERR     *p_err)
{
  NET_TCP_SEQ_CODE   seq_code;
  NET_TCP_ACK_CODE   ack_code;
  NET_TCP_RESET_CODE reset_code;
  CPU_BOOLEAN        data_avail;
  CPU_INT32U         timeout_ms;
  CPU_FNCT_PTR       timeout_fnct;
  NET_TCP_FREE_CODE  free_code;
  NET_TCP_STATUS     rtn_status = NET_TCP_STATUS_INVALID;
  RTOS_ERR           local_err;

  //                                                               -------------- VALIDATE RX'D TCP PKT ---------------
  //                                                               Chk for rx'd fin/close.
  if (p_buf_hdr->TCP_SegClose == DEF_YES) {                     // If fin/close avail, update seg lens.
    p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
    p_buf_hdr->TCP_SegLen += NET_TCP_SEG_LEN_CLOSE;
  }

  //                                                               Chk rx'd seq nbr.
  seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr);
  switch (seq_code) {
    case NET_TCP_CONN_RX_SEQ_VALID:
      break;

    case NET_TCP_CONN_RX_SEQ_SYNC:                              // If invalid sync rx'd, ...
    case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagSynCtr);
      //                                                           ... tx TCP conn ack  (see Notes #2c2 & #2b2B).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_RX_SEQ_NONE:
    case NET_TCP_CONN_RX_SEQ_INVALID:                           // If invalid seq  rx'd (see Note #2a4A), ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxSeqInvalidCtr);
      if (p_buf_hdr->TCP_SegReset != DEF_YES) {                 // ... & reset NOT rx'd (see Note #2a4C), ...
                                                                // ... tx TCP conn ack  (see Note #2a4B).
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
        (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      }
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd reset.
  reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr);
  switch (reset_code) {
    case NET_TCP_CONN_RX_RESET_NONE:
      break;

    case NET_TCP_CONN_RX_RESET_VALID:                           // If   valid reset rx'd, ...
                                                                // ...  close TCP conn (see Note #2b1A).
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      rtn_status = NET_TCP_STATUS_VALID;
      goto exit;

    case NET_TCP_CONN_RX_RESET_INVALID:                         // If invalid reset rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagRstCtr);
      //                                                           ... tx TCP conn ack (see Note #2b2Ac).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd ack.
  ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr);
  switch (ack_code) {
    case NET_TCP_CONN_RX_ACK_VALID:
    case NET_TCP_CONN_RX_ACK_DUP:
    case NET_TCP_CONN_RX_ACK_PREV:
      break;

    case NET_TCP_CONN_RX_ACK_NONE:                              // If NO      ack rx'd, ...
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckNoneCtr);            // ... ignore TCP pkt  (see Note #2d1).
      goto exit;

    case NET_TCP_CONN_RX_ACK_INVALID:                           // If invalid ack rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckInvalidCtr);
      //                                                           ... tx TCP conn ack (see Note #2d2A3).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- HANDLE RX'D SEG ------------------
  rtn_status = NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, p_err);
  switch (RTOS_ERR_CODE_GET(*p_err)) {
    case RTOS_ERR_NONE:
      break;

    case RTOS_ERR_NET_IF_LINK_DOWN:                             // Ignore transitory tx err(s) [see Note #4].
      goto exit;

    default:
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
  }

  switch (rtn_status) {
    case NET_TCP_STATUS_NONE:
    case NET_TCP_STATUS_DATA:
      break;

    case NET_TCP_STATUS_DUP:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataDupCtr);
      goto exit;

    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  timeout_fnct = DEF_NULL;
  //                                                               If local conn close ack'd (see Note #2f5A);      ...
  if ((p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED)
      || (p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED_SUSPEND)) {
    //                                                             Closing data avail for half-closed conns ONLY.
    data_avail = ((p_conn->ConnCloseCode != NET_CONN_CLOSE_HALF)
                  || ((p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSED)
                      && (p_conn->RxQ_App_Head == DEF_NULL))) ? DEF_NO : DEF_YES;

    //                                                             ... signal app conn close (see Note #2d2B2b1);   ...
    NetTCP_RxPktConnHandlerSignalClose(p_conn, data_avail, p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
    }

    if (p_buf_hdr->TCP_SegClose == DEF_YES) {                   // ... & if fin/close rx'd                          ...
      if (data_avail != DEF_YES) {                              // ... & NO app data avail,                         ...
                                                                // ... chng to time-wait state (see Note  #2f5A2a); ...
        p_conn->ConnState = NET_TCP_CONN_STATE_TIME_WAIT;
        p_conn->ConnCloseTimeoutFaultFlag = DEF_NO;             // ... clr close timeout fault (see Note  #2f5A1a1);...
        timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;
      } else {                                                  // ... else chng to conn-closing-data-avail state   ...
                                                                // ...                         (see Note  #2f5A2b1);...
        p_conn->ConnState = NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL;
        timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnClosingTimeoutDataAvail;
      }
      //                                                           ... & start time-wait tmr   (see Notes #2f5A1a & ...
      //                                                           ...                                    #2f5A2b2A).
      timeout_ms = p_conn->TimeoutMaxSeg_sec * DEF_TIME_NBR_mS_PER_SEC * NET_TCP_CONN_TIMEOUT_MAX_SEG_SCALAR;
    } else {
      p_conn->ConnState = NET_TCP_CONN_STATE_FIN_WAIT_2;        // ... else chng to fin-wait-2 state (see Note #2d2B1b1)
                                                                // ... & start      fin-wait-2 tmr   (see Note #3b).
      timeout_ms = NET_TCP_DFLT_TIMEOUT_CONN_FIN_WAIT_2_SEC * DEF_TIME_NBR_mS_PER_SEC;
      timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;
    }
  } else {
    if (p_buf_hdr->TCP_SegClose == DEF_YES) {                   // Else if fin/close rx'd,                     ...
      p_conn->ConnState = NET_TCP_CONN_STATE_CLOSING;           // ... chng to closing state  (see Note #2f5B) ...
      timeout_ms = p_conn->TimeoutConn_sec;                     // ... & start conn close tmr (see Note #3a2).
      timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;
    }
  }

  //                                                               UPDATE TMR's
  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_TIME_WAIT:                          // If in time-wait            (see Note #2f5A1)    ...
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:                 // ... or closing state(s)    [see Note #2d2B2b2], ...
      free_code = NET_TCP_CONN_FREE_TMR_ALL;                    // ... free all TCP conn tmrs (see Note #2f5A1b).
      DEF_BIT_CLR(free_code, (NET_TCP_FREE_CODE)NET_TCP_CONN_FREE_TMR_TIMEOUT);
      NetTCP_ConnFreeTmr(p_conn, free_code);
      break;

    default:                                                    // 'default' case intentionally empty.
      break;
  }

  if (timeout_fnct != DEF_NULL) {
    if (p_conn->TimeoutTmr != DEF_NULL) {
      NetTmr_Set(p_conn->TimeoutTmr,
                 timeout_fnct,
                 timeout_ms);
    } else {
      p_conn->TimeoutTmr = NetTmr_Get(timeout_fnct,
                                      p_conn,
                                      timeout_ms,
                                      NET_TMR_OPT_NONE,
                                      p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
        RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
        goto exit;
      }
    }
  }

  //                                                               --------------- TX TCP CONN ACK/DATA ---------------
  ack_code = ((p_buf_hdr->TCP_SegAckTxReqCode == NET_TCP_CONN_TX_ACK_IMMED)
              || (p_buf_hdr->TCP_SegClose == DEF_YES))          // See Note #2f3.
             ?   NET_TCP_CONN_TX_ACK_IMMED
             :   NET_TCP_CONN_TX_ACK;

  if ((p_conn->ConnState == NET_TCP_CONN_STATE_FIN_WAIT_1)      // If TCP conn tx Q NOT closed, ...
      || (p_conn->ConnState == NET_TCP_CONN_STATE_CLOSING)) {   // ... tx ack & any tx data (see Note #1c).
    NetTCP_TxConnTxQ(p_conn,
                     p_buf_hdr,
                     ack_code,
                     DEF_NO,
                     NET_TCP_CONN_CLOSE_ALL,
                     DEF_NO,
                     p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
  } else {                                                      // Else tx TCP conn ack (see Note #2f3).
    (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, ack_code, NET_TCP_CONN_CLOSE_ALL, p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
  }

exit:
  return (rtn_status);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerFinWait2()
 *
 * @brief    (1) Handle TCP connection in FIN-WAIT-2 state :
 *
 *           - (a) Validate received TCP packet for current TCP connection state :
 *
 *               - (1) Sequence Number (SEQ)                                   See Note  #2a
 *               - (2) Reset           (RST)                                   See Note  #2b
 *               - (3) Synchronization (SYN)                                   See Note  #2c
 *               - (4) Acknowledgement (ACK)                                   See Note  #2d
 *               - (5) Finish/Close    (FIN)                                   See Note  #2f
 *
 *           - (b) Update TCP connection :
 *               - (1) Handle received TCP segment                             See Notes #2d   & #2e
 *               - (2) Update TCP connection state :                           See Notes #2f5A & #2f5B2a
 *                   - (A) Configure TCP connection timeout value
 *                   - (B) Configure TCP connection timeout function
 *               - (3) Update TCP connection timer(s)                          See Notes #2f5A,  #2f5B2b, & #3
 *
 *           - (c) Transmit TCP connection acknowledgement                     See Notes #2e2A & #2f3
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) TCP connections in the FIN-WAIT-2 state are handled as follows :
 *
 *                           - (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
 *                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
 *                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
 *
 *                           - (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
 *
 *                           - (2) "Initial tests on arrival are used to discard old duplicates."
 *
 *                           - (3) "If a segment's contents straddle the boundary between old and new, only the
 *                       new parts should be processed."
 *
 *                           - (4) (A) "If an incoming segment is not acceptable," ...
 *
 *                           - (B) "an acknowledgment should be sent in reply" ...
 *
 *                           - (C) "(unless the RST bit is set, if so drop the segment)".
 *
 *                       See also Notes #2b2Aa & #2b2B.
 *
 *                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
 *
 *                           - (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit' states
 *                       that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states that "if the
 *                       RST bit is set then, any outstanding RECEIVEs and SEND[s] should receive 'reset'
 *                       responses.  All segment queues should be flushed.  Users should also receive an
 *                       unsolicited general 'connection reset' signal[, and] enter the CLOSED state".
 *
 *                           - (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
 *                       that "if the receiver ... of a RST ... was in any other state [other than LISTEN
 *                       or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
 *                       CLOSED state".
 *
 *                           - (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
 *                       with the RST bit when in a synchronized state" to "provide some protection against
 *                       ... blind reset attack[s] using the RST bit" :
 *
 *                           - (a) "If the RST bit is set and the sequence number is outside the expected
 *                       window, silently drop the segment."
 *
 *                           - (b) "If the RST bit is exactly the next expected sequence number [sic], reset
 *                       the connection"; it is assumed that this should read "if the RST bit is
 *                       set and the sequence number is exactly the next expected sequence number,
 *                       reset the connection."
 *
 *                           - (c) "If the RST bit is set and the sequence number does not exactly match
 *                       the next expected sequence value, yet is within the acceptable window
 *                       (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
 *
 *                           - (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
 *                       priority for handling TCP segments received with BOTH the RST & SYN bits set.
 *
 *                       Therefore, since it does NOT seem reasonable to reset a TCP connection
 *                       due to a TCP segment that also attempted to synchronize the  TCP connection,
 *                       it is assumed that the amended handling of the SYN bit should take precedence
 *                       over the amended handling of the RST bit.
 *
 *                       See also Note #2c2.
 *
 *                           - (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
 *                       states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
 *                       FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that :
 *
 *                           - (A) "If the SYN is in the window it is an error, send a reset, any outstanding
 *                       RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
 *                       should be flushed, the user should also receive an unsolicited general
 *                       'connection reset' signal[, and] enter the CLOSED state."
 *
 *                           - (B) But "if the SYN is not in the window this step would not have been reached
 *                       and an ack would have been sent".
 *
 *                           - (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
 *                       of a segment with the SYN bit set in the synchronized state ... [by] handling
 *                       ... the SYN bit" as follows :
 *
 *                           - (a) "If the SYN bit is set and the sequence number is outside the
 *                       expected window, send an ACK back to the peer."
 *
 *                           - (b) "If the SYN bit is set and the sequence number is an exact
 *                       match to the next expected sequence (RCV.NXT == SEG.SEQ)
 *                       then send an ACK segment ... but ... subtract one from
 *                       value being acknowledged."
 *
 *                           - (c) "If the SYN bit is set and the sequence number is acceptable,
 *                       i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
 *                       ACK segment."
 *
 *                           - (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
 *                       states that :
 *
 *                           - (1) "If the ACK bit is off drop the segment."
 *
 *                           - (2) "If the ACK bit is on" :
 *
 *                           - (A) And in the "ESTABLISHED STATE" :
 *
 *                           - (1) "If SND.UNA < SEG.ACK <= SND.NXT then" :
 *
 *                           - (a) "Set SND.UNA <- SEG.ACK."
 *
 *                           - (b) "Any segments on the retransmission queue which are thereby entirely
 *                       acknowledged are removed."
 *
 *                           - (c) "The send window should be updated" :
 *
 *                           - (1) (A) (1) "If ((SND.WL1 <  SEG.SEQ) or" ...
 *
 *                           - (2) (a) "(SND.WL1  = SEG.SEQ and" ...
 *                           - (b)  "SND.WL2 <= SEG.ACK)),"  ...
 *
 *                           - (B) (1) "Set SND.WND <- SEG.WND," ...
 *                           - (2) "Set SND.WL1 <- SEG.SEQ," ...
 *                           - (3) "Set SND.WL2 <- SEG.ACK."
 *
 *                           - (2) "Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the
 *                       sequence number of the last segment used to update SND.WND, and that
 *                       SND.WL2 records the acknowledgment number of the last segment used to
 *                       update SND.WND.  The check here prevents using old segments to update
 *                       the window."
 *
 *                           - (2) (a) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
 *
 *                           - (b) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
 *                       for the segment's acknowledgement to include SND.UNA : "The window should
 *                       updated if SND.UNA <= SEG.ACK <= SND.NXT."
 *
 *                       See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1b2'.
 *
 *                           - (3) "If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK
 *                       [and] drop the segment."
 *
 *                           - (B) For the "FIN-WAIT-2 STATE" :
 *
 *                           - (1) "In addition to the processing for the ESTABLISHED state" ...
 *                           - (2) "If the retransmission queue is empty,"                   ...
 *
 *                           - (a) (1) "The user's CLOSE can be acknowledged."
 *                           - (2) However, a TCP connection transitions into the FIN-WAIT-2 state if &
 *                       only if the TCP connection's close request was previously acknowledged
 *                       while in the FIN-WAIT-1 state.  Thus the TCP connection's re-transmit
 *                       queue should already be empty prior to entering the FIN-WAIT-2 state.
 *
 *                       See also 'NetTCP_RxPktConnHandlerFinWait1()  Note #2d2B2'.
 *
 *                           - (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
 *                       states that for the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE ... it
 *                       is possible to deliver segment text to user RECEIVE buffers" :
 *
 *                           - (1) "If the segment ... carries [a] PUSH flag, then the user is informed [and] the
 *                       buffer is returned."
 *
 *                           - (2) (A) "When the TCP takes responsibility for delivering the data to the user it
 *                       must also acknowledge the receipt of the data."
 *
 *                           - (B) "Once the TCP takes responsibility for the data" :
 *
 *                           - (1) "It advances RCV.NXT over the data accepted," ...
 *
 *                           - (2) "Adjusts RCV.WND as appropriate to the current buffer availability" ...
 *
 *                           - (3) (a) "The total of RCV.NXT and RCV.WND should not be reduced."
 *
 *                           - (b) RFC #793,  Section 3.7 'Data Communication : Managing the Window' &
 *                       RFC #1122, Section 4.2.2.16 confirm that "a TCP receiver SHOULD NOT
 *                       shrink the window"; i.e. "advertise a much smaller window without
 *                       having accepted that much data".
 *
 *                           - (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
 *                       that "if the FIN bit is set" :
 *
 *                           - (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
 *                       same message," ...
 *
 *                           - (2) "Advance RCV.NXT over the FIN," ...
 *
 *                           - (3) "Send an acknowledgment for the FIN" ...
 *
 *                           - (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
 *
 *                           - (5) For the "FIN-WAIT-2 STATE" :
 *
 *                           - (A) "Enter the TIME-WAIT state"      ...
 *                           - (1) "Start the time-wait timer," ...
 *                           - (a) A TCP connection should be closed WITHOUT fault following a TCP
 *                       connection TIME-WAIT timeout.
 *
 *                           - (2) "Turn off the other timers."
 *
 *                           - (B) However, it is possible that some closing received data from the remote
 *                       host is available but has NOT yet been received by the application layer.
 *
 *                           - (1) Therefore, if the application receive queue is closed, then enter the
 *                       TIME-WAIT state.
 *
 *                           - (2) (a) But if the application receive queue is NOT closed, then enter the
 *                       connection-closing-data-available state to allow the application
 *                       layer to receive the remaining receive data.
 *
 *                           - (b) (1) To satisfy the required time-wait timeout of two maximum segment
 *                       lifetimes (see Note #2f5A1a), the time-wait timeout is initially
 *                       used to provide the application layer sufficient time to receive
 *                       the closing received data.
 *
 *                           - (2) If after the time-wait timeout expires, the application receive
 *                       queue is still not empty, the user connection timeout is used
 *                       to provide the application layer additional time to receive the
 *                       closing received data.
 *
 *                       See also Note #3a.
 *
 * @note     (3) (a) (1) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
 *                       "for any state if the user timeout expires, flush all queues, signal the user
 *                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
 *
 *                           - (2) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
 *
 *                       Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
 *                       or control segment should reset its connection timer.
 *
 *                           - (b) (1) (A) (1) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.6 'FIN_WAIT_2
 *                       State', Page 246 states that "in the FIN_WAIT_2 state we have sent our FIN and
 *                       the other end has acknowledged it ... [and] we are waiting for the application
 *                       on the other end to recognize that it has received an end-of-file notification
 *                       and close its end of the connection, which sends us a FIN.  Only when the
 *                       process at the other end does this will our end move from the FIN_WAIT_2 to
 *                       the TIME_WAIT state.  This means our end of the connection can remain in this
 *                       state forever.  The other end is still in the CLOSE_WAIT state, and can remain
 *                       there forever, until the application decides to issue its close".
 *
 *                           - (2) "Many Berkeley-derived implementations prevent this infinite wait in the
 *                       FIN_WAIT_2 state" by :
 *
 *                           - (a) "Mov[ing] the connection into the CLOSED state" ...
 *                           - (b) "if the connection is idle for 10 minutes plus 75 seconds."
 *
 *                           - (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.1 'A FIN_WAIT_2
 *                       timer', Page 818 states that "to avoid leaving a connection in the FIN_WAIT_2 state
 *                       forever, if the other end never sends a FIN" :
 *
 *                           - (1) (a) "When a connection moves from the FIN_WAIT_1 state to the FIN_WAIT_2 state" ...
 *                           - (b) "and the connection cannot receive any more data [implying the process called
 *                       close(), instead of ... half-close ... shutdown()]," ...
 *
 *                           - (2) (a)  The TCP connection's "timer is set to 10 minutes ... [and] 75 seconds," ...
 *                           - (b) "and when it expires ... the connection is dropped".
 *
 *                           - (C) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6 'FIN_WAIT_2
 *                       and 2MSL Timers : FIN_WAIT_2 timer', Pages 825-827 adds that "terminating an idle
 *                       connection after more than 10 minutes in the FIN_WAIT_2 state violates the protocol
 *                       specification, but this is practical ... [since] all outstanding data on the connection
 *                       has been sent and acknowledged, the other end has acknowledged the FIN, and TCP is
 *                       waiting for the process at the other end of the connection to issue its close().  If
 *                       the other process never closes its end of the connection, our end can remain in the
 *                       FIN_WAIT_2 [state] forever".
 *
 *                           - (2) However, NO RFC or reference specifies or suggests any mechanism to handle/reset any
 *                       FIN-WAIT-2 timeouts.
 *
 *                       Therefore, it is assumed that ANY TCP connection in  the FIN-WAIT-2 state that
 *                       receives a valid TCP data or control segment should reset its FIN-WAIT-2 timer.
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerFinWait2(NET_TCP_CONN *p_conn,
                                                      NET_BUF      *p_buf,
                                                      NET_BUF_HDR  *p_buf_hdr,
                                                      RTOS_ERR     *p_err)
{
  NET_TCP_SEQ_CODE   seq_code;
  NET_TCP_ACK_CODE   ack_code;
  NET_TCP_RESET_CODE reset_code;
  CPU_BOOLEAN        data_avail;
  CPU_INT32U         timeout_ms;
  CPU_FNCT_PTR       timeout_fnct;
  NET_TCP_FREE_CODE  free_code;
  NET_TCP_STATUS     rtn_status = NET_TCP_STATUS_INVALID;
  RTOS_ERR           local_err;

  //                                                               -------------- VALIDATE RX'D TCP PKT ---------------
  //                                                               Chk for rx'd fin/close.
  if (p_buf_hdr->TCP_SegClose == DEF_YES) {                     // If fin/close avail, update seg lens.
    p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
    p_buf_hdr->TCP_SegLen += NET_TCP_SEG_LEN_CLOSE;
  }

  //                                                               Chk rx'd seq nbr.
  seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr);
  switch (seq_code) {
    case NET_TCP_CONN_RX_SEQ_VALID:
      break;

    case NET_TCP_CONN_RX_SEQ_SYNC:                              // If invalid sync rx'd, ...
    case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagSynCtr);
      //                                                           ... tx TCP conn ack  (see Notes #2c2 & #2b2B).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_RX_SEQ_NONE:
    case NET_TCP_CONN_RX_SEQ_INVALID:                           // If invalid seq  rx'd (see Note #2a4A), ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxSeqInvalidCtr);
      if (p_buf_hdr->TCP_SegReset != DEF_YES) {                 // ... & reset NOT rx'd (see Note #2a4C), ...
                                                                // ... tx TCP conn ack  (see Note #2a4B).
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
        (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      }
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd reset.
  reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr);
  switch (reset_code) {
    case NET_TCP_CONN_RX_RESET_NONE:
      break;

    case NET_TCP_CONN_RX_RESET_VALID:                           // If   valid reset rx'd, ...
                                                                // ...  close TCP conn (see Note #2b1A).
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      rtn_status = NET_TCP_STATUS_VALID;
      goto exit;

    case NET_TCP_CONN_RX_RESET_INVALID:                         // If invalid reset rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagRstCtr);
      //                                                           ... tx TCP conn ack (see Note #2b2Ac).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd ack.
  ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr);
  switch (ack_code) {
    case NET_TCP_CONN_RX_ACK_VALID:
    case NET_TCP_CONN_RX_ACK_DUP:
    case NET_TCP_CONN_RX_ACK_PREV:
      break;

    case NET_TCP_CONN_RX_ACK_NONE:                              // If NO      ack rx'd, ...
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckNoneCtr);            // ... ignore TCP pkt  (see Note #2d1).
      goto exit;

    case NET_TCP_CONN_RX_ACK_OTW:                               // If out-of-window ack rx'd, ...
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckInvalidCtr);
      //                                                           ... tx TCP conn ack (see Note #2d2A3).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_OTW, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_RX_ACK_INVALID:                           // If invalid ack rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckInvalidCtr);
      //                                                           ... tx TCP conn ack (see Note #2d2A3).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- HANDLE RX'D SEG ------------------
  rtn_status = NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, p_err);
  switch (RTOS_ERR_CODE_GET(*p_err)) {
    case RTOS_ERR_NONE:
      break;

    case RTOS_ERR_NET_IF_LINK_DOWN:                             // Ignore transitory tx err(s) [see Note #4].
      goto exit;

    default:
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
  }

  switch (rtn_status) {
    case NET_TCP_STATUS_NONE:
    case NET_TCP_STATUS_DATA:
      break;

    case NET_TCP_STATUS_DUP:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataDupCtr);
      goto exit;

    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  if (p_buf_hdr->TCP_SegClose == DEF_YES) {                     // If fin/close rx'd,                               ...
                                                                // Closing data avail for half-closed conns ONLY.
    data_avail = ((p_conn->ConnCloseCode != NET_CONN_CLOSE_HALF)
                  || ((p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSED)
                      && (p_conn->RxQ_App_Head == DEF_NULL))) ? DEF_NO : DEF_YES;

    if (data_avail != DEF_YES) {                                // ... & NO app data avail,                         ...
                                                                // ... chng to time-wait state (see Note  #2f5B1);  ...
      p_conn->ConnState = NET_TCP_CONN_STATE_TIME_WAIT;
      p_conn->ConnCloseTimeoutFaultFlag = DEF_NO;               // ... clr close timeout fault (see Note  #2f5A1a); ...
      timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;
    } else {                                                    // ... else chng to conn-closing-data-avail state   ...
                                                                // ...                         (see Note  #2f5B2a); ...
      p_conn->ConnState = NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL;
      timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnClosingTimeoutDataAvail;
    }
    //                                                             ... & start time-wait tmr   (see Notes #2f5A1 &  ...
    //                                                             ...                                    #2f5B2b1).
    timeout_ms = p_conn->TimeoutMaxSeg_sec * DEF_TIME_NBR_mS_PER_SEC * NET_TCP_CONN_TIMEOUT_MAX_SEG_SCALAR;
  } else {
    //                                                             Else reset fin-wait-2 tmr   (see Note #3b).
    timeout_ms = NET_TCP_DFLT_TIMEOUT_CONN_FIN_WAIT_2_SEC * DEF_TIME_NBR_mS_PER_SEC;
    timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;
  }
  //                                                               UPDATE TMR's
  //                                                               In time-wait or closing state(s) [see Note #2f5A],
  free_code = NET_TCP_CONN_FREE_TMR_ALL;                        // ... free all TCP conn tmrs       (see Note #2f5A2).
  DEF_BIT_CLR(free_code, (NET_TCP_FREE_CODE)NET_TCP_CONN_FREE_TMR_TIMEOUT);
  NetTCP_ConnFreeTmr(p_conn, free_code);

  if (p_conn->TimeoutTmr != DEF_NULL) {
    NetTmr_Set(p_conn->TimeoutTmr,
               timeout_fnct,
               timeout_ms);
  } else {
    p_conn->TimeoutTmr = NetTmr_Get(timeout_fnct,
                                    p_conn,
                                    timeout_ms,
                                    NET_TMR_OPT_NONE,
                                    p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
    }
  }

  //                                                               ----------------- TC TCP CONN ACK ------------------
  //                                                               Tx TCP conn ack (see Notes #1c).
  (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_IMMED, NET_TCP_CONN_CLOSE_ALL, p_err);

exit:
  return (rtn_status);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerClosing()
 *
 * @brief    (1) Handle TCP connection in CLOSING state :
 *
 *           - (a) Validate received TCP packet for current TCP connection state :
 *
 *               - (1) Sequence Number (SEQ)                                   See Note  #2a
 *               - (2) Reset           (RST)                                   See Note  #2b
 *               - (3) Synchronization (SYN)                                   See Note  #2c
 *               - (4) Acknowledgement (ACK)                                   See Note  #2d
 *               - (5) Finish/Close    (FIN)                                   See Note  #2f
 *
 *           - (b) Update TCP connection :
 *               - (1) Handle received TCP segment                             See Notes #2d    & #2e
 *               - (2) Update TCP connection state :                           See Note  #2d2B2a1A
 *                   - (A) Configure TCP connection timeout value
 *                   - (B) Configure TCP connection timeout function
 *               - (3) Update TCP connection timer(s)                          See Notes #2d2B2a1A, #2d2B2a1B2b,
 *                                                                                               & #3
 *
 *           - (c) Transmit TCP connection acknowledgement & data              See Notes #2d2B1 & #2f3
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) TCP connections in the CLOSING state are handled as follows :
 *
 *                           - (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
 *                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
 *                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
 *
 *                           - (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
 *
 *                           - (2) "Initial tests on arrival are used to discard old duplicates."
 *
 *                           - (3) "If a segment's contents straddle the boundary between old and new, only the
 *                       new parts should be processed."
 *
 *                           - (4) (A) "If an incoming segment is not acceptable," ...
 *
 *                           - (B) "an acknowledgment should be sent in reply" ...
 *
 *                           - (C) "(unless the RST bit is set, if so drop the segment)".
 *
 *                       See also Notes #2b2Aa & #2b2B.
 *
 *                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
 *
 *                           - (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
 *                       states that in the "CLOSING, LAST-ACK, TIME-WAIT" states that "if the RST bit
 *                       is set then, enter the CLOSED state".
 *
 *                           - (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
 *                       that "if the receiver ... of a RST ... was in any other state [other than LISTEN
 *                       or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
 *                       CLOSED state".
 *
 *                           - (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
 *                       with the RST bit when in a synchronized state" to "provide some protection against
 *                       ... blind reset attack[s] using the RST bit" :
 *
 *                           - (a) "If the RST bit is set and the sequence number is outside the expected
 *                       window, silently drop the segment."
 *
 *                           - (b) "If the RST bit is exactly the next expected sequence number [sic], reset
 *                       the connection"; it is assumed that this should read "if the RST bit is
 *                       set and the sequence number is exactly the next expected sequence number,
 *                       reset the connection."
 *
 *                           - (c) "If the RST bit is set and the sequence number does not exactly match
 *                       the next expected sequence value, yet is within the acceptable window
 *                       (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
 *
 *                           - (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
 *                       priority for handling TCP segments received with BOTH the RST & SYN bits set.
 *
 *                       Therefore, since it does NOT seem reasonable to reset a TCP connection
 *                       due to a TCP segment that also attempted to synchronize the  TCP connection,
 *                       it is assumed that the amended handling of the SYN bit should take precedence
 *                       over the amended handling of the RST bit.
 *
 *                       See also Note #2c2.
 *
 *                           - (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
 *                       states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
 *                       FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that :
 *
 *                           - (A) "If the SYN is in the window it is an error, send a reset, any outstanding
 *                       RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
 *                       should be flushed, the user should also receive an unsolicited general
 *                       'connection reset' signal[, and] enter the CLOSED state."
 *
 *                           - (B) But "if the SYN is not in the window this step would not have been reached
 *                       and an ack would have been sent".
 *
 *                           - (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
 *                       of a segment with the SYN bit set in the synchronized state ... [by] handling
 *                       ... the SYN bit" as follows :
 *
 *                           - (a) "If the SYN bit is set and the sequence number is outside the
 *                       expected window, send an ACK back to the peer."
 *
 *                           - (b) "If the SYN bit is set and the sequence number is an exact
 *                       match to the next expected sequence (RCV.NXT == SEG.SEQ)
 *                       then send an ACK segment ... but ... subtract one from
 *                       value being acknowledged."
 *
 *                           - (c) "If the SYN bit is set and the sequence number is acceptable,
 *                       i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
 *                       ACK segment."
 *
 *                           - (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
 *                       states that :
 *
 *                           - (1) "If the ACK bit is off drop the segment."
 *
 *                           - (2) "If the ACK bit is on" :
 *
 *                           - (A) And in the "ESTABLISHED STATE" :
 *
 *                           - (1) "If SND.UNA < SEG.ACK <= SND.NXT then" :
 *
 *                           - (a) "Set SND.UNA <- SEG.ACK."
 *
 *                           - (b) "Any segments on the retransmission queue which are thereby entirely
 *                       acknowledged are removed."
 *
 *                           - (c) "The send window should be updated" :
 *
 *                           - (1) (A) (1) "If ((SND.WL1 <  SEG.SEQ) or" ...
 *
 *                           - (2) (a) "(SND.WL1  = SEG.SEQ and" ...
 *                           - (b)  "SND.WL2 <= SEG.ACK)),"  ...
 *
 *                           - (B) (1) "Set SND.WND <- SEG.WND," ...
 *                           - (2) "Set SND.WL1 <- SEG.SEQ," ...
 *                           - (3) "Set SND.WL2 <- SEG.ACK."
 *
 *                           - (2) "Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the
 *                       sequence number of the last segment used to update SND.WND, and that
 *                       SND.WL2 records the acknowledgment number of the last segment used to
 *                       update SND.WND.  The check here prevents using old segments to update
 *                       the window."
 *
 *                           - (2) (a) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
 *
 *                           - (b) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
 *                       for the segment's acknowledgement to include SND.UNA : "The window should
 *                       updated if SND.UNA <= SEG.ACK <= SND.NXT."
 *
 *                       See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1b2'.
 *
 *                           - (3) "If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK
 *                       [and] drop the segment."
 *
 *                           - (B) For the "CLOSING STATE" :
 *
 *                           - (1) "In addition to the processing for the ESTABLISHED state" ...
 *
 *                           - (2) (a) "If the ACK acknowledges our FIN then" ...
 *
 *                           - (1) (A) "Enter the TIME-WAIT state," ...
 *
 *                           - (1) The following sections ... :
 *
 *                           - (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES :
 *                       Check FIN Bit : FIN-WAIT-1 STATE'
 *                           - (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES :
 *                       Check FIN Bit : FIN-WAIT-2 STATE'
 *
 *                           - (2) ... generalize that when entering "the TIME-WAIT state" to ...
 *
 *                           - (a) "Start the time-wait timer," ...
 *                           - (1) A TCP connection should be closed WITHOUT fault following
 *                       a TCP connection TIME-WAIT timeout.
 *
 *                           - (b) "Turn off the other timers."
 *
 *                           - (3) Although these sections are the only sections to state that these
 *                       TCP connection timers should be updated when transitioning to the
 *                       TIME-WAIT state, it is assumed that these timers should also be
 *                       updated for the transition from the CLOSING state to the TIME-WAIT
 *                       state.
 *
 *                           - (B) However, it is possible that some closing received data from the remote
 *                       host is available but has NOT yet been received by the application layer.
 *
 *                           - (1) Therefore, if the application receive queue is closed, then enter the
 *                       TIME-WAIT state.
 *
 *                           - (2) (a) But if the application receive queue is NOT closed, then enter the
 *                       connection-closing-data-available state to allow the application
 *                       layer to receive the remaining receive data.
 *
 *                           - (b) (1) To satisfy the required time-wait timeout of two maximum segment
 *                       lifetimes (see Note #2f5A1a), the time-wait timeout is initially
 *                       used to provide the application layer sufficient time to receive
 *                       the closing received data.
 *
 *                           - (2) If after the time-wait timeout expires, the application receive
 *                       queue is still not empty, the user connection timeout is used
 *                       to provide the application layer additional time to receive the
 *                       closing received data.
 *
 *                       See also Note #3.
 *
 *                           - (2) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check
 *                       ACK Field : FIN-WAIT-2 STATE' states that "if the retransmission
 *                       queue is empty, the user's CLOSE can be acknowledged".
 *
 *                           - (B) Although this section is the only section to state that the TCP
 *                       connection should acknowledge the user's close, it is assumed that
 *                       a TCP connection should signal the application layer that "the
 *                       user's close [is] acknowledged" whenever its re-transmit queue
 *                       becomes empty.
 *
 *                           - (b) (1) "Otherwise ignore the segment."
 *
 *                           - (2) However, it is possible that some but NOT all transmitted data has
 *                       been received by the remote host.  In other words, the remote host may
 *                       have received some but NOT ALL transmitted data preceding this host's
 *                       connection close request.
 *
 *                       Therefore, acknowledgements validated by as within the transmit
 *                       window MUST be received & processed as in connected states.
 *
 *                       See also 'NetTCP_RxPktConnIsValidAck()  Note #1d'.
 *
 *                       See also Note #2e2.
 *
 *                           - (e) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
 *                       states that in the "CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that "this should not occur, since a FIN has been received from the remote
 *                       side.  Ignore the segment text."
 *
 *                           - (2) (A) However, it is possible that some but NOT all data has been received from
 *                       the remote host.  In other words, the remote host's  connection close request
 *                       may have received but ALL receive data preceding the connection close request
 *                       may NOT have been received.
 *
 *                       Therefore, receive data validated by sequence number as within the
 *                       receive window MUST be received & processed as in connected states.
 *
 *                           - (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment
 *                       Text' states that "once in the ESTABLISHED state, it is possible to deliver
 *                       segment text to user RECEIVE buffers".
 *
 *                       See also Note #2d2B2b.
 *
 *                           - (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
 *                       that "if the FIN bit is set" :
 *
 *                           - (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
 *                       same message," ...
 *
 *                           - (2) "Advance RCV.NXT over the FIN," ...
 *
 *                           - (3) "Send an acknowledgment for the FIN" ...
 *
 *                           - (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
 *
 *                           - (5) And the "CLOSING STATE ... remain[s] in the CLOSING state".
 *
 * @note     (3) (a) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
 *                       "for any state if the user timeout expires, flush all queues, signal the user
 *                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
 *
 *                           - (b) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
 *
 *                       Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
 *                       or control segment should reset its connection timer.
 *
 * @note     (4) Since the mechanisms of TCP connection close are independent of the application layer
 *                       close; any external application layer close error(s) are ignored.
 *
 * @note     (5) Some  transitory errors were ignored &/or not returned from previous handler function(s).
 *                       These transitory errors are included for completeness & as an extra precaution in case
 *                       these transitory errors are returned by handler function(s).
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerClosing(NET_TCP_CONN *p_conn,
                                                     NET_BUF      *p_buf,
                                                     NET_BUF_HDR  *p_buf_hdr,
                                                     RTOS_ERR     *p_err)
{
  NET_TCP_SEQ_CODE   seq_code;
  NET_TCP_ACK_CODE   ack_code;
  NET_TCP_RESET_CODE reset_code;
  CPU_BOOLEAN        data_avail;
  CPU_INT32U         timeout_ms;
  CPU_FNCT_PTR       timeout_fnct;
  NET_TCP_FREE_CODE  free_code;
  NET_TCP_STATUS     rtn_status = NET_TCP_STATUS_INVALID;
  RTOS_ERR           local_err;

  //                                                               -------------- VALIDATE RX'D TCP PKT ---------------
  //                                                               Chk for rx'd fin/close.
  if (p_buf_hdr->TCP_SegClose == DEF_YES) {                     // If fin/close avail, update seg lens.
    p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
    p_buf_hdr->TCP_SegLen += NET_TCP_SEG_LEN_CLOSE;
  }

  //                                                               Chk rx'd seq nbr.
  seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr);
  switch (seq_code) {
    case NET_TCP_CONN_RX_SEQ_VALID:
      break;

    case NET_TCP_CONN_RX_SEQ_SYNC:                              // If invalid sync rx'd, ...
    case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagSynCtr);
      //                                                           ... tx TCP conn ack  (see Notes #2c2 & #2b2B).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_RX_SEQ_NONE:
    case NET_TCP_CONN_RX_SEQ_INVALID:                           // If invalid seq  rx'd (see Note #2a4A), ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxSeqInvalidCtr);
      if (p_buf_hdr->TCP_SegReset != DEF_YES) {                 // ... & reset NOT rx'd (see Note #2a4C), ...
                                                                // ... tx TCP conn ack  (see Note #2a4B).
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
        (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      }
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd reset.
  reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr);
  switch (reset_code) {
    case NET_TCP_CONN_RX_RESET_NONE:
      break;

    case NET_TCP_CONN_RX_RESET_VALID:                           // If   valid reset rx'd, ...
                                                                // ...  close TCP conn (see Note #2b1A).
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      rtn_status = NET_TCP_STATUS_VALID;
      goto exit;

    case NET_TCP_CONN_RX_RESET_INVALID:                         // If invalid reset rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagRstCtr);
      //                                                           ... tx TCP conn ack (see Note #2b2Ac).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd ack.
  ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr);
  switch (ack_code) {
    case NET_TCP_CONN_RX_ACK_VALID:
    case NET_TCP_CONN_RX_ACK_DUP:
    case NET_TCP_CONN_RX_ACK_PREV:
      break;

    case NET_TCP_CONN_RX_ACK_NONE:                              // If NO      ack rx'd, ...
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckNoneCtr);            // ... ignore TCP pkt  (see Note #2d1).
      goto exit;

    case NET_TCP_CONN_RX_ACK_INVALID:                           // If invalid ack rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckInvalidCtr);
      //                                                           ... tx TCP conn ack (see Note #2d2A3).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- HANDLE RX'D SEG ------------------
  rtn_status = NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, p_err);
  switch (RTOS_ERR_CODE_GET(*p_err)) {
    case RTOS_ERR_NONE:
      break;

    case RTOS_ERR_NET_IF_LINK_DOWN:                             // Ignore transitory tx err(s) [see Note #4].
      goto exit;

    default:
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
  }

  switch (rtn_status) {
    case NET_TCP_STATUS_NONE:
    case NET_TCP_STATUS_DATA:
      break;

    case NET_TCP_STATUS_DUP:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataDupCtr);
      goto exit;

    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  //                                                               If local conn close ack'd (see Note #2d2B2a);     ..
  if ((p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED)
      || (p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED_SUSPEND)) {
    //                                                             Closing data avail for half-closed conns ONLY.
    data_avail = ((p_conn->ConnCloseCode != NET_CONN_CLOSE_HALF)
                  || ((p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSED)
                      && (p_conn->RxQ_App_Head == DEF_NULL))) ? DEF_NO : DEF_YES;

    //                                                             .. signal app conn close (see Note #2d2B2a2B),    ..
    NetTCP_RxPktConnHandlerSignalClose(p_conn, data_avail, p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
    }

    if (data_avail != DEF_YES) {                                // .. & if NO app data avail,                        ..
                                                                // .. chng to time-wait state (see Note  #2d2B2a1B1),
      p_conn->ConnState = NET_TCP_CONN_STATE_TIME_WAIT;
      p_conn->ConnCloseTimeoutFaultFlag = DEF_NO;               // .. clr close timeout fault (see Note  #2d2B2a1A2a1),
      timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;
    } else {                                                    // .. else chng to closing-data-avail state          ..
                                                                // ..                         (see Note  #2d2B2a1B2a),
      p_conn->ConnState = NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL;
      timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnClosingTimeoutDataAvail;
    }
    //                                                             .. & start time-wait tmr   (see Notes #2d2B2a1A2a &
    //                                                             ..                                    #2d2B2a1B2b1).
    timeout_ms = p_conn->TimeoutMaxSeg_sec * DEF_TIME_NBR_mS_PER_SEC * NET_TCP_CONN_TIMEOUT_MAX_SEG_SCALAR;
  } else {
    //                                                             Else start conn close tmr (see Note #3b).
    timeout_ms = p_conn->TimeoutConn_sec * DEF_TIME_NBR_mS_PER_SEC;
    timeout_fnct = (CPU_FNCT_PTR)&NetTCP_ConnIdleTimeout;
  }

  //                                                               UPDATE TMR's
  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_TIME_WAIT:                          // If in time-wait            (see Note #2d2B2a1A)  ...
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:                 // ... or closing state(s)    [see Note #2d2B2a1B], ...
      free_code = NET_TCP_CONN_FREE_TMR_ALL;                    // ... free all TCP conn tmrs (see Note #2d2B2a1A2b).
      DEF_BIT_CLR(free_code, (NET_TCP_FREE_CODE)NET_TCP_CONN_FREE_TMR_TIMEOUT);
      NetTCP_ConnFreeTmr(p_conn, free_code);
      break;

    default:                                                    // 'default' case intentionally empty.
      break;
  }

  if (p_conn->TimeoutTmr != DEF_NULL) {
    NetTmr_Set(p_conn->TimeoutTmr,
               timeout_fnct,
               timeout_ms);
  } else {
    p_conn->TimeoutTmr = NetTmr_Get(timeout_fnct,
                                    p_conn,
                                    timeout_ms,
                                    NET_TMR_OPT_NONE,
                                    p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
    }
  }

  //                                                               --------------- TX TCP CONN ACK/DATA ---------------
  ack_code = ((p_buf_hdr->TCP_SegAckTxReqCode == NET_TCP_CONN_TX_ACK_IMMED)
              || (p_buf_hdr->TCP_SegClose == DEF_YES))          // See Note #2f3.
             ?   NET_TCP_CONN_TX_ACK_IMMED
             :   NET_TCP_CONN_TX_ACK;

  if (p_conn->ConnState == NET_TCP_CONN_STATE_CLOSING) {        // If conn still closing, ...
                                                                // ... tx ack & any tx data (see Note #1c).
    NetTCP_TxConnTxQ(p_conn,
                     p_buf_hdr,
                     ack_code,
                     DEF_NO,
                     NET_TCP_CONN_CLOSE_ALL,
                     DEF_NO,
                     p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
  } else {                                                      // Else tx TCP conn ack (see Note #2f3).
    (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, ack_code, NET_TCP_CONN_CLOSE_ALL, p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
  }

exit:
  return (rtn_status);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerTimeWait()
 *
 * @brief    (1) Handle TCP connection in TIME-WAIT state :
 *
 *           - (a) Validate received TCP packet for current TCP connection state :
 *
 *               - (1) Sequence Number (SEQ)                                   See Note  #2a
 *               - (2) Reset           (RST)                                   See Note  #2b
 *               - (3) Synchronization (SYN)                                   See Note  #2c
 *               - (4) Acknowledgement (ACK)                                   See Note  #2d
 *               - (5) Finish/Close    (FIN)                                   See Note  #2f
 *
 *           - (b) Update TCP connection :
 *               - (1) Handle received TCP segment                             See Notes #2d    & #2e
 *               - (2) Update TCP connection timer                             See Notes #2d2C2
 *
 *           - (c) Transmit TCP connection acknowledgement                     See Notes #2d2C1 & #2f3
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) TCP connections in the TIME-WAIT state are handled as follows :
 *
 *                           - (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
 *                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
 *                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
 *
 *                           - (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
 *
 *                           - (2) "Initial tests on arrival are used to discard old duplicates."
 *
 *                           - (3) "If a segment's contents straddle the boundary between old and new, only the
 *                       new parts should be processed."
 *
 *                           - (4) (A) "If an incoming segment is not acceptable," ...
 *
 *                           - (B) "an acknowledgment should be sent in reply" ...
 *
 *                           - (C) "(unless the RST bit is set, if so drop the segment)".
 *
 *                       See also Notes #2b2Aa & #2b2B.
 *
 *                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
 *
 *                           - (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
 *                       states that in the "CLOSING, LAST-ACK, TIME-WAIT" states that "if the RST bit
 *                       is set then, enter the CLOSED state".
 *
 *                           - (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
 *                       that "if the receiver ... of a RST ... was in any other state [other than LISTEN
 *                       or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
 *                       CLOSED state".
 *
 *                           - (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
 *                       with the RST bit when in a synchronized state" to "provide some protection against
 *                       ... blind reset attack[s] using the RST bit" :
 *
 *                           - (a) "If the RST bit is set and the sequence number is outside the expected
 *                       window, silently drop the segment."
 *
 *                           - (b) "If the RST bit is exactly the next expected sequence number [sic], reset
 *                       the connection"; it is assumed that this should read "if the RST bit is
 *                       set and the sequence number is exactly the next expected sequence number,
 *                       reset the connection."
 *
 *                           - (c) "If the RST bit is set and the sequence number does not exactly match
 *                       the next expected sequence value, yet is within the acceptable window
 *                       (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
 *
 *                           - (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
 *                       priority for handling TCP segments received with BOTH the RST & SYN bits set.
 *
 *                       Therefore, since it does NOT seem reasonable to reset a TCP connection
 *                       due to a TCP segment that also attempted to synchronize the  TCP connection,
 *                       it is assumed that the amended handling of the SYN bit should take precedence
 *                       over the amended handling of the RST bit.
 *
 *                       See also Note #2c2.
 *
 *                           - (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
 *                       states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
 *                       FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that :
 *
 *                           - (A) "If the SYN is in the window it is an error, send a reset, any outstanding
 *                       RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
 *                       should be flushed, the user should also receive an unsolicited general
 *                       'connection reset' signal[, and] enter the CLOSED state."
 *
 *                           - (B) But "if the SYN is not in the window this step would not have been reached
 *                       and an ack would have been sent".
 *
 *                           - (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
 *                       of a segment with the SYN bit set in the synchronized state ... [by] handling
 *                       ... the SYN bit" as follows :
 *
 *                           - (a) "If the SYN bit is set and the sequence number is outside the
 *                       expected window, send an ACK back to the peer."
 *
 *                           - (b) "If the SYN bit is set and the sequence number is an exact
 *                       match to the next expected sequence (RCV.NXT == SEG.SEQ)
 *                       then send an ACK segment ... but ... subtract one from
 *                       value being acknowledged."
 *
 *                           - (c) "If the SYN bit is set and the sequence number is acceptable,
 *                       i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
 *                       ACK segment."
 *
 *                           - (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
 *                       states that :
 *
 *                           - (1) "If the ACK bit is off drop the segment."
 *
 *                           - (2) "If the ACK bit is on" :
 *
 *                           - (A) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
 *
 *                           - (B) "If the ACK acks something not yet sent ... then send an ACK [and] drop the segment."
 *
 *                           - (C) For the "TIME-WAIT STATE ... the only thing that can arrive in this state is a
 *                       retransmission of the remote FIN" :
 *
 *                           - (1) "Acknowledge it" ...
 *                           - (2) "Restart the 2 MSL timeout."
 *
 *                           - (e) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
 *                       states that in the "CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that "this should not occur, since a FIN has been received from the remote
 *                       side.  Ignore the segment text."
 *
 *                           - (2) (A) However, it is possible that some but NOT all data has been received from
 *                       the remote host.  In other words, the remote host's  connection close request
 *                       may have received but ALL receive data preceding the connection close request
 *                       may NOT have been received.
 *
 *                       Therefore, receive data validated by sequence number as within the
 *                       receive window MUST be received & processed as in connected states.
 *
 *                           - (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment
 *                       Text' states that "once in the ESTABLISHED state, it is possible to deliver
 *                       segment text to user RECEIVE buffers".
 *
 *                           - (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
 *                       that "if the FIN bit is set" :
 *
 *                           - (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
 *                       same message," ...
 *
 *                           - (2) "Advance RCV.NXT over the FIN," ...
 *
 *                           - (3) "Send an acknowledgment for the FIN" ...
 *
 *                           - (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
 *
 *                           - (5) For the "TIME-WAIT STATE" :
 *
 *                           - (A) "Remain in the TIME-WAIT state" ...
 *                           - (B) "Restart the 2 MSL time-wait timeout."
 *
 * @note     (3) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : TIME-WAIT TIMEOUT' states
 *                       that "if the time-wait timeout expires on a connection ... enter the CLOSED state".
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerTimeWait(NET_TCP_CONN *p_conn,
                                                      NET_BUF      *p_buf,
                                                      NET_BUF_HDR  *p_buf_hdr,
                                                      RTOS_ERR     *p_err)
{
  NET_TCP_SEQ_CODE   seq_code;
  NET_TCP_ACK_CODE   ack_code;
  NET_TCP_RESET_CODE reset_code;
  CPU_INT32U         timeout_ms;
  NET_TCP_STATUS     rtn_status = NET_TCP_STATUS_INVALID;
  RTOS_ERR           local_err;

  //                                                               -------------- VALIDATE RX'D TCP PKT ---------------
  PP_UNUSED_PARAM(p_buf_hdr->TCP_SegClose);                     // Ignore any rx'd fin (see Note #2f5A).

  //                                                               Chk rx'd seq nbr.
  seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr);
  switch (seq_code) {
    case NET_TCP_CONN_RX_SEQ_VALID:
      break;

    case NET_TCP_CONN_RX_SEQ_SYNC:                              // If invalid sync rx'd, ...
    case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagSynCtr);
      //                                                           ... tx TCP conn ack  (see Notes #2c2 & #2b2B).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_RX_SEQ_NONE:
    case NET_TCP_CONN_RX_SEQ_INVALID:                           // If invalid seq  rx'd (see Note #2a4A), ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxSeqInvalidCtr);
      if (p_buf_hdr->TCP_SegReset != DEF_YES) {                 // ... & reset NOT rx'd (see Note #2a4C), ...
                                                                // ... tx TCP conn ack  (see Note #2a4B).
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
        (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      }
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd reset.
  reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr);
  switch (reset_code) {
    case NET_TCP_CONN_RX_RESET_NONE:
      break;

    case NET_TCP_CONN_RX_RESET_VALID:                           // If   valid reset rx'd, ...
                                                                // ...  close TCP conn (see Note #2b1A).
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      rtn_status = NET_TCP_STATUS_VALID;
      goto exit;

    case NET_TCP_CONN_RX_RESET_INVALID:                         // If invalid reset rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagRstCtr);
      //                                                           ... tx TCP conn ack (see Note #2b2Ac).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd ack.
  ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr);
  switch (ack_code) {
    case NET_TCP_CONN_RX_ACK_VALID:
    case NET_TCP_CONN_RX_ACK_DUP:
    case NET_TCP_CONN_RX_ACK_PREV:
      break;

    case NET_TCP_CONN_RX_ACK_NONE:                              // If NO      ack rx'd, ...
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckNoneCtr);            // ... ignore TCP pkt  (see Note #2d1).
      goto exit;

    case NET_TCP_CONN_RX_ACK_INVALID:                           // If invalid ack rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckInvalidCtr);
      //                                                           ... tx TCP conn ack (see Note #2d2B).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- HANDLE RX'D SEG ------------------
  rtn_status = NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, p_err);
  switch (RTOS_ERR_CODE_GET(*p_err)) {
    case RTOS_ERR_NONE:
      break;

    case RTOS_ERR_NET_IF_LINK_DOWN:                             // Ignore transitory tx err(s) [see Note #4].
      goto exit;

    default:
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
  }

  switch (rtn_status) {
    case NET_TCP_STATUS_NONE:
    case NET_TCP_STATUS_DATA:
      break;

    case NET_TCP_STATUS_DUP:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataDupCtr);
      goto exit;

    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  //                                                               -------------------- UPDATE TMR --------------------
  //                                                               Reset time-wait tmr (see Note #2d2C2).
  timeout_ms = p_conn->TimeoutMaxSeg_sec * DEF_TIME_NBR_mS_PER_SEC * NET_TCP_CONN_TIMEOUT_MAX_SEG_SCALAR;
  if (p_conn->TimeoutTmr != DEF_NULL) {
    NetTmr_Set(p_conn->TimeoutTmr,
               NetTCP_ConnIdleTimeout,
               timeout_ms);
  } else {
    p_conn->TimeoutTmr = NetTmr_Get(NetTCP_ConnIdleTimeout,
                                    p_conn,
                                    timeout_ms,
                                    NET_TMR_OPT_NONE,
                                    p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
    }
  }

  //                                                               ----------------- TX TCP CONN ACK ------------------
  //                                                               Tx TCP conn ack (see Notes #1c).
  (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_IMMED, NET_TCP_CONN_CLOSE_ALL, p_err);

exit:
  return (rtn_status);
}

/****************************************************************************************************//**
 *                                   NetTCP_RxPktConnHandlerCloseWait()
 *
 * @brief    (1) Handle TCP connection in CLOSE-WAIT state :
 *
 *           - (a) Validate received TCP packet for current TCP connection state :
 *
 *               - (1) Sequence Number (SEQ)                                   See Note  #2a
 *               - (2) Reset           (RST)                                   See Note  #2b
 *               - (3) Synchronization (SYN)                                   See Note  #2c
 *               - (4) Acknowledgement (ACK)                                   See Note  #2d
 *               - (5) Finish/Close    (FIN)                                   See Note  #2f
 *
 *           - (b) Update TCP connection :
 *               - (1) Handle received TCP segment                             See Notes #2d   & #2e
 *               - (2) Update TCP connection timer                             See Note  #3
 *
 *           - (c) Transmit TCP connection acknowledgement & data              See Notes #2d2B & #2f3
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) TCP connections in the CLOSE-WAIT state are handled as follows :
 *
 *                           - (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
 *                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
 *                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
 *
 *                           - (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
 *
 *                           - (2) "Initial tests on arrival are used to discard old duplicates."
 *
 *                           - (3) "If a segment's contents straddle the boundary between old and new, only the
 *                       new parts should be processed."
 *
 *                           - (4) (A) "If an incoming segment is not acceptable," ...
 *
 *                           - (B) "an acknowledgment should be sent in reply" ...
 *
 *                           - (C) "(unless the RST bit is set, if so drop the segment)".
 *
 *                       See also Notes #2b2Aa & #2b2B.
 *
 *                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
 *
 *                           - (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit' states
 *                       that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states that "if the
 *                       RST bit is set then, any outstanding RECEIVEs and SEND[s] should receive 'reset'
 *                       responses.  All segment queues should be flushed.  Users should also receive an
 *                       unsolicited general 'connection reset' signal[, and] enter the CLOSED state".
 *
 *                           - (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
 *                       that "if the receiver ... of a RST ... was in any other state [other than LISTEN
 *                       or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
 *                       CLOSED state".
 *
 *                           - (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
 *                       with the RST bit when in a synchronized state" to "provide some protection against
 *                       ... blind reset attack[s] using the RST bit" :
 *
 *                           - (a) "If the RST bit is set and the sequence number is outside the expected
 *                       window, silently drop the segment."
 *
 *                           - (b) "If the RST bit is exactly the next expected sequence number [sic], reset
 *                       the connection"; it is assumed that this should read "if the RST bit is
 *                       set and the sequence number is exactly the next expected sequence number,
 *                       reset the connection."
 *
 *                           - (c) "If the RST bit is set and the sequence number does not exactly match
 *                       the next expected sequence value, yet is within the acceptable window
 *                       (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
 *
 *                           - (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
 *                       priority for handling TCP segments received with BOTH the RST & SYN bits set.
 *
 *                       Therefore, since it does NOT seem reasonable to reset a TCP connection
 *                       due to a TCP segment that also attempted to synchronize the  TCP connection,
 *                       it is assumed that the amended handling of the SYN bit should take precedence
 *                       over the amended handling of the RST bit.
 *
 *                       See also Note #2c2.
 *
 *                           - (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
 *                       states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
 *                       FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that :
 *
 *                           - (A) "If the SYN is in the window it is an error, send a reset, any outstanding
 *                       RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
 *                       should be flushed, the user should also receive an unsolicited general
 *                       'connection reset' signal[, and] enter the CLOSED state."
 *
 *                           - (B) But "if the SYN is not in the window this step would not have been reached
 *                       and an ack would have been sent".
 *
 *                           - (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
 *                       of a segment with the SYN bit set in the synchronized state ... [by] handling
 *                       ... the SYN bit" as follows :
 *
 *                           - (a) "If the SYN bit is set and the sequence number is outside the
 *                       expected window, send an ACK back to the peer."
 *
 *                           - (b) "If the SYN bit is set and the sequence number is an exact
 *                       match to the next expected sequence (RCV.NXT == SEG.SEQ)
 *                       then send an ACK segment ... but ... subtract one from
 *                       value being acknowledged."
 *
 *                           - (c) "If the SYN bit is set and the sequence number is acceptable,
 *                       i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
 *                       ACK segment."
 *
 *                           - (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
 *                       states that :
 *
 *                           - (1) "If the ACK bit is off drop the segment."
 *
 *                           - (2) "If the ACK bit is on" :
 *
 *                           - (A) And in the "ESTABLISHED STATE" :
 *
 *                           - (1) "If SND.UNA < SEG.ACK <= SND.NXT then" :
 *
 *                           - (a) "Set SND.UNA <- SEG.ACK."
 *
 *                           - (b) "Any segments on the retransmission queue which are thereby entirely
 *                       acknowledged are removed."
 *
 *                           - (c) "The send window should be updated" :
 *
 *                           - (1) (A) (1) "If ((SND.WL1 <  SEG.SEQ) or" ...
 *
 *                           - (2) (a) "(SND.WL1  = SEG.SEQ and" ...
 *                           - (b)  "SND.WL2 <= SEG.ACK)),"  ...
 *
 *                           - (B) (1) "Set SND.WND <- SEG.WND," ...
 *                           - (2) "Set SND.WL1 <- SEG.SEQ," ...
 *                           - (3) "Set SND.WL2 <- SEG.ACK."
 *
 *                           - (2) "Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the
 *                       sequence number of the last segment used to update SND.WND, and that
 *                       SND.WL2 records the acknowledgment number of the last segment used to
 *                       update SND.WND.  The check here prevents using old segments to update
 *                       the window."
 *
 *                           - (2) (a) "If the ACK is a duplicate (SEG.ACK <= SND.UNA), it can be ignored."
 *
 *                           - (b) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
 *                       for the segment's acknowledgement to include SND.UNA : "The window should
 *                       updated if SND.UNA <= SEG.ACK <= SND.NXT."
 *
 *                       See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1b2'.
 *
 *                           - (3) "If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK
 *                       [and] drop the segment."
 *
 *                           - (B) For the "CLOSE-WAIT STATE ... do the same processing as for the ESTABLISHED state".
 *
 *                           - (e) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
 *                       states that in the "CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that "this should not occur, since a FIN has been received from the remote
 *                       side.  Ignore the segment text."
 *
 *                           - (2) (A) However, it is possible that some but NOT all data has been received from the
 *                       remote host.  In other words, the remote host's close request may have been
 *                       received but ALL receive data preceding the close request may NOT have been
 *                       received.
 *
 *                       Therefore, receive data validated by sequence number as within the receive
 *                       window MUST be received & processed as in connected states.
 *
 *                           - (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment
 *                       Text' states that "once in the ESTABLISHED state, it is possible to deliver
 *                       segment text to user RECEIVE buffers".
 *
 *                       See also Note #2d2B.
 *
 *                           - (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
 *                       that "if the FIN bit is set" :
 *
 *                           - (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
 *                       same message," ...
 *
 *                           - (2) "Advance RCV.NXT over the FIN," ...
 *
 *                           - (3) "Send an acknowledgment for the FIN" ...
 *
 *                           - (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
 *
 *                           - (5) And the "CLOSE-WAIT STATE ... remain[s] in the CLOSE-WAIT state".
 *
 * @note     (3) (a) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
 *                       "for any state if the user timeout expires, flush all queues, signal the user
 *                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
 *
 *                           - (b) However, NO RFC specifies or suggests any mechanism to implement/handle user timeouts.
 *
 *                       Therefore, it is assumed that ANY TCP connection that receives a valid TCP data
 *                       or control segment should reset its connection timer.
 *
 * @note     (4) Some  transitory errors were ignored &/or not returned from previous handler function(s).
 *                       These transitory errors are included for completeness & as an extra precaution in case
 *                       these transitory errors are returned by handler function(s).
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerCloseWait(NET_TCP_CONN *p_conn,
                                                       NET_BUF      *p_buf,
                                                       NET_BUF_HDR  *p_buf_hdr,
                                                       RTOS_ERR     *p_err)
{
  NET_TCP_SEQ_CODE   seq_code;
  NET_TCP_ACK_CODE   ack_code;
  NET_TCP_RESET_CODE reset_code;
  CPU_INT32U         timeout_ms;
  NET_TCP_STATUS     rtn_status = NET_TCP_STATUS_INVALID;
  RTOS_ERR           local_err;

  //                                                               -------------- VALIDATE RX'D TCP PKT ---------------
  //                                                               Chk for rx'd fin/close.
  if (p_buf_hdr->TCP_SegClose == DEF_YES) {                     // If fin/close avail, update seg lens.
    p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
    p_buf_hdr->TCP_SegLen += NET_TCP_SEG_LEN_CLOSE;
  }

  //                                                               Chk rx'd seq nbr.
  seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr);
  switch (seq_code) {
    case NET_TCP_CONN_RX_SEQ_VALID:
      break;

    case NET_TCP_CONN_RX_SEQ_SYNC:                              // If invalid sync rx'd, ...
    case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagSynCtr);
      //                                                           ... tx TCP conn ack  (see Notes #2c2 & #2b2B).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_RX_SEQ_NONE:
    case NET_TCP_CONN_RX_SEQ_INVALID:                           // If invalid seq  rx'd (see Note #2a4A), ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxSeqInvalidCtr);
      if (p_buf_hdr->TCP_SegReset != DEF_YES) {                 // ... & reset NOT rx'd (see Note #2a4C), ...
                                                                // ... tx TCP conn ack  (see Note #2a4B).
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
        (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      }
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd reset.
  reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr);
  switch (reset_code) {
    case NET_TCP_CONN_RX_RESET_NONE:
      break;

    case NET_TCP_CONN_RX_RESET_VALID:                           // If   valid reset rx'd, ...
                                                                // ...  close TCP conn (see Note #2b1A).
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      rtn_status = NET_TCP_STATUS_VALID;
      goto exit;

    case NET_TCP_CONN_RX_RESET_INVALID:                         // If invalid reset rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagRstCtr);
      //                                                           ... tx TCP conn ack (see Note #2b2Ac).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd ack.
  ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr);
  switch (ack_code) {
    case NET_TCP_CONN_RX_ACK_VALID:
    case NET_TCP_CONN_RX_ACK_DUP:
    case NET_TCP_CONN_RX_ACK_PREV:
      break;

    case NET_TCP_CONN_RX_ACK_NONE:                              // If NO      ack rx'd, ...
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckNoneCtr);            // ... ignore TCP pkt  (see Note #2d1).
      goto exit;

    case NET_TCP_CONN_RX_ACK_INVALID:                           // If invalid ack rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckInvalidCtr);
      //                                                           ... tx TCP conn ack (see Note #2d2A3).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- HANDLE RX'D SEG ------------------
  rtn_status = NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, p_err);
  switch (RTOS_ERR_CODE_GET(*p_err)) {
    case RTOS_ERR_NONE:
      break;

    case RTOS_ERR_NET_IF_LINK_DOWN:                             // Ignore transitory tx err(s) [see Note #4].
      goto exit;

    default:
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
  }

  switch (rtn_status) {
    case NET_TCP_STATUS_NONE:
    case NET_TCP_STATUS_DATA:
      break;

    case NET_TCP_STATUS_DUP:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataDupCtr);
      goto exit;

    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  //                                                               -------------------- UPDATE TMR --------------------
  //                                                               Reset conn idle/close tmr (see Note #3b).
  timeout_ms = p_conn->TimeoutConn_sec * DEF_TIME_NBR_mS_PER_SEC;
  if (p_conn->TimeoutTmr != DEF_NULL) {
    NetTmr_Set(p_conn->TimeoutTmr,
               NetTCP_ConnIdleTimeout,
               timeout_ms);
  } else {
    p_conn->TimeoutTmr = NetTmr_Get(NetTCP_ConnIdleTimeout,
                                    p_conn,
                                    timeout_ms,
                                    NET_TMR_OPT_NONE,
                                    p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
    }
  }

  //                                                               --------------- TX TCP CONN ACK/DATA ---------------
  ack_code = ((p_buf_hdr->TCP_SegAckTxReqCode == NET_TCP_CONN_TX_ACK_IMMED)
              || (p_buf_hdr->TCP_SegClose == DEF_YES))          // See Note #2f3.
             ?   NET_TCP_CONN_TX_ACK_IMMED
             :   NET_TCP_CONN_TX_ACK;
  //                                                               Tx ack & any tx data (see Note #1c).
  NetTCP_TxConnTxQ(p_conn,
                   p_buf_hdr,
                   ack_code,
                   DEF_NO,
                   NET_TCP_CONN_CLOSE_ALL,
                   DEF_NO,
                   p_err);

exit:
  return (rtn_status);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerLastAck()
 *
 * @brief    (1) Handle TCP connection in LAST-ACK state :
 *
 *           - (a) Validate received TCP packet for current TCP connection state :
 *
 *               - (1) Sequence Number (SEQ)                                   See Note  #2a
 *               - (2) Reset           (RST)                                   See Note  #2b
 *               - (3) Synchronization (SYN)                                   See Note  #2c
 *               - (4) Acknowledgement (ACK)                                   See Note  #2d
 *               - (5) Finish/Close    (FIN)                                   See Note  #2f
 *
 *           - (b) Update TCP connection :
 *               - (1) Handle received TCP segment                             See Notes #2d       & #2e
 *               - (2) Update TCP connection state :                           See Notes #2d2A1a   & #2d2A1b2A
 *                   - (A) Configure TCP connection timeout value
 *               - (3) Update TCP connection timer                             See Notes #2d2A1b2B & #3
 *
 *           - (c) Transmit TCP connection acknowledgement & data              See Notes #2d2B     & #2f3
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) TCP connections in the LAST-ACK state are handled as follows :
 *
 *                           - (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
 *                       states that in the "SYN-RECEIVED, ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2
 *                       STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT STATE" that :
 *
 *                           - (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
 *
 *                           - (2) "Initial tests on arrival are used to discard old duplicates."
 *
 *                           - (3) "If a segment's contents straddle the boundary between old and new, only the
 *                       new parts should be processed."
 *
 *                           - (4) (A) "If an incoming segment is not acceptable," ...
 *
 *                           - (B) "an acknowledgment should be sent in reply" ...
 *
 *                           - (C) "(unless the RST bit is set, if so drop the segment)".
 *
 *                       See also Notes #2b2Aa & #2b2B.
 *
 *                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #1d'.
 *
 *                           - (b) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit' states
 *                       that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states that "if the
 *                       RST bit is set then, any outstanding RECEIVEs and SEND[s] should receive 'reset'
 *                       responses.  All segment queues should be flushed.  Users should also receive an
 *                       unsolicited general 'connection reset' signal[, and] enter the CLOSED state".
 *
 *                           - (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
 *                       that "if the receiver ... of a RST ... was in any other state [other than LISTEN
 *                       or SYN-RECEIVED], it aborts the connection and advises the user and goes to the
 *                       CLOSED state".
 *
 *                           - (2) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
 *                       with the RST bit when in a synchronized state" to "provide some protection against
 *                       ... blind reset attack[s] using the RST bit" :
 *
 *                           - (a) "If the RST bit is set and the sequence number is outside the expected
 *                       window, silently drop the segment."
 *
 *                           - (b) "If the RST bit is exactly the next expected sequence number [sic], reset
 *                       the connection"; it is assumed that this should read "if the RST bit is
 *                       set and the sequence number is exactly the next expected sequence number,
 *                       reset the connection."
 *
 *                           - (c) "If the RST bit is set and the sequence number does not exactly match
 *                       the next expected sequence value, yet is within the acceptable window
 *                       (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
 *
 *                           - (B) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
 *                       priority for handling TCP segments received with BOTH the RST & SYN bits set.
 *
 *                       Therefore, since it does NOT seem reasonable to reset a TCP connection
 *                       due to a TCP segment that also attempted to synchronize the  TCP connection,
 *                       it is assumed that the amended handling of the SYN bit should take precedence
 *                       over the amended handling of the RST bit.
 *
 *                       See also Note #2c2.
 *
 *                           - (c) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
 *                       states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
 *                       FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that :
 *
 *                           - (A) "If the SYN is in the window it is an error, send a reset, any outstanding
 *                       RECEIVEs and SEND[s] should receive 'reset' responses, all segment queues
 *                       should be flushed, the user should also receive an unsolicited general
 *                       'connection reset' signal[, and] enter the CLOSED state."
 *
 *                           - (B) But "if the SYN is not in the window this step would not have been reached
 *                       and an ack would have been sent".
 *
 *                           - (2) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the  "handling
 *                       of a segment with the SYN bit set in the synchronized state ... [by] handling
 *                       ... the SYN bit" as follows :
 *
 *                           - (a) "If the SYN bit is set and the sequence number is outside the
 *                       expected window, send an ACK back to the peer."
 *
 *                           - (b) "If the SYN bit is set and the sequence number is an exact
 *                       match to the next expected sequence (RCV.NXT == SEG.SEQ)
 *                       then send an ACK segment ... but ... subtract one from
 *                       value being acknowledged."
 *
 *                           - (c) "If the SYN bit is set and the sequence number is acceptable,
 *                       i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
 *                       ACK segment."
 *
 *                           - (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
 *                       states that :
 *
 *                           - (1) "If the ACK bit is off drop the segment."
 *
 *                           - (2) "If the ACK bit is on [and in the] LAST-ACK STATE" :
 *
 *                           - (A) "The only thing that can arrive in this state is an acknowledgement of our FIN."
 *
 *                           - (1) "If our FIN is now acknowledged" ...
 *
 *                           - (a) "Enter the CLOSED state."
 *
 *                           - (b) However, it is possible that some closing received data from the remote
 *                       host is available but has NOT yet been received by the application layer.
 *
 *                           - (1) Therefore, if the application receive queue is closed, then close the
 *                       TCP connection &/or enter the CLOSED state.
 *
 *                           - (2) (A) But if the application receive queue is NOT closed, then enter the
 *                       connection-closing-data-available state to allow the application
 *                       layer to receive the remaining receive data.
 *
 *                           - (B) To provide the application layer sufficient time to receive the
 *                       closing received data, the user connection timeout is used as a
 *                       connection closing timeout.
 *
 *                       See also Note #2e2.
 *
 *                           - (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                       FIN-WAIT-2 STATE' states that "if the retransmission queue is empty, the
 *                       user's CLOSE can be acknowledged".
 *
 *                           - (b) However, TCP connection should signal the application layer that "the user's
 *                       close [is] acknowledged" whenever its re-transmit queue becomes &/or is
 *                       empty :
 *
 *                           - (1) Transition from LAST-ACK to CLOSED
 *
 *                       See also 'NetTCP_RxPktConnHandlerSignalClose()  Note #1'.
 *
 *                           - (B) However, it is possible that some but NOT all transmitted data has been received
 *                       by the remote host.  In other words, the remote host may have received some but
 *                       NOT ALL receive data preceding this host's close request.
 *
 *                       Therefore, acknowledgements validated as within the transmit window MUST be
 *                       received & processed as in connected states.
 *
 *                       See also 'NetTCP_RxPktConnIsValidAck()  Note #1d'.
 *
 *                           - (e) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text'
 *                       states that in the "CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                       STATE" that "this should not occur, since a FIN has been received from the remote
 *                       side.  Ignore the segment text."
 *
 *                           - (2) (A) However, it is possible that some but NOT all data has been received from
 *                       the remote host.  In other words, the remote host's close request may have
 *                       received but ALL receive data preceding the close request may NOT have been
 *                       received.
 *
 *                       Therefore, receive data validated by sequence number as within the
 *                       receive window MUST be received & processed as in connected states.
 *
 *                           - (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment
 *                       Text' states that "once in the ESTABLISHED state, it is possible to deliver
 *                       segment text to user RECEIVE buffers".
 *
 *                       See also Note #2d2A1b.
 *
 *                           - (f) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
 *                       that "if the FIN bit is set" :
 *
 *                           - (1) "Signal the user 'connection closing' and return any pending RECEIVEs with
 *                       same message," ...
 *
 *                           - (2) "Advance RCV.NXT over the FIN," ...
 *
 *                           - (3) "Send an acknowledgment for the FIN" ...
 *
 *                           - (4) "FIN implies PUSH for any segment text not yet delivered to the user" ...
 *
 *                           - (5) And the "LAST-ACK STATE ... remain[s] in the LAST-ACK state".
 *
 * @note     (3) (a) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
 *                       "for any state if the user timeout expires, flush all queues, signal the user
 *                       'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
 *
 *                           - (b) (1) However, a TCP connection enters the LAST-ACK state ONLY after the remote host
 *                       has initiated an active close & enters the TIME-WAIT state, waiting for its
 *                       time-wait timer to expire before closing its TCP connection.
 *
 *                           - (2) Therefore, a TCP connection in the LAST-ACK state should NOT wait for its
 *                       last acknowledgement from the remote host in the TIME-WAIT state longer than
 *                       the remote host's time-wait timeout of two TCP maximum segment lifetimes.
 *
 *                           - (3) Therefore, it is assumed that ANY TCP connection in the LAST-ACK state
 *                       that receives a valid TCP data or control segment should reset its time-wait
 *                       timer for two TCP maximum segment lifetimes.
 *
 * @note     (4) Since the mechanisms of TCP connection close are independent of the application layer
 *                       close; any external application layer close error(s) are ignored.
 *
 * @note     (5) Some  transitory errors were ignored &/or not returned from previous handler function(s).
 *                       These transitory errors are included for completeness & as an extra precaution in case
 *                       these transitory errors are returned by handler function(s).
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerLastAck(NET_TCP_CONN *p_conn,
                                                     NET_BUF      *p_buf,
                                                     NET_BUF_HDR  *p_buf_hdr,
                                                     RTOS_ERR     *p_err)
{
  NET_TCP_SEQ_CODE   seq_code;
  NET_TCP_ACK_CODE   ack_code;
  NET_TCP_RESET_CODE reset_code;
  CPU_BOOLEAN        data_avail;
  CPU_BOOLEAN        close_conn;
  CPU_INT32U         timeout_ms;
  NET_TCP_STATUS     rtn_status = NET_TCP_STATUS_INVALID;
  RTOS_ERR           local_err;

  //                                                               -------------- VALIDATE RX'D TCP PKT ---------------
  //                                                               Chk for rx'd fin/close.
  if (p_buf_hdr->TCP_SegClose == DEF_YES) {                     // If fin/close avail, update seg lens.
    p_buf_hdr->TCP_SegLenInit += NET_TCP_SEG_LEN_CLOSE;
    p_buf_hdr->TCP_SegLen += NET_TCP_SEG_LEN_CLOSE;
  }

  //                                                               Chk rx'd seq nbr.
  seq_code = NetTCP_RxPktConnIsValidSeq(p_conn, p_buf_hdr);
  switch (seq_code) {
    case NET_TCP_CONN_RX_SEQ_VALID:
      break;

    case NET_TCP_CONN_RX_SEQ_SYNC:                              // If invalid sync rx'd, ...
    case NET_TCP_CONN_RX_SEQ_SYNC_INVALID:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagSynCtr);
      //                                                           ... tx TCP conn ack  (see Notes #2c2 & #2b2B).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_RX_SEQ_NONE:
    case NET_TCP_CONN_RX_SEQ_INVALID:                           // If invalid seq  rx'd (see Note #2a4A), ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxSeqInvalidCtr);
      if (p_buf_hdr->TCP_SegReset != DEF_YES) {                 // ... & reset NOT rx'd (see Note #2a4C), ...
                                                                // ... tx TCP conn ack  (see Note #2a4B).
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
        (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      }
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd reset.
  reset_code = NetTCP_RxPktConnIsValidReset(p_conn, p_buf_hdr);
  switch (reset_code) {
    case NET_TCP_CONN_RX_RESET_NONE:
      break;

    case NET_TCP_CONN_RX_RESET_VALID:                           // If   valid reset rx'd, ...
                                                                // ...  close TCP conn (see Note #2b1A).
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      rtn_status = NET_TCP_STATUS_VALID;
      goto exit;

    case NET_TCP_CONN_RX_RESET_INVALID:                         // If invalid reset rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrFlagRstCtr);
      //                                                           ... tx TCP conn ack (see Note #2b2Ac).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               Chk for rx'd ack.
  ack_code = NetTCP_RxPktConnIsValidAck(p_conn, p_buf_hdr);
  switch (ack_code) {
    case NET_TCP_CONN_RX_ACK_VALID:
    case NET_TCP_CONN_RX_ACK_DUP:
    case NET_TCP_CONN_RX_ACK_PREV:
      break;

    case NET_TCP_CONN_RX_ACK_NONE:                              // If NO      ack rx'd, ...
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckNoneCtr);            // ... ignore TCP pkt  (see Note #2d1).
      goto exit;

    case NET_TCP_CONN_RX_ACK_INVALID:                           // If invalid ack rx'd, ...
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxAckInvalidCtr);
      //                                                           ... tx TCP conn ack (see Note #2d2B).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, NET_TCP_CONN_TX_ACK_FAULT, NET_TCP_CONN_CLOSE_ALL, &local_err);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- HANDLE RX'D SEG ------------------
  rtn_status = NetTCP_RxPktConnHandlerSeg(p_conn, ack_code, p_buf, p_buf_hdr, p_err);
  switch (RTOS_ERR_CODE_GET(*p_err)) {
    case RTOS_ERR_NONE:
      break;

    case RTOS_ERR_NET_IF_LINK_DOWN:                             // Ignore transitory tx err(s) [see Note #4].
      goto exit;

    default:
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      goto exit;
  }

  switch (rtn_status) {
    case NET_TCP_STATUS_NONE:
    case NET_TCP_STATUS_DATA:
      break;

    case NET_TCP_STATUS_DUP:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataDupCtr);
      goto exit;

    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  close_conn = DEF_NO;
  if (p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSED) {         // If    remote conn closed      (see Note #2e2A)  ...
                                                                // ... & local  conn close ack'd (see Note #2d2A1) ...
    if ((p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED)
        || (p_conn->TxQ_State == NET_TCP_TX_Q_STATE_CLOSED_SUSPEND)) {
      close_conn = DEF_YES;
    }
  }

  if (close_conn == DEF_YES) {
    //                                                             Closing data avail for half-closed conns ONLY.
    data_avail = ((p_conn->ConnCloseCode != NET_CONN_CLOSE_HALF)
                  || ((p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSED)
                      && (p_conn->RxQ_App_Head == DEF_NULL))) ? DEF_NO : DEF_YES;
    //                                                             ... signal app conn close (see Note #2d2A2b1);  ...
    //                                                             Ignore any app conn close err(s) [see Note #4].
    RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
    NetTCP_RxPktConnHandlerSignalClose(p_conn, data_avail, &local_err);

    if (data_avail != DEF_YES) {                                // ... & if NO app data avail,                     ...
                                                                // ... close TCP conn (see Note #2d2A1b1);         ...
      NetTCP_ConnCloseHandler(p_conn, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      rtn_status = NET_TCP_STATUS_NONE;
      goto exit;
    }
    //                                                             ... else chng to closing-data-avail state       ...
    //                                                             ... (see Note #2d2A1b2A),                       ...
    p_conn->ConnState = NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL;
    //                                                             ... & set user tmr (see Note #2d2A1b2B).
    timeout_ms = p_conn->TimeoutUser_sec * DEF_TIME_NBR_mS_PER_SEC;
  } else {                                                      // Else start time-wait tmr (see Note #3b3).
    timeout_ms = p_conn->TimeoutMaxSeg_sec * DEF_TIME_NBR_mS_PER_SEC * NET_TCP_CONN_TIMEOUT_MAX_SEG_SCALAR;
  }

  //                                                               -------------------- UPDATE TMR --------------------
  if (p_conn->TimeoutTmr != DEF_NULL) {
    NetTmr_Set(p_conn->TimeoutTmr,
               NetTCP_ConnIdleTimeout,
               timeout_ms);
  } else {
    p_conn->TimeoutTmr = NetTmr_Get(NetTCP_ConnIdleTimeout,
                                    p_conn,
                                    timeout_ms,
                                    NET_TMR_OPT_NONE,
                                    p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
    }
  }

  //                                                               --------------- TX TCP CONN ACK/DATA ---------------
  ack_code = ((p_buf_hdr->TCP_SegAckTxReqCode == NET_TCP_CONN_TX_ACK_IMMED)
              || (p_buf_hdr->TCP_SegClose == DEF_YES))          // See Note #2f3.
             ?   NET_TCP_CONN_TX_ACK_IMMED
             :   NET_TCP_CONN_TX_ACK;
  //                                                               Tx ack & any tx data (see Note #1c).
  NetTCP_TxConnTxQ(p_conn,
                   p_buf_hdr,
                   ack_code,
                   DEF_NO,
                   NET_TCP_CONN_CLOSE_ALL,
                   DEF_NO,
                   p_err);

exit:
  return(rtn_status);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerSeg()
 *
 * @brief    (1) Handle TCP connection's received segments :
 *
 *           - (a) Update TCP connection    transmit remote window                     See Note  #6
 *           - (b) Update TCP connection controls on transition to connected state(s)
 *           - (c) Handle TCP connection re-transmit queue                             See Notes #2b & #5
 *           - (d) Update TCP connection    transmit congestion controls               See Note  #7
 *           - (e) Handle TCP connection    receive  queue(s)                          See Note  #3
 *           - (f) Handle TCP connection    receive  data                              See Notes #2a & #3
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    ack_code    Indicates the received segment's acknowledgement condition :
 *
 * @param    --------   NET_TCP_CONN_RX_ACK_NONE            NO received acknowledgement number.
 *                               NET_TCP_CONN_RX_ACK_INVALID            Received acknowledgement number
 *                                                                   is invalid for the TCP connection.
 *                               NET_TCP_CONN_RX_ACK_VALID              Received acknowledgement number
 *                                                                   is   valid for the TCP connection.
 *                               NET_TCP_CONN_RX_ACK_DUP                Received acknowledgement number
 *                                                                   is a          duplicate for the
 *                                                                   TCP connection.
 *                               NET_TCP_CONN_RX_ACK_PREV               Received acknowledgement number
 *                                                                   is a previous duplicate for the
 *                                                                   TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
 *                       states that "segments are processed in sequence ... processing is done in SEG.SEQ
 *                       order" (see also Note #3).
 *
 *                           - (b) The following sections generalize that for the SYN-SENT & ESTABLISHED states that
 *                       "any segments on the retransmission queue which are ... acknowledged should be
 *                       removed" :
 *
 *                           - (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                       Check SYN Bit'
 *                           - (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                       ESTABLISHED STATE'
 *
 * @note     (3) TCP segments with receive data are sequenced into the appropriate TCP connection
 *                       receive queue(s) to be made available & ready to be read by the application layer.
 *
 *                       See also 'NetTCP_RxPktConnHandlerRxQ_Conn()     Note #3'
 *                       & 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #2'.
 *
 * @note     (4) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6 'Connection
 *                       Establishment and Keepalive Timers', Page 828 states that "when a segment is received
 *                       on a connection", TCP "resets the keepalive timer for that connection".
 *
 *                       See also 'NetTCP_TxConnKeepAliveReset()  Note #1'.
 *
 * @note     (5) A TCP connection's re-transmit queue SHOULD be updated ONLY by valid received
 *                       acknowledgement segments.
 *
 *                       See also 'NetTCP_RxPktConnHandlerReTxQ()  Note #3'.
 *
 * @note     (6) RFC #1122, Section 4.2.2.20 generalizes that "when ... SND.UNA < SEG.ACK <= SND.NXT,
 *                       the send window should be updated".
 *
 *                       See also 'NetTCP_RxPktConnHandlerTxWinRemote()  Note #1'.
 *
 * @note     (7) RFC #2581, Section 3.1 states that "the slow start and congestion avoidance algorithms
 *                       ... [update] cwnd [TCP transmit congestion control window] for each ACK received that
 *                       acknowledges new data".
 *
 *                           - (a) A TCP connection's transmit window congestion controls SHOULD be updated :
 *
 *                           - (1) After    any possible updating of the TCP connection re-transmit queue.
 *                           - (2) Prior to any possible queuing  of data segments into the TCP connection
 *                       receive queue(s).
 *
 * @note     (8) Some  transitory errors were ignored &/or not returned from previous handler function(s).
 *                       These transitory errors are included for completeness & as an extra precaution in case
 *                       these transitory errors are returned by handler function(s).
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerSeg(NET_TCP_CONN     *p_conn,
                                                 NET_TCP_ACK_CODE ack_code,
                                                 NET_BUF          *p_buf,
                                                 NET_BUF_HDR      *p_buf_hdr,
                                                 RTOS_ERR         *p_err)
{
  NET_TCP_STATUS rtn_status = NET_TCP_STATUS_INVALID;

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_LISTEN:
      rtn_status = NetTCP_RxPktConnHandlerRxQ_Sync(p_conn, p_buf, p_buf_hdr);
      goto exit;

    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
      NetTCP_RxPktConnHandlerTxWinRemote(p_conn, ack_code, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }

      NetTCP_RxPktConnHandlerCfgConn(p_conn);

      NetTCP_RxPktConnHandlerReTxQ(p_conn, ack_code, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }

      NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn, p_buf_hdr, ack_code, 0u, NET_TCP_CONN_TX_WIN_SEG_RXD, p_err);
      switch (RTOS_ERR_CODE_GET(*p_err)) {
        case RTOS_ERR_NONE:
        case RTOS_ERR_NET_IF_LINK_DOWN:
          break;

        default:
          goto exit;
      }

      rtn_status = NetTCP_RxPktConnHandlerRxQ_Conn(p_conn, p_buf, p_buf_hdr);
      break;

    case NET_TCP_CONN_STATE_SYNC_TXD:
      if (ack_code == NET_TCP_CONN_RX_ACK_VALID) {
        NetTCP_RxPktConnHandlerTxWinRemote(p_conn, ack_code, p_buf_hdr, p_err);
        if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
          goto exit;
        }

        NetTCP_RxPktConnHandlerCfgConn(p_conn);

        NetTCP_RxPktConnHandlerReTxQ(p_conn, ack_code, p_buf_hdr, p_err);
        if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
          goto exit;
        }

        NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn, p_buf_hdr, ack_code, 0u, NET_TCP_CONN_TX_WIN_SEG_RXD, p_err);
        if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
          goto exit;
        }

        rtn_status = NetTCP_RxPktConnHandlerRxQ_Conn(p_conn, p_buf, p_buf_hdr);
      } else {
        rtn_status = NetTCP_RxPktConnHandlerRxQ_Sync(p_conn, p_buf, p_buf_hdr);
      }
      break;

    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      NetTCP_TxConnKeepAliveReset(p_conn);

      if ((p_buf_hdr->TCP_SegLenData > 0u)                      // This check is added to avoid queuing data from
          && (p_conn->RxWinSizeActual == 0u)) {                 // remote host when the receive windows is 0.
                                                                // i.e. Remote stack doesn't respect RFCs.
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxPktQ_FullCtr);
        RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
        goto exit;
      }

      NetTCP_RxPktConnHandlerTxWinRemote(p_conn, ack_code, p_buf_hdr, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }

      if (p_conn->MaxSegSizeConn <= 0) {                        // Try set up again Conn if MSS was set to 0 in connect.
        NetTCP_RxPktConnHandlerCfgConn(p_conn);
      }

      switch (ack_code) {
        case NET_TCP_CONN_RX_ACK_VALID:                         // If valid ack, update re-tx Q (see Note #5).
        case NET_TCP_CONN_RX_ACK_DUP:
          NetTCP_RxPktConnHandlerReTxQ(p_conn, ack_code, p_buf_hdr, p_err);
          if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
            goto exit;
          }
          break;

        default:                                                // 'default' case intentionally empty.
          break;
      }

      NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn, p_buf_hdr, ack_code, 0u, NET_TCP_CONN_TX_WIN_SEG_RXD, p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }

      rtn_status = NetTCP_RxPktConnHandlerRxQ_Conn(p_conn, p_buf, p_buf_hdr);

      switch (rtn_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_DATA:
          break;

        case NET_TCP_STATUS_DUP:
          goto exit;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }

      NetTCP_RxPktConnHandlerRxQ_AppData(p_conn);
      break;

    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:
      rtn_status = NetTCP_RxPktConnHandlerRxQ_Conn(p_conn, p_buf, p_buf_hdr);

      switch (rtn_status) {
        case NET_TCP_STATUS_NONE:
        case NET_TCP_STATUS_VALID:
        case NET_TCP_STATUS_DATA:
          break;

        case NET_TCP_STATUS_DUP:
          goto exit;

        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
      }

      NetTCP_RxPktConnHandlerRxQ_AppData(p_conn);
      break;

    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    case NET_TCP_CONN_STATE_CLOSED:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, NET_TCP_STATUS_INVALID);
  }

exit:
  return (rtn_status);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerCfgConn()
 *
 * @brief    (1) Configure TCP connection's controls on transition to connected state(s) :
 *
 *           - (a) Configure TCP connection maximum segment size control(s)
 *           - (b) Configure TCP connection window size controls
 *
 *
 * Argument(s) : p_conn       Pointer to a TCP connection.
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) During TCP connection initialization, some TCP connection controls were previously
 *                   configured in NetTCP_ConnGet() when the TCP connection was allocated from the TCP
 *                   connection pool.  These TCP connection controls do NOT need to be reconfigured
 *                   but are shown for completeness.
 *******************************************************************************************************/
static void NetTCP_RxPktConnHandlerCfgConn(NET_TCP_CONN *p_conn)
{
  NET_TCP_CFG_CODE cfg_code;

  //                                                               Cfg conn (see Note #1).
  cfg_code = NET_TCP_CONN_CFG_NONE
             | NET_TCP_CONN_CFG_MAX_SEG_SIZE_CONN
             | NET_TCP_CONN_CFG_WIN_SIZE_ALL;
  NetTCP_ConnCfg(p_conn, cfg_code);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerRxQ_Sync()
 *
 * @brief    (1) (a) Handle TCP connection's transport receive queue ... :
 *
 *               - (1) Update TCP connection initial receive sequence numbers          See Note #2b
 *               - (2) Queue  received TCP segments into transport receive queue       See Note #3
 *               - (3) Update TCP connection receive window
 *
 *           - (b) ... for the following connection-request/synchronization states :
 *
 *               - (1) LISTEN
 *               - (2) SYN-SENT
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @note     (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
 *                       states that "segments are processed in sequence ... processing is done in SEG.SEQ
 *                       order."
 *
 *                           - (b) The following sections generalize that for the LISTEN & SYN-SENT states that "if the
 *                       SYN bit is on and ... acceptable then ... RCV.NXT is set to SEG.SEQ+1, IRS is set to
 *                       SEG.SEQ" :
 *
 *                           - (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN   [State] :
 *                       Check for SYN'
 *                           - (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                       Check SYN Bit'
 *
 *                           - (c) (1) The following sections generalize that for the LISTEN & SYN-SENT states that "if
 *                       there are other controls or text in the segment, queue them for later processing
 *                       after the ESTABLISHED state has been reached" :
 *
 *                           - (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN   [State] :
 *                       Check for SYN'
 *                           - (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                       Check SYN Bit'
 *
 *                           - (2) If any control or text is queued for later processing, the next sequence octet to
 *                       receive (RCV.NXT) MUST include the length of this received segment (SEG.LEN) :
 *
 *                           - (A) RCV.NXT = SEG.SEQ + SEG.LEN + 1
 *
 * @note     (3) TCP segments with receive data are sequenced into the appropriate TCP connection
 *                       receive queue(s) to be made available & ready to be read by the application layer.
 *
 *                       See also 'NetTCP_RxPktConnHandlerRxQ_Conn()     Note #3'
 *                       & 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #2'.
 *
 * @note     (4) Some buffer controls were previously initialized in NetBuf_Get() when the buffer was
 *                       allocated.  These buffer controls do NOT need to be re-initialized but are shown for
 *                       completeness.
 *
 * @note     (5) RFC #793, Section 3.7 'Data Communication : Managing the Window' states that "the window
 *                       sent in each segment indicates the range of sequence numbers the sender of the window
 *                       (the data receiver) is currently prepared to accept.  There is an assumption that this
 *                       is related to the currently available data buffer space available for this connection
 *                       ... One strategy would be to ... [update the] information when the window" changes.
 *
 *                       See also 'NetTCP_RxAppData()                 Note #6',
 *                       'NetTCP_RxPktConnHandlerRxQ_Conn()  Note #6',
 *                       & 'NetTCP_RxConnWinSizeHandler()      Note #2a'.
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerRxQ_Sync(NET_TCP_CONN *p_conn,
                                                      NET_BUF      *p_buf,
                                                      NET_BUF_HDR  *p_buf_hdr)
{
  NET_TCP_SEG_SIZE seg_len_data;
  NET_TCP_STATUS   rtn_val = NET_TCP_STATUS_INVALID;

  //                                                               Update TCP conn rx seq nbrs (see Notes #2b & #2c2).
  p_conn->RxSeqNbrSync = p_buf_hdr->TCP_SeqNbr;
  p_conn->RxSeqNbrNext = (p_buf_hdr->TCP_SeqNbr + p_buf_hdr->TCP_SegLen);
  p_conn->RxQ_State = NET_TCP_RX_Q_STATE_SYNC;

  seg_len_data = p_buf_hdr->TCP_SegLenData;
  if (seg_len_data > 0) {                                       // If rx'd seg len data > 0, ...
                                                                // ... Q seg to TCP conn rx Q  (see Notes #3 & #2c1).
    NetTCP_ConnFreeBufQ(&p_conn->RxQ_Transport_Head, &p_conn->RxQ_Transport_Tail);

    p_conn->RxQ_Transport_Head = p_buf;
    p_conn->RxQ_Transport_Tail = p_buf;

    //                                                             Dec TCP conn's rx win size (see Note #5).
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
    NetTCP_RxConnWinSizeHandler(p_conn, p_buf_hdr, seg_len_data, NET_TCP_CONN_RX_WIN_DEC);
#else
    NetTCP_RxConnWinSizeHandler(p_conn, p_buf_hdr, 1, NET_TCP_CONN_RX_WIN_DEC);
#endif
    rtn_val = NET_TCP_STATUS_DATA;
  } else {
    rtn_val = NET_TCP_STATUS_NONE;
  }

  return (rtn_val);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerRxQ_Conn()
 *
 * @brief    (1) (a) Handle TCP connection's transport receive queue ... :
 *
 *               - (1) Update TCP connection receive sequence numbers          See Notes #2c  & #2e
 *               - (2) Insert received TCP segments in sequence order          See Notes #3   & #4
 *               - (3) Update TCP connection receive window
 *
 *           - (b) ... for the following connected states :
 *
 *               - (1) SYN-RECEIVED                                            See Notes #1bA & #2b2
 *               - (2) SYN-SENT                                                See Notes #1bA & #2b1
 *               - (3) ESTABLISHED                                             See Note  #1bB
 *               - (4) FIN-WAIT-1                                              See Note  #1bB
 *               - (5) FIN-WAIT-2                                              See Note  #1bB
 *               - (6) CLOSING                                                 See Note  #1bC
 *               - (7) TIME-WAIT                                               See Note  #1bC
 *               - (8) CLOSE-WAIT                                              See Note  #1bC
 *               - (9) LAST-ACK                                                See Note  #1bC
 *
 *                   - (A) For synchronization-to-connected state transitions, segments are queued to
 *                           the TCP connection's transport receive queue, but NOT to the TCP connection's
 *                           application receive queue, until the application layer is signaled that the
 *                           transport layer connection is complete.
 *
 *                           See also 'NetTCP_RxPktConnHandlerSyncRxd()  Note #1c1'
 *                                   & 'NetTCP_RxPktConnHandlerSyncTxd()  Note #1c1'.
 *
 *                   - (B) For connected states,       segments are queued to the TCP connection's
 *                           transport &/or application receive queue(s) as appropriate (see Note #3).
 *
 *                   - (C) For closing states; closing segments are queued to the TCP connection's
 *                           transport &/or application receive queue(s) as for connected states.
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf       Pointer to network buffer that received TCP packet.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @note     (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence Number'
 *                       states that :
 *
 *                           - (1) "Segments are processed in sequence ... processing is done in SEG.SEQ order."
 *
 *                           - (A) Assumes received segment's sequences previously validated.
 *
 *                           - (2) "Initial tests on arrival are used to discard old duplicates."
 *
 *                           - (3) (A) (1) "If a segment's contents straddle the boundary between old and new,
 *                       only the new parts should be processed."
 *
 *                           - (2) "One could tailor actual segments to ... the idealized segment that
 *                       begins at RCV.NXT and does not exceed the window ... by trimming off
 *                       any portions that lie outside the window (including SYN and FIN),
 *                       and only processing further if the segment then begins at RCV.NXT.
 *                       Segments with higher beginning sequence numbers may be held for later
 *                       processing."
 *
 *                           - (B) (1) Sequencing     received segments with duplicate data that overlaps
 *                       multiple previously-received segments' non-contiguous sequence numbers
 *                       is data intensive/expensive.
 *
 *                           - (2) Therefore, any received segment  with duplicate data that overlaps
 *                       multiple previously-received segments' non-contiguous sequence numbers
 *                       is trimmed of duplicate data starting from the end of the received
 *                       segment's data.
 *
 *                       In other words, only the first contiguous, non-duplicate data sequence
 *                       starting from the start of the received segment's data is sequenced
 *                       into the TCP connection's receive queue(s).
 *
 *                           - (C) RFC #1122, Section 4.2.2.20 states that "a TCP SHOULD be capable of queueing
 *                       out-of-order TCP segments".
 *
 *                           - (b) The following sections generalize that in the "SYN-SENT [or] ... SYN-RECEIVED
 *                       STATE[s], ... [that] if the ACK bit is on [and] our SYN has been ACKed ...
 *                       then enter the ESTABLISHED state and continue processing" :
 *
 *                           - (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                       Check SYN Bit'
 *                           - (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                       SYN-RECEIVED STATE'
 *
 *                           - (c) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                       Check SYN Bit' states that "if the SYN bit is on and ... acceptable then ...
 *                       RCV.NXT is set to SEG.SEQ+1, IRS is set to SEG.SEQ".
 *
 *                           - (d) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                       Check SYN Bit' states that "if there are other controls or text in the segment,
 *                       queue them for later processing after the ESTABLISHED state has been reached"
 *                       (see also Note #2b).
 *
 *                           - (2) If any control or text is queued for later processing, the next sequence octet to
 *                       receive (RCV.NXT) MUST include the length of this received segment (SEG.LEN) :
 *
 *                           - (A) RCV.NXT = SEG.SEQ + SEG.LEN + 1
 *
 *                           - (e) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
 *                       that "if the FIN bit is set ... advance RCV.NXT over the FIN".
 *
 *                           - (2) However, the next octet to receive is NOT updated with the sequence number of the
 *                       last octet to receive.  Instead, the generic sequence algorithm maintains & updates
 *                       BOTH the next & last octets to receive for the closing TCP connection.
 *
 * @note     (3) TCP segments with receive data are sequenced first into the TCP connection's transport
 *                       receive queue to be made available & ready to be read by the application layer from the
 *                       TCP connection's application receive queue (see 'NetTCP_RxPktConnHandlerRxQ_AppData()
 *                       Note #2').
 *
 *                           - (a) Received TCP segments are inserted into a doubly-linked Transport Receive Queue,
 *                       sorted by their sequence number(s).
 *
 *                       In the diagram below, ... :
 *
 *                           - (1) (A) TCP connections' 'RxQ_Transport_Head' points to the head of a TCP connections'
 *                       Transport Receive Queue;
 *                           - (B) TCP connections' 'RxQ_Transport_Tail' points to the tail of a TCP connections'
 *                       Transport Receive Queue.
 *
 *                           - (2) Segment buffers' 'PrevPrimListPtr' & 'NextPrimListPtr'  doubly-link each
 *                       segment to form the Transport Receive Queue.
 *
 *                           - (3) Fragmented segment buffer's 'PrevBufPtr' & 'NextBufPtr' doubly-link each
 *                       fragmented segment (see also 'net_ip.c  NetIP_RxPktFragReasm()  Note #2b1E').
 *
 *                           - (b) (1) Typically & most-frequently, TCP segments will be received in sequence-order.
 *                       Therefore, the sequence sort algorithm starts at the tail of the Transport
 *                       Receive Queue.
 *
 *                           - (2) As segments are inserted into the Transport Receive Queue, segments migrate to
 *                       the head of the Transport Receive Queue.  Queued segments with sequence numbers
 *                       that are contiguous from the next expected receive sequence number are ready to
 *                       be read by the application layer, so are immediately moved from the Transport
 *                       Receive Queue to the Application Receive Queue.
 *
 *                       See also 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #2'.
 *
 *                                    |                                               |
 *                                    |<-- TCP Connection Transport Receive Queue --->|
 *                                    |                (see Note #3)                  |
 *
 *                                Segments Moved                           Segments Sequenced
 *                                to Application                             into Transport
 *                                Receive Queue                              Receive Queue
 *                                starting at head                           starting at tail
 *                                (see Note #3b2)                            (see Note #3b1)
 *
 *                                         |        NextPrimListPtr                  |
 *                                         |        (see Note #3a2)                  |
 *                                         v                   |                     v
 *                                                             |
 *                        Head of       -------       -------  v    -------       -------   (see Note #3a1B)
 *                        Receive  ---->|     |------>|     |------>|     |------>|     |
 *                         Queue        |     |       |     |       |     |       |     |       Tail of
 *                                      |     |<------|     |<------|     |<------|     |<----  Receive
 *                   (see Note #3a1A)   |     |       |     |  ^    |     |       |     |        Queue
 *                                      |     |       |     |  |    |     |       |     |
 *                                      -------       -------  |    -------       -------
 *                                        | ^                  |      | ^
 *                                        | |       PrevPrimListPtr   | |
 *                                        v |       (see Note #3a2)   v |
 *                                      -------                     -------
 *                                      |     |                     |     |
 *                                      |     |                     |     |
 *                                      |     |                     |     |
 *                                      |     |                     |     |
 *                                      |     |                     |     |
 *                                      -------                     -------
 *                                        | ^                         | ^
 *                        NextBufPtr ---> | | <--- PrevBufPtr         | |
 *                     (see Note #3a3)    v |   (see Note #3a3)       v |
 *                                      -------                     -------
 *                                      |     |                     |     |
 *                                      |     |                     |     |
 *                                      |     |                     -------
 *                                      |     |
 *                                      |     |
 *                                      -------
 *
 * @note     (4) RFC #793 does NOT provide nor suggest any logic to determine/handle sequence number
 *                       comparisons for sequence number windows that overflow the sequence number space.
 *
 *                           - (a) For example, the next sequence octet to receive (RCV.NXT) is typically less than
 *                       or equal to  the next received sequence octet (SEG.SEQ) :
 *
 *                           - (1) RCV.NXT <= SEG.SEQ
 *
 *                       SEG.SEQ itself is also typically less than RCV.NXT plus the current receive window
 *                       size (RCV.WND) :
 *
 *                           - (2) SEG.SEQ <  RCV.NXT + RCV.WND
 *
 *                       However, if (RCV.NXT + RCV.WND) or SEG.SEQ overflows the sequence number space,
 *                       these values will be MUCH less than SEG.SEQ or RCV.NXT, respectively, until
 *                       SEG.SEQ & RCV.NXT also overflow :
 *
 *                           - (3) RCV.NXT + RCV.WND << RCV.NXT
 *                       << SEG.SEQ
 *
 *                           - (4) SEG.SEQ           << RCV.NXT
 *
 *                           - (b) Therefore, in order to determine if a received segment's sequence value precedes any
 *                       previously received segment(s) in the TCP connection's receive queue(s), the following
 *                       unsigned arithmetic comparisons MUST be checked :
 *
 *                           - (1) RxQCur.SeqNbr - (SEG.SEQ + 1)  <   RX.WIN
 *
 *                           - (2)     RX.NXT    - (SEG.SEQ + 1)  <  SEG.LEN
 *
 *                       Note that these comparisons bound any received segment's sequence within limits set
 *                       by the TCP connection's receive window size & next expected receive octet.
 *
 *                           - (c) In order to determine if a received segment's sequence value overlaps any previously
 *                       received segment(s) in the TCP connection's receive queue, the following unsigned
 *                       arithmetic comparisons MUST be checked :
 *
 *                           - (1) (   SEG.SEQ    +    SEG.LEN   )  -  (RxQNext.SeqNbr + 1)  <     SEG.LEN
 *
 *                           - (2) (RxQCur.SeqNbr + RxQCur.SegLen)  -  (SEG.SEQ        + 1)  <  RxQCur.SegLen
 *
 *                       See also 'NetTCP_RxPktConnIsValidSeq()  Note #2'.
 *
 * @note     (5) (a) RFC #2581, Section 3.2 states that "a TCP receiver SHOULD send an immediate ACK" :
 *
 *                           - (1) "When an out-of-order segment arrives.  The purpose of this ACK is to inform
 *                       the sender that a segment was received out-of-order and which sequence number
 *                       is expected."
 *
 *                           - (2) "In addition, ... when the incoming segment fills in all or part of a gap in
 *                       the sequence space."
 *
 *                       See also 'NetTCP_TxConnAck()  Note #4a5'.
 *
 *                           - (b) Since segments are typically received in sequence order (see Notes #5a1 & #3b1) &
 *                       since segments received in sequential order are immediately made available & ready
 *                       to be read by the application layer (see Note #3b2), received segments are out-of-
 *                       order AND/OR fill in sequence number gaps whenever :
 *
 *                           - (1) A TCP connection's Transport Receive Queue is initially non-empty;
 *                       OR
 *                           - (2) A TCP connection's Transport Receive Queue's head segment's sequence number
 *                       does NOT equal the TCP connection's next expected receive   sequence number.
 *
 *                           - (c) However, since a TCP connection's next expected receive sequence numbers are NOT
 *                       updated until both of the TCP connection's transport & application receive queues
 *                       have been handled (see 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #1a3'), the
 *                       transmission of any immediate acknowledgement MUST follow the handling of BOTH
 *                       of the TCP connection's receive queues.
 *
 *                       See also 'NetTCP_RxPktConnHandlerRxQ_AppData()  Notes #1a3 & #4'.
 *
 * @note     (6) RFC #793, Section 3.7 'Data Communication : Managing the Window' states that "the window
 *                       sent in each segment indicates the range of sequence numbers the sender of the window
 *                       (the data receiver) is currently prepared to accept.  There is an assumption that this
 *                       is related to the currently available data buffer space available for this connection
 *                       ... One strategy would be to ... [update the] information when the window" changes.
 *
 *                       See also 'NetTCP_RxAppData()                 Note #6',
 *                       'NetTCP_RxPktConnHandlerRxQ_Sync()  Note #5',
 *                       & 'NetTCP_RxConnWinSizeHandler()      Note #2a'.
 *******************************************************************************************************/
static NET_TCP_STATUS NetTCP_RxPktConnHandlerRxQ_Conn(NET_TCP_CONN *p_conn,
                                                      NET_BUF      *p_buf,
                                                      NET_BUF_HDR  *p_buf_hdr)
{
  NET_BUF         *p_buf_q;
  NET_BUF         *p_buf_q_head;
  NET_BUF         *p_buf_q_prev;
  NET_BUF         *p_buf_q_next;
  NET_BUF_HDR     *p_buf_q_hdr;
  NET_BUF_HDR     *p_buf_q_hdr_head;
  NET_BUF_HDR     *p_buf_q_hdr_next;
  NET_TCP_SEQ_NBR seq_nbr;
  NET_TCP_SEQ_NBR seq_nbr_next;
  NET_TCP_SEQ_NBR seq_nbr_dup;
  NET_TCP_SEQ_NBR seq_nbr_delta;
  NET_TCP_SEQ_NBR seq_nbr_win;
  NET_TCP_STATUS  data_status = NET_TCP_STATUS_INVALID;
  CPU_BOOLEAN     seq_srch_done;
  CPU_BOOLEAN     seq_unordered_prev;
  CPU_BOOLEAN     seq_unordered_cur;
  CPU_BOOLEAN     seq_unordered;

  //                                                               ----------- UPDATE TCP CONN RX SEQ NBRS ------------
  if (p_conn->ConnState == NET_TCP_CONN_STATE_SYNC_TXD) {
    //                                                             Init SYN-SENT state (see Notes #2c & #2d2).
    p_conn->RxSeqNbrSync = (NET_TCP_SEQ_NBR) p_buf_hdr->TCP_SeqNbr;
    p_conn->RxSeqNbrNext = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + p_buf_hdr->TCP_SegLen);
    p_conn->RxQ_State = NET_TCP_RX_Q_STATE_SYNC;
  } else {
    switch (p_conn->RxQ_State) {
      case NET_TCP_RX_Q_STATE_SYNC:
        break;

      case NET_TCP_RX_Q_STATE_CONN:
        //                                                         Chk TCP conn closing (see Note #2e).
        if (p_buf_hdr->TCP_SegClose == DEF_YES) {
          p_conn->RxSeqNbrLast = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + p_buf_hdr->TCP_SegLen);
          p_conn->RxSeqNbrClose = (NET_TCP_SEQ_NBR)(p_conn->RxSeqNbrLast  - NET_TCP_SEG_LEN_CLOSE);
          p_conn->RxQ_State = NET_TCP_RX_Q_STATE_CLOSING;
        }
      //                                                           'break' intentionally omitted; MUST execute the ..
      //                                                           .. following case : 'NET_TCP_RX_Q_STATE_CLOSED'.
      //                                                           fallthrough

      case NET_TCP_RX_Q_STATE_CLOSED:
      case NET_TCP_RX_Q_STATE_CLOSING:
        break;

      case NET_TCP_RX_Q_STATE_NONE:
      default:
        data_status = NET_TCP_STATUS_INVALID;
        RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, NET_TCP_STATUS_INVALID);
    }
  }

  if (p_buf_hdr->TCP_SegLenData < 1) {                          // If seg data len < 1,             AND ...
                                                                // ... NOT in rx conn closing state OR  ...
    if ((p_conn->RxQ_State != NET_TCP_RX_Q_STATE_CLOSING)
        || (p_buf_hdr->TCP_SegClose != DEF_YES)) {              // ... fin/close NOT rx'd;              ...
      data_status = NET_TCP_STATUS_NONE;                        // ... rtn data  NOT avail.
      goto exit;
    }                                                           // Else seq & handle closing-ctrl seg.
  }

  //                                                               ------- INSERT SEG INTO SEQ'D TRANSPORT RX Q -------
  p_buf_q = (NET_BUF *)p_conn->RxQ_Transport_Tail;              // Start seq insert alg from rx Q tail (see Note #3b1).
  p_buf_q_next = DEF_NULL;
  seq_srch_done = DEF_NO;
  //                                                               Chk init'l rx Q seq order (see Note #5b1).
  seq_unordered_prev = (p_conn->RxQ_Transport_Head != DEF_NULL)
                       ?  DEF_YES : DEF_NO;

  while (seq_srch_done == DEF_NO) {                             // Srch rx Q to insert rx'd seg into seq nbr position.
    if (p_buf_q != DEF_NULL) {                                  // While NOT @ rx Q head, chk if seg ...
      p_buf_q_hdr = (NET_BUF_HDR *)&p_buf_q->Hdr;
      p_buf_q_prev = (NET_BUF *) p_buf_q_hdr->PrevPrimListPtr;
      //                                                           ... before or after cur  rx Q seg (see Note #2a1).
      seq_nbr_next = (NET_TCP_SEQ_NBR) p_buf_q_hdr->TCP_SeqNbr;
      seq_nbr = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr   + 1u);
      seq_nbr_delta = (NET_TCP_SEQ_NBR)(seq_nbr_next           - seq_nbr);
      seq_nbr_win = (NET_TCP_SEQ_NBR) p_conn->RxWinSizeCfgd;

      if (seq_nbr_delta < seq_nbr_win) {                        // If seg's seq nbr < cur rx Q's seq nbr (see Note #4b1)
                                                                // ... adv to prev rx Q seg; but chk ...
                                                                // ... for dup seqs in next rx Q seg.
        seq_nbr_next = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr   + p_buf_hdr->TCP_SegLen);
        seq_nbr = (NET_TCP_SEQ_NBR)(p_buf_q_hdr->TCP_SeqNbr + 1u);
        seq_nbr_delta = (NET_TCP_SEQ_NBR)(seq_nbr_next           - seq_nbr);
        seq_nbr_win = (NET_TCP_SEQ_NBR) p_buf_hdr->TCP_SegLen;

        if (seq_nbr_delta < seq_nbr_win) {                      // If seg overlaps next rx Q seqs (see Note #4c1), ...
          seq_nbr_dup = seq_nbr_delta + 1u;                     // ... trim dup seqs from seg     (see Note #2a3); ...
          if (p_buf_hdr->TCP_SegLenData > (NET_TCP_SEG_SIZE)seq_nbr_dup) {
            p_buf_hdr->TCP_SegLenData -= (NET_TCP_SEG_SIZE)seq_nbr_dup;
            p_buf_hdr->TCP_SegLen -= (NET_TCP_SEG_SIZE)seq_nbr_dup;
          } else {                                              // ... else discard ALL dup seqs  (see Note #2a2).
            data_status = NET_TCP_STATUS_DUP;
            goto exit;
          }
        }
        //                                                         Adv to prev rx Q seg.
        p_buf_q_next = p_buf_q;
        p_buf_q = p_buf_q_prev;
      } else {                                                  // Else insert seg between cur/next rx Q segs.
                                                                // Chk for dup seqs in cur rx Q seg.
        seq_nbr_next = (NET_TCP_SEQ_NBR)(p_buf_q_hdr->TCP_SeqNbr + p_buf_q_hdr->TCP_SegLen);
        seq_nbr = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr   + 1u);
        seq_nbr_delta = (NET_TCP_SEQ_NBR)(seq_nbr_next           - seq_nbr);
        seq_nbr_win = (NET_TCP_SEQ_NBR) p_buf_q_hdr->TCP_SegLen;

        if (seq_nbr_delta < seq_nbr_win) {                      // If seg overlaps prev'ly rx'd seqs (see Note #4c2),
          seq_nbr_dup = seq_nbr_delta + 1u;                     // ... trim dup seqs from seg    (see Note #2a3); ...
          if (p_buf_hdr->TCP_SegLenData > (NET_TCP_SEG_SIZE)seq_nbr_dup) {
            p_buf_hdr->TCP_SegLenData -= (NET_TCP_SEG_SIZE)seq_nbr_dup;
            p_buf_hdr->TCP_SegLen -= (NET_TCP_SEG_SIZE)seq_nbr_dup;
            p_buf_hdr->TCP_SeqNbr = (NET_TCP_SEQ_NBR)seq_nbr_next;
          } else {                                              // ... else discard ALL dup seqs (see Note #2a2).
            data_status = NET_TCP_STATUS_DUP;
            goto exit;
          }
        }

        seq_srch_done = DEF_YES;
      }
    } else {                                                    // Else if @ head of rx Q, entire rx Q srch'd; ...
                                                                // ... chk for dup seqs prior to TCP conn's    ...
                                                                // ... next expected rx octet.
      seq_nbr_next = (NET_TCP_SEQ_NBR) p_conn->RxSeqNbrNext;
      seq_nbr = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + 1u);
      seq_nbr_delta = (NET_TCP_SEQ_NBR)(seq_nbr_next         - seq_nbr);
      seq_nbr_win = (NET_TCP_SEQ_NBR) p_buf_hdr->TCP_SegLen;

      if (seq_nbr_delta < seq_nbr_win) {                        // If seg overlaps prev'ly rx'd seqs (see Note #4b2),
        seq_nbr_dup = seq_nbr_delta + 1u;                       // ... trim dup seqs from seg    (see Note #2a3),
        if (p_buf_hdr->TCP_SegLenData > (NET_TCP_SEG_SIZE)seq_nbr_dup) {
          p_buf_hdr->TCP_SegLenData -= (NET_TCP_SEG_SIZE)seq_nbr_dup;
          p_buf_hdr->TCP_SegLen -= (NET_TCP_SEG_SIZE)seq_nbr_dup;
          p_buf_hdr->TCP_SeqNbr = (NET_TCP_SEQ_NBR)seq_nbr_next;
        } else {                                                // ... else discard ALL dup seqs (see Note #2a2).
          data_status = NET_TCP_STATUS_DUP;
          goto exit;
        }
      }

      seq_srch_done = DEF_YES;
    }
  }

  //                                                               Insert rx'd seg between cur/next rx Q segs.
  p_buf_hdr->PrevPrimListPtr = p_buf_q;
  if (p_buf_q != DEF_NULL) {                                    // If avail, insert rx'd seg after  cur  rx Q seg.
    p_buf_q_hdr->NextPrimListPtr = p_buf;
  } else {                                                      // Else      insert rx'd seg @ rx Q head.
    p_conn->RxQ_Transport_Head = p_buf;
  }

  p_buf_hdr->NextPrimListPtr = p_buf_q_next;
  if (p_buf_q_next != DEF_NULL) {                               // If avail, insert rx'd seg before next rx Q seg.
    p_buf_q_hdr_next = &p_buf_q_next->Hdr;
    p_buf_q_hdr_next->PrevPrimListPtr = p_buf;
  } else {                                                      // Else      insert rx'd seg @ rx Q tail.
    p_conn->RxQ_Transport_Tail = p_buf;
  }

  //                                                               Chk rx'd out-of-order seg(s) [see Note #5a].
  if (p_conn->RxQ_Transport_Head != DEF_NULL) {
    p_buf_q_head = p_conn->RxQ_Transport_Head;
    p_buf_q_hdr_head = &p_buf_q_head->Hdr;
    //                                                             Chk cur rx Q seq order       (see Note #5b2).
    seq_unordered_cur = (p_buf_q_hdr_head->TCP_SeqNbr
                         != p_conn->RxSeqNbrNext)    ? DEF_YES : DEF_NO;
  } else {
    seq_unordered_cur = DEF_NO;
  }

  seq_unordered = ((seq_unordered_prev == DEF_YES)
                   || (seq_unordered_cur == DEF_YES)) ? DEF_YES : DEF_NO;

  if (seq_unordered != DEF_NO) {                                // If out-of-order seg(s) rx'd   (see Note #5a) ...
    if (p_conn->RxQ_State != NET_TCP_RX_Q_STATE_SYNC) {         // ... in non-sync state,                       ...
                                                                // ... req immed TCP conn ack tx (see Note #5c).
      p_buf_hdr->TCP_SegAckTxReqCode = NET_TCP_CONN_TX_ACK_IMMED;
    }
  }

  //                                                               ----------- UPDATE TCP CONN RX WIN SIZE ------------
  //                                                               Dec TCP conn's rx win size (see Note #6).
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
  NetTCP_RxConnWinSizeHandler(p_conn, p_buf_hdr, p_buf_hdr->TCP_SegLenData, NET_TCP_CONN_RX_WIN_DEC);
#else
  NetTCP_RxConnWinSizeHandler(p_conn, p_buf_hdr, 1, NET_TCP_CONN_RX_WIN_DEC);
#endif

  data_status = NET_TCP_STATUS_DATA;

exit:
  return (data_status);
}

/****************************************************************************************************//**
 *                                   NetTCP_RxPktConnHandlerRxQ_AppData()
 *
 * @brief    (1) (a) Handle TCP connection's application receive queue ... :
 *
 *               - (1) Remove segments from  TCP connection's transport   receive queue    See Note #3b1B
 *               - (2) Update TCP connection transport receive queue
 *               - (3) Update TCP connection receive sequence numbers
 *               - (4) Move   segments into  TCP connection's application receive queue    See Note #2
 *               - (5) Update TCP connection receive window                                See Note #6
 *
 *           - (b) ... for the following connected states :
 *
 *               - (1) SYN-RECEIVED                                                        See Note #1bA
 *               - (2) SYN-SENT                                                            See Note #1bA
 *               - (3) ESTABLISHED                                                         See Note #1bB
 *               - (4) FIN-WAIT-1                                                          See Note #1bB
 *               - (5) FIN-WAIT-2                                                          See Note #1bB
 *               - (6) CLOSING                                                             See Note #1bC
 *               - (7) TIME-WAIT                                                           See Note #1bC
 *               - (8) CLOSE-WAIT                                                          See Note #1bC
 *               - (9) LAST-ACK                                                            See Note #1bC
 *
 *                   - (A) For synchronization-to-connected state transitions, segments are queued to
 *                           the TCP connection's transport receive queue, but NOT to the TCP connection's
 *                           application receive queue, until the application layer is signaled that the
 *                           transport layer connection is complete.
 *
 *                           See also 'NetTCP_RxPktConnHandlerSyncRxd()  Note #1c1'
 *                                   & 'NetTCP_RxPktConnHandlerSyncTxd()  Note #1c1'.
 *
 *                   - (B) For connected states, segments are queued to the TCP connection's application
 *                           receive queue as appropriate (see Notes #2 & #3b).
 *
 *                   - (C) For closing states; closing segments are queued to the TCP connection's
 *                           transport &/or application receive queue(s) as for connected states.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (2) TCP segments with receive data that are available & ready to be read by the application
 *                   layer are linked in a TCP connection's application receive queue.
 *
 *                       - (a) Received TCP segments are moved from the doubly-linked Transport Receive Queue,
 *                   sorted by their sequence number(s), into the Application Receive Queue.
 *
 *                   In the diagram below, ... :
 *
 *                       - (1) (A) TCP connections' 'RxQ_App_Head' points to the head of a TCP connections'
 *                   Application Receive Queue;
 *                       - (B) TCP connections' 'RxQ_App_Tail' points to the tail of a TCP connections'
 *                   Application Receive Queue.
 *
 *                       - (2) Segment buffers' 'PrevPrimListPtr' & 'NextPrimListPtr'  doubly-link each
 *                   segment to form the Application Receive Queue.
 *
 *                       - (3) Fragmented segment buffer's 'PrevBufPtr' & 'NextBufPtr' doubly-link each
 *                   fragmented segment (see also 'net_ip.c  NetIP_RxPktFragReasm()  Note #2b1E').
 *
 *                       - (b) (1) TCP segments are appended in sequence order from the head of a TCP connection's
 *                   Transport Receive Queue to the tail of the TCP connection's Application Receive
 *                   Queue.
 *
 *                   See also 'NetTCP_RxPktConnHandlerRxQ_Conn()  Note #3'.
 *
 *                       - (2) Application data is read from segments starting from the head of the Application
 *                   Receive Queue.  Segments that are read by the application layer are removed from
 *                   the Application Receive Queue.
 *
 *                                         |                                               |
 *                                         |<- TCP Connection Application Receive Queue -->|
 *                                         |                (see Note #2)                  |
 *
 *                                    Segments Read by                         Segments Appended to
 *                                    Application Layer                      Application Receive Queue
 *                                    starting at head                           starting at tail
 *                                    (see Note #2b2)                            (see Note #2b1)
 *
 *                                            |        NextPrimListPtr                  |
 *                                            |        (see Note #2a2)                  |
 *                                            v                   |                     v
 *                                                                |
 *                           Head of       -------       -------  v    -------       -------  (see Note #2a1B)
 *                           Receive  ---->|     |------>|     |------>|     |------>|     |
 *                            Queue        |     |       |     |       |     |       |     |       Tail of
 *                                         |     |<------|     |<------|     |<------|     |<----  Receive
 *                      (see Note #2a1A)   |     |       |     |  ^    |     |       |     |        Queue
 *                                         |     |       |     |  |    |     |       |     |
 *                                         -------       -------  |    -------       -------
 *                                           | ^                  |      | ^
 *                                           | |       PrevPrimListPtr   | |
 *                                           v |       (see Note #2a2)   v |
 *                                         -------                     -------
 *                                         |     |                     |     |
 *                                         |     |                     |     |
 *                                         |     |                     |     |
 *                                         |     |                     |     |
 *                                         |     |                     |     |
 *                                         -------                     -------
 *                                           | ^                         | ^
 *                           NextBufPtr ---> | | <--- PrevBufPtr         | |
 *                        (see Note #2a3)    v |   (see Note #2a3)       v |
 *                                         -------                     -------
 *                                         |     |                     |     |
 *                                         |     |                     |     |
 *                                         |     |                     -------
 *                                         |     |
 *                                         |     |
 *                                         -------
 *
 * @note     (3) (a) (1) RFC #793, Section 3.8 'Interfaces : User/TCP Interface : TCP User Commands :
 *                   Receive' states that :
 *
 *                       - (A) "If enough data arrive [sic] to fill the buffer before a PUSH is seen,
 *                   the PUSH flag will not be set in the response to the RECEIVE.  The
 *                   buffer will be filled with as much data as it can hold."
 *
 *                       - (B) "If the PUSH is seen before the buffer is filled the buffer will be
 *                   returned partially filled and PUSH indicated."
 *
 *                   See Notes #3b1B & #3b1B.
 *
 *                       - (2) RFC #1122, Section 4.2.2.2 states that :
 *
 *                       - (A) (1) "At the receiver, the PSH bit forces buffered data to be delivered to
 *                   the application (even if less than a full buffer has been received)."
 *
 *                       - (2) (a) "Conversely, the lack of a PSH bit can be used to avoid unnecessary
 *                   wakeup calls to the application process; this can be an important
 *                   performance optimization for large timesharing hosts."
 *
 *                       - (b) "When a series of segments is received without the PSH bit, a TCP
 *                   MAY queue the data internally without passing it to the receiving
 *                   application."
 *
 *                       - (B) (1) "Passing the PSH bit to the receiving application allows an ...
 *                   optimization within the application."
 *
 *                       - (2) "RFC-793 ... erroneously implies that a received PSH flag must be passed
 *                   to the application layer.  Passing a received PSH flag to the application
 *                   layer is now OPTIONAL."
 *
 *                       - (C) "The PSH bit is not a record marker and is independent of segment boundaries."
 *
 *                       - (b) (1) (A) (1) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 20.5, Page 284
 *                   states that "Berkeley-derived implementations ignore a received PUSH flag
 *                   because they normally never delay the delivery of received data to the
 *                   application".
 *
 *                       - (2) Therefore, for TCP connections in any connected state, received TCP segment
 *                   data is made available to the application receive queue as soon as it is
 *                   enqueued to the application receive queue.
 *
 *                       - (B) Thus for TCP connections in any connected state, TCP segments are moved from
 *                   a TCP connection's transport receive queue to its application receive queue
 *                   whenever the transport receive queue's enqueued TCP segments are consecutively
 *                   sequenced starting from the TCP connection's next expected receive octet.
 *
 *                       - (2) Thus TCP application-receive PUSH feature is obsoleted & NOT implemented.
 *
 *                   See also 'NetTCP_TxConnAck()  Note #4a4'.
 *
 * @note     (4) A TCP connection's next expected receive sequence numbers are NOT updated until
 *                   both of the TCP connection's transport & application receive queues have been
 *                   handled.  Thus the transmission of any TCP connection data or acknowledgements
 *                   MUST follow the handling of BOTH of the TCP connection's receive queues.
 *
 *                   See also Note #1a3 & 'NetTCP_RxPktConnHandlerRxQ_Conn()  Note #5c'.
 *
 * @note     (5) Stream-type connections receive all data octets in one or more non-distinct
 *                   packets.  In other words, the application data is NOT bounded by any specific
 *                   packet(s); rather, it is contiguous & sequenced from one packet to the next.
 *
 *                   Therefore, the TCP connection receive queue is signaled ONLY when data is received
 *                   for a connection where data was previously unavailable.
 *
 * @note     (6) (a) RFC #793, Section 3.7 'Data Communication : Managing the Window' states that
 *                   "the window sent in each segment indicates the range of sequence numbers the
 *                   sender of the window (the data receiver) is currently prepared to accept.
 *                   There is an assumption that this is related to the currently available data
 *                   buffer space available for this connection".
 *
 *                       - (b) (1) A TCP connection's advertised receive window MUST NEVER be decreased to zero
 *                   if NO receive data is available & ready to be read by the application layer.
 *
 *                   In other words, if NO received data starting from the next expected receive
 *                   sequence number(s) is queued, then NO data is available to be read by the
 *                   application layer.  Therefore, the receive window size MUST NOT be decreased
 *                   to zero, otherwise the receive window would deadlock since the application
 *                   layer would NOT be able to read & extract any data from the receive window
 *                   & the TCP connection would NOT be able to receive any more data into the
 *                   receive window.
 *
 *                       - (2) (A) In case the advertised receive window size has decreased to zero, ...
 *                       - (B) & NO data is available to be read by the application layer;       ...
 *                       - (C) then remove & free the last received TCP segment from the tail
 *                   of the TCP connection's transport receive queue,              ...
 *                       - (D) & increase the advertised receive window size by this freed
 *                   segment's length.
 *
 *                   This is permissible because removing the last received TCP segment from
 *                   the TCP connection's transport receive queue does NOT interfere with TCP
 *                   communications since the next expected receive sequence number(s) remains
 *                   unchanged.
 *
 *                       - (3) (A) A TCP connection's receive window SHOULD NOT become deadlocked during
 *                   correct operation of TCP communication.  However, these TCP receive
 *                   zero-sized window cases are included as an extra precaution in the
 *                   case that TCP communication is incorrectly handled &/or corrupted.
 *
 *                       - (B) A deadlocked TCP connection with a receive window of zero-size with
 *                   absolutely NO buffers queued in the TCP connection's transport receive
 *                   queue SHOULD NEVER occur.  However, the TCP receive window size reset
 *                   case is included as an extra precaution in the case that a TCP connection
 *                   receive window is incorrectly handled &/or corrupted.
 *
 *                   See also 'NetTCP_RxConnWinSizeHandler()  Note #2a1'.
 *******************************************************************************************************/
static void NetTCP_RxPktConnHandlerRxQ_AppData(NET_TCP_CONN *p_conn)
{
  NET_BUF         *p_buf;
  NET_BUF         *p_buf_head;
  NET_BUF         *p_buf_tail;
  NET_BUF         *p_buf_q_head;
  NET_BUF         *p_buf_q_tail;
  NET_BUF_HDR     *p_buf_hdr;
  NET_BUF_HDR     *p_buf_hdr_head;
  NET_BUF_HDR     *p_buf_hdr_tail;
  NET_BUF_HDR     *p_buf_hdr_q_head;
  NET_BUF_HDR     *p_buf_hdr_q_tail;
  NET_TCP_SEQ_NBR seq_nbr = 0u;
  NET_TCP_SEQ_NBR seq_nbr_inc;
  CPU_BOOLEAN     done;

  //                                                               ------ REMOVE RX'D SEG(S) FROM TRANSPORT RX Q ------
  switch (p_conn->RxQ_State) {                                  // Cfg starting seq nbr.
    case NET_TCP_RX_Q_STATE_SYNC:
      if (p_conn->RxQ_Transport_Head == DEF_NULL) {             // If   sync seg NOT      q'd with rx'd data, ...
        seq_nbr = p_conn->RxSeqNbrNext;                         // ...  start rx seq move from next rx seq.
      } else {                                                  // Else sync seg possibly q'd with rx'd data.
        p_buf_q_head = p_conn->RxQ_Transport_Head;
        p_buf_hdr_q_head = &p_buf_q_head->Hdr;
        //                                                         If sync seg q'd,                             ...
        seq_nbr = (p_buf_hdr_q_head->TCP_SegSync == DEF_YES)
                  ?  p_conn->RxSeqNbrSync                       // ...      start rx seq move from sync rx seq; ...
                  :  p_conn->RxSeqNbrNext;                      // ... else start rx seq move from next rx seq.
      }

      p_conn->RxQ_State = NET_TCP_RX_Q_STATE_CONN;
      break;

    case NET_TCP_RX_Q_STATE_CONN:
    case NET_TCP_RX_Q_STATE_CLOSING:
      seq_nbr = p_conn->RxSeqNbrNext;
      break;

    case NET_TCP_RX_Q_STATE_CLOSED:
      goto exit;

    case NET_TCP_RX_Q_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  p_buf = p_conn->RxQ_Transport_Head;
  p_buf_head = p_buf;
  p_buf_tail = DEF_NULL;
  done = DEF_NO;

  while (done == DEF_NO) {                                      // Srch for ALL segs with consecutive seq nbrs ...
                                                                // ... from next expected rx seq.
    if (p_buf != DEF_NULL) {
      p_buf_hdr = &p_buf->Hdr;
      if (p_buf_hdr->TCP_SeqNbr == seq_nbr) {                   // If seq consecutive from next expected rx seq, ..
        seq_nbr_inc = p_buf_hdr->TCP_SegLen;
        seq_nbr += seq_nbr_inc;                                 // ..               update next expected rx seq.
        p_buf_tail = p_buf;
        p_buf = p_buf_hdr->NextPrimListPtr;
      } else {
        done = DEF_YES;
      }
    } else {
      done = DEF_YES;
    }
  }

  //                                                               ---------- UPDATE TCP CONN TRANSPORT RX Q ----------
  if (p_buf != DEF_NULL) {                                      // If transport rx Q NOT empty, update ..
                                                                // .. transport rx Q head.
    p_buf_hdr->PrevPrimListPtr = DEF_NULL;
    p_conn->RxQ_Transport_Head = p_buf;
  } else {                                                      // Else clr transport rx Q.
    p_conn->RxQ_Transport_Head = DEF_NULL;
    p_conn->RxQ_Transport_Tail = DEF_NULL;
  }

  p_conn->RxSeqNbrNext = seq_nbr;                               // Update next expected rx seq.
  if (p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSING) {
    if (p_conn->RxSeqNbrNext == p_conn->RxSeqNbrLast) {         // If last seq rx'd, close TCP conn rx.
      p_conn->RxQ_State = NET_TCP_RX_Q_STATE_CLOSED;
    }
  }

  //                                                               ---------- MOVE RX'D SEG(S) ONTO APP RX Q ----------
  if (p_buf_tail != DEF_NULL) {                                 // If avail, move rx'd seg(s) from transport rx Q
                                                                // ... into app rx Q (see Note #3b1B).
    p_buf_hdr_head = &p_buf_head->Hdr;
    p_buf_hdr_tail = &p_buf_tail->Hdr;
    p_buf_hdr_head->PrevPrimListPtr = p_conn->RxQ_App_Tail;
    p_buf_hdr_tail->NextPrimListPtr = DEF_NULL;

    if (p_conn->RxQ_App_Tail != DEF_NULL) {                     // If app rx Q NOT empty, ...
                                                                // ... append seg(s) @ Q tail (see Note #2b1).
      p_buf_q_tail = p_conn->RxQ_App_Tail;
      p_buf_hdr_q_tail = &p_buf_q_tail->Hdr;
      p_buf_hdr_q_tail->NextPrimListPtr = p_buf_head;
      p_conn->RxQ_App_Tail = p_buf_tail;
    } else {                                                    // Else add seg(s) to empty app rx Q ...
      p_conn->RxQ_App_Head = p_buf_head;
      p_conn->RxQ_App_Tail = p_buf_tail;

      NetTCP_RxQ_Signal(p_conn->ID);                            // ...   & signal non-empty app rx Q (see Note #5).
    }
  } else {                                                      // ----------------- CHK RX WIN SIZE ------------------
    if (p_conn->RxWinSizeActual < 1) {                          // If avail rx win size zero  (see Note #6b2A)  ...
      if (p_conn->RxQ_App_Head == DEF_NULL) {                   // ... & NO avail app rx data (see Note #6b2B); ...
                                                                // ... inc rx win size (see Note #6b).
        p_buf = p_conn->RxQ_Transport_Tail;
        if (p_buf != DEF_NULL) {                                // If transport rx Q NOT empty;              ...
                                                                // ... remove last q'd seg (see Note #6b2C), ...
          p_buf_hdr = &p_buf->Hdr;
          p_buf_q_tail = p_buf_hdr->PrevPrimListPtr;
          if (p_buf_q_tail != DEF_NULL) {
            p_conn->RxQ_Transport_Tail = p_buf_q_tail;
            p_buf_hdr_q_tail = &p_buf_q_tail->Hdr;
            p_buf_hdr_q_tail->NextPrimListPtr = DEF_NULL;
          } else {
            p_conn->RxQ_Transport_Head = DEF_NULL;
            p_conn->RxQ_Transport_Tail = DEF_NULL;

            NetTCP_RxQ_Abort(p_conn->ID);
            NetTCP_RxQ_Clr(p_conn->ID);
          }

#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN                           // ... inc win size by seg's len (see Note #6b2D),
          NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, p_buf_hdr->TCP_SegLenData, NET_TCP_CONN_RX_WIN_SET);
#else
          NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, 1, NET_TCP_CONN_RX_WIN_INC);
#endif
          NetTCP_RxPktFree(p_buf);                               // ... & free seg (see Note #6b2C).
        } else {                                                  // Else reset TCP conn rx win size (see Note #6b3B).
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
          NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, 0u, NET_TCP_CONN_RX_WIN_RESET);
#else
          NetTCP_RxConnWinSizeHandler(p_conn, DEF_NULL, 0u, NET_TCP_CONN_RX_WIN_RESET);
#endif
        }
      }
    }
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                   NetTCP_RxPktConnHandlerTxWinRemote()
 *
 * @brief    Handle TCP connection's transmit remote host window update.
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    ack_code    Indicates the received segment's acknowledgement condition :
 *
 * @param    --------   NET_TCP_CONN_RX_ACK_VALID           Received acknowledgement number is
 *                                                                       valid for the TCP connection.
 *                               NET_TCP_CONN_RX_ACK_DUP             Received acknowledgement number is a
 *                                                                               duplicate for the TCP
 *                                                                       connection.
 *                               NET_TCP_CONN_RX_ACK_PREV            Received acknowledgement number is a
 *                                                                       previous duplicate for the TCP
 *                                                                       connection.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (1) (a) (1) The following sections ... :
 *
 *                           - (A) RFC #1122, Section 4.2.2.20.(c)
 *                           - (B) RFC #1122, Section 4.2.2.20.(f)
 *
 *                           - (2) ... generalize that "when the connection enters ESTABLISHED STATE, the following
 *                       variables should be set" :
 *
 *                           - (A) SND.WND <- SEG.WND
 *                           - (B) SND.WL1 <- SEG.SEQ
 *                           - (C) SND.WL2 <- SEG.ACK
 *
 *                           - (b) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                       ESTABLISHED STATE' generalizes ...
 *
 *                           - (A) ... that for the following connected states ... :
 *
 *                           - (1) ESTABLISHED
 *                           - (2) FIN-WAIT-1
 *                           - (3) CLOSING
 *                           - (4) CLOSE-WAIT
 *                           - (5) LAST-ACK
 *                           - (a) See 'NetTCP_RxPktConnHandlerLastAck()  Notes #2d2B'.
 *
 *                           - (B) ... that "if SND.UNA < SEG.ACK <= SND.NXT, the send window should be updated" :
 *
 *                           - (1) If ...
 *
 *                           - (a)  ((SND.WL1 <  SEG.SEQ)  or
 *                           - (b)  ((SND.WL1 == SEG.SEQ)  and
 *                           - (c)   (SND.WL2 <= SEG.ACK)) ...
 *
 *                           - (2) ... [then] set ...
 *
 *                           - (a) SND.WND <- SEG.WND
 *                           - (b) SND.WL1 <- SEG.SEQ
 *                           - (c) SND.WL2 <- SEG.ACK
 *
 *                           - (2) (A) RFC #1122, Section 4.2.2.20.(g) amends the transmit window update criteria
 *                       for the segment's acknowledgement to include SND.UNA : "The window should
 *                       updated if SND.UNA <= SEG.ACK <= SND.NXT."
 *
 *                       This allows received segments that exactly acknowledge the TCP connection's
 *                       last acknowledged transmit sequence octet to update the transmit window in
 *                       case the remote host's receive window size is increasing or decreasing.
 *
 *                           - (B) However, it does NOT seem reasonable to update a TCP connection's remote
 *                       transmit window for any received duplicate acknowledgement segment; i.e.
 *                       an acknowledgement with the exact same sequence numbers & receive window
 *                       size advertisement.  Otherwise, each received duplicate acknowledgement
 *                       would incorrectly update the TCP connection's remote transmit window size.
 *
 *                       Therefore, it seems reasonable & is assumed that the transmit window MUST
 *                       be updated for received acknowledgements that exactly acknowledge the TCP
 *                       connection's last acknowledged transmit sequence octet, if & only if the
 *                       received segment's receive window size advertisement has increased or
 *                       decreased since the last received acknowledgement segment.
 *
 *                       See also RFC #1122, Section 4.2.2.16 & 'NetTCP_TxConnAck()  Note #4b1B1'.
 *
 *                       See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #3'.
 *
 * @note     (2) RFC #793 does NOT provide nor suggest any logic to determine/handle sequence number
 *                       comparisons for sequence number windows that overflow the sequence number space.
 *
 *                           - (a) (1) For example, in order to update the transmit window, a received segment's
 *                       acknowledgement value (SEG.ACK) MUST be greater than or equal to the last
 *                       received acknowledgement number that updated the transmit window (SND.WL2)
 *                       [see Note #1b1B1c] :
 *
 *                           - (A) SEG.ACK >= SND.WL2
 *
 *                       However, if SEG.ACK overflows the sequence number space, it will be MUCH
 *                       less than SND.WL2 until SND.WL2 also overflows :
 *
 *                           - (B) SEG.ACK << SND.WL2
 *
 *                           - (2) Therefore, in order to validate a received segment's acknowledgement number
 *                       as valid for updating the TCP connection's transmit window, the following
 *                       unsigned arithmetic comparison MUST be true :
 *
 *                           - (A) (SND.NXT - SEG.ACK)  <=  (SND.NXT - SND.WL2)
 *
 *                           - (b) (1) Alternatively, to update the transmit window, a received segment's  sequence
 *                       number (SEG.SEQ) MUST be greater than or equal to the last received sequence
 *                       number that updated the transmit window (SND.WL1) [see Notes #1b1B1a & #1b1B1b] :
 *
 *                           - (A) SEG.SEQ >= SND.WL1
 *
 *                           - (2) Therefore, in order to validate a received segment's sequence number as valid
 *                       for updating the TCP connection's transmit window, the following unsigned
 *                       arithmetic comparison MUST be true :
 *
 *                           - (A) (RCV.NXT + RCV.WND) - SEG.SEQ  <  (RCV.NXT + RCV.WND) - SND.WL1
 *
 *                       See also 'NetTCP_RxPktConnIsValidAck()  Note #3'.
 *******************************************************************************************************/
static void NetTCP_RxPktConnHandlerTxWinRemote(NET_TCP_CONN     *p_conn,
                                               NET_TCP_ACK_CODE ack_code,
                                               NET_BUF_HDR      *p_buf_hdr,
                                               RTOS_ERR         *p_err)
{
  CPU_BOOLEAN     tx_win_update;
  NET_TCP_SEQ_NBR ack_delta_next;
  NET_TCP_SEQ_NBR ack_delta_win_update;
  NET_TCP_SEQ_NBR seq_win;
  NET_TCP_SEQ_NBR seq_win_delta;
  NET_TCP_SEQ_NBR seq_win_update_delta;
  RTOS_ERR        local_err;

  //                                                               ------ VALIDATE TCP CONN TX REMOTE WIN UPDATE ------
  tx_win_update = DEF_NO;

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
      //                                                           Validate TCP conn tx Q state.
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CLOSED:
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSING:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        default:
          RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
      }
      tx_win_update = DEF_YES;                                  // Update tx win ctrls (see Note #1a2).
      break;

    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      //                                                           Validate TCP conn tx Q state.
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSING:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CLOSED:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        default:
          RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
      }

      //                                                           Chk tx win ctrls update      (see Note #1b1B1).
      //                                                           If seq = last win update seq (see Note #1b1B1b),  ..
      if (p_buf_hdr->TCP_SeqNbr == p_conn->TxWinUpdateSeqNbr) {
        ack_delta_next = (NET_TCP_SEQ_NBR)(p_conn->TxSeqNbrNext - p_buf_hdr->TCP_AckNbr);
        ack_delta_win_update = (NET_TCP_SEQ_NBR)(p_conn->TxSeqNbrNext - p_conn->TxWinUpdateAckNbr);
        if (ack_delta_next <= ack_delta_win_update) {           // .. (next - ack) <= (next - last win update ack),  ..
                                                                // .. & rx'd ack OR win != last rx'd ack or win,     ..
                                                                // .. update tx win (see Notes #1b1B1c, #1b2B, & #2a2A),
          tx_win_update = ((p_buf_hdr->TCP_AckNbr != p_conn->TxWinUpdateAckNbr)
                           || (p_buf_hdr->TCP_WinSize != p_conn->TxWinUpdateWinSize)) ? DEF_YES : DEF_NO;
        }
      } else {
        seq_win = (NET_TCP_SEQ_NBR)(p_conn->RxSeqNbrNext + p_conn->RxWinSizeActual);
        seq_win_delta = (NET_TCP_SEQ_NBR)(seq_win             - p_buf_hdr->TCP_SeqNbr);
        seq_win_update_delta = (NET_TCP_SEQ_NBR)(seq_win             - p_conn->TxWinUpdateSeqNbr);

        if (seq_win_delta < seq_win_update_delta) {             // .. else if [(next + win) -                 seq] < ..
                                                                // ..         [(next + win) - last win update seq],  ..
          tx_win_update = DEF_YES;                              // .. update tx win (see Notes #1b1B1a & #2b2A).
        }
      }
      break;

    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_STATE_NONE:
    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_CLOSED:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  //                                                               ---------- UPDATE TCP CONN TX REMOTE WIN -----------
  if (tx_win_update == DEF_YES) {                               // Update tx win ctrls (see Notes #1a2 & #1b1B2).
    RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
    NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn, p_buf_hdr, ack_code, 0, NET_TCP_CONN_TX_WIN_REMOTE_UPDATE, &local_err);
    PP_UNUSED_PARAM(local_err);                                 // Ignore err(s).
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnHandlerReTxQ()
 *
 * @brief    (1) Handle received valid acknowledgment segments :
 *
 *           - (a) Update TCP connection re-transmit queue :
 *
 *               - (1) Update TCP connection's unacknowledged transmit sequences       See Note #2c1
 *               - (2) Remove acknowledged TCP segments from a TCP                     See Note #2c2
 *                           connection's re-transmit queue
 *               - (3) Update TCP connection's round-trip  time calculations
 *                           (see 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a1')
 *               - (4) Update TCP connection's re-transmit timeout                     See Note #8b
 *               - (5) Free   TCP packet buffer(s)
 *               - (6) Start  TCP connection's    transmit idle timer
 *                           (see 'NetTCP_TxConnTxQ_TimeoutIdleSet()  Note #2a1')
 *
 *           - (b) Update TCP connection's transmit window(s) :
 *
 *               - (1) Increment TCP connection's configured         transmit window size
 *               - (2) Increment TCP connection's congestion control transmit window size
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    ack_code    Indicates the received segment's acknowledgement condition :
 *
 * @param    --------   NET_TCP_CONN_RX_ACK_VALID           Received acknowledgement number is
 *                                                                       valid     for the TCP connection.
 *                               NET_TCP_CONN_RX_ACK_DUP             Received acknowledgement number is a
 *                                                                       duplicate for the TCP connection.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) (a) The following sections ... :
 *
 *                           - (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                       Check SYN Bit'
 *                           - (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                       ESTABLISHED STATE'
 *
 *                           - (b) ... generalize that for ...
 *
 *                           - (1) ... the following synchronization-to-connected state transitions ... :
 *
 *                           - (A) SYN-RECEIVED to ESTABLISHED
 *                           - (B) SYN-SENT     to ESTABLISHED
 *
 *                           - (2) ... & for the following connected states ... :
 *
 *                           - (A) ESTABLISHED
 *                           - (B) FIN-WAIT-1
 *                           - (C) CLOSING
 *                           - (D) CLOSE-WAIT
 *                           - (E) LAST-ACK
 *                           - (1) See 'NetTCP_RxPktConnHandlerLastAck()  Notes #2d2B'.
 *
 *                           - (c) ... that ...
 *
 *                           - (1) "If SND.UNA < SEG.ACK <= SND.NXT, SND.UNA should be advanced to equal SEG.ACK" :
 *
 *                           - (A) SND.UNA <- SEG.ACK
 *
 *                           - (2) "Any segments on the retransmission queue which are thereby entirely acknowledged
 *                       are removed."
 *
 * @note     (3) A TCP connection's re-transmit queue SHOULD be updated ONLY by valid, non-duplicate
 *                       received acknowledgement segments.
 *
 * @note     (4) Since valid received acknowledgement segments update a TCP connection's last
 *                       unacknowledged transmit sequence number ('TxSeqNbrUnackd'), any controls &/or
 *                       calculations based on the TCP connection's last unacknowledged transmit sequence
 *                       number MUST use the saved/previous value of the TCP connection's last unacknowledged
 *                       transmit sequence number ('TxSeqNbrUnackdPrev').
 *
 * @note     (5) Since segments enqueued to a TCP connection's re-transmit queue have already been
 *                       transmitted to the remote host & reported to the application layer as having been
 *                       transmitted, any TCP connection whose re-transmit queue becomes corrupted MUST be
 *                       closed to prevent the further transmit of corrupted data.
 *
 * @note     (6) Although network packets are NOT required to ensure that network packet headers or
 *                       data will locate on CPU word-aligned addresses; many processors may be more efficient
 *                       & may even REQUIRE that memory transfers occur on CPU word-aligned addresses [e.g.
 *                       processors or devices with direct memory access (DMA) capability].
 *
 *                       Therefore, to ensure appropriate CPU word alignment; any segment in a TCP connection's
 *                       re-transmit queue whose transmit sequences are partially acknowledged MUST acknowledge
 *                       an exact number of sequences such that the remaining sequences are aligned on a CPU
 *                       word-aligned address.
 *
 *                           - (a) Since RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check
 *                       Sequence Number' states that in the "SYN-RECEIVED, ESTABLISHED STATE,
 *                       FIN-WAIT-1 STATE, FIN-WAIT-2 STATE, CLOSE-WAIT STATE, CLOSING STATE,
 *                       LAST-ACK STATE, TIME-WAIT STATE" that "if a segment's contents straddle
 *                       the boundary between old and new, only the new parts should be processed";
 *                       any data segments partially acknowledged in a TCP connections' re-transmit
 *                       queue may be re-transmitted in full or in part since the retransmission of
 *                       previously received data is not processed.
 *
 * @note     (7) (a) RFC #1122, Section 4.2.3.5 states that "excessive retransmission of the same
 *                       segment by TCP indicates some failure of the remote host or the Internet path
 *                       ... When the number of transmissions of the same segment reaches a threshold
 *                       ... close the connection."
 *
 *                           - (b) However, any segment in a TCP connection's re-transmit queue whose transmit
 *                       sequences are partially acknowledged SHOULD NOT be considered the same segment
 *                       for purposes of excessive retransmission.
 *
 *                       Therefore, it seems reasonable that whenever a TCP connection's re-transmit
 *                       queue segment's transmit sequences are partially acknowledged; that segment's
 *                       re-transmit counter should be reset.
 *
 *                       See also 'NetTCP_TxConnReTxQ()  Note #3'.
 *
 * @note     (8) (a) (1) (A) RFC #793, Section 3.7 'Data Communication : Retransmission Timeout' states
 *                       that "the Round Trip Time (RTT) ... [is] the elapsed time between" :
 *
 *                           - (1) "sending a data octet with a particular sequence number and"   ...
 *                           - (2) "receiving an acknowledgment that covers that sequence number" ...
 *                           - (3) "(segments sent do not have to match segments received)".
 *
 *                           - (B) (1) RFC #2988, Section 3 adds that :
 *
 *                           - (a) "Traditionally, TCP implementations have taken one RTT measurement at
 *                       a time (typically once per RTT)."
 *
 *                           - (2) RFC #2988, Section 1 states that "in some situations it may be beneficial
 *                       for a TCP sender to be more conservative than the algorithms detailed in
 *                       this document allow.  However, a TCP MUST NOT be more aggressive than the
 *                       ... algorithms allow".
 *
 *                       See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a2'.
 *
 *                           - (2) RFC #2988, Section 3 states that "TCP MUST use Karn's algorithm ... for taking
 *                       RTT samples.  That is, RTT samples MUST NOT be made using segments that were
 *                       retransmitted (and thus for which it is ambiguous whether the reply was for
 *                       the first instance of the packet or a later instance)".
 *
 *                           - (A) (1) To determine if any segment(s) from a TCP connection's re-transmit queue
 *                       have been re-transmitted (i.e. transmitted more than once), the TCP
 *                       connection's transmit unacknowledged & un-re-transmitted sequence numbers
 *                       are compared :
 *
 *                           - (a) If NO  sequences in the TCP connection's re-transmit queue have been
 *                       re-transmitted,  the TCP connection's    transmit unacknowledged &
 *                       un-re-transmitted sequence numbers will be equal.
 *
 *                           - (b) If ANY sequences in the TCP connection's re-transmit queue have been
 *                       re-transmitted,  the TCP connection's    transmit unacknowledged
 *                       sequence number will be less than the un-re-transmitted sequence
 *                       number.
 *
 *                           - (2) If a received acknowledgement fully acknowledges ALL re-transmitted
 *                       segment(s) from a TCP connection's re-transmit queue, the TCP connection
 *                       advances its un-re-transmitted sequence number to the received segment's
 *                       acknowledgement sequence number.
 *
 *                           - (B) Although RTT measurements could be calculated for ALL transmitted segments;
 *                       to simplify implementation of Karn's algorithm :
 *
 *                           - (1) Only a single RTT measurement is calculated, ...        See Note #8a1B1a
 *                           - (2) (a) per TCP acknowledgement received         ...        See Note #8a1A2
 *                       AND
 *                           - (b) the segment at the head of a TCP connection's
 *                       re-transmit queue.                              See Note #8a1A1
 *
 *                       See also 'NetTCP_TxConnReTxQ()  Note #4'.
 *
 *                           - (b) RFC #2988, Section 5 states that "the following is the RECOMMENDED algorithm for
 *                       managing the retransmission timer" :
 *
 *                           - (2) "When all outstanding data has been acknowledged, turn off the retransmission
 *                       timer."
 *
 *                           - (3) "When an ACK is received that acknowledges new data, restart the retransmission
 *                       timer so that it will expire after RTO seconds (for the current value of RTO)."
 *
 *                       See also 'NetTCP_TxConnReTxQ()  Note #2b1A'.
 *
 * @note     (9) RFC #793 does NOT provide nor suggest any logic to determine/handle sequence number
 *                       comparisons for sequence number windows that overflow the sequence number space.
 *
 *                           - (a) For example, the next sequence octet to transmit (SND.NXT) is typically greater
 *                       than or equal to any received segment's acknowledgement number (SEG.ACK) :
 *
 *                           - (1) SND.NXT >= SEG.ACK
 *
 *                       However, if SND.NXT overflows the sequence number space, it will be MUCH less
 *                       than SEG.ACK until SEG.ACK also overflows :
 *
 *                           - (2) SND.NXT << SEG.ACK
 *
 *                           - (b) (1) Therefore, in order to determine if a received segment's acknowledgement value
 *                       fully acknowledges previously transmitted segment(s) in the TCP connection's
 *                       re-transmit queue, the following unsigned arithmetic comparison MUST be checked :
 *
 *                           - (A) (SND.NXT - SEG.ACK)  <=  SND.NXT - (ReTxQCur.SeqNbr + ReTxQCur.SegLen)
 *
 *                       See also 'NetTCP_RxPktConnIsValidAck()  Note #3a2'.
 *
 *                           - (2) In order to determine if a received segment's acknowledgement partially
 *                       acknowledges a previously received segment in the TCP connection's re-
 *                       transmit queue, the following unsigned arithmetic comparison MUST be checked :
 *
 *                           - (A) (ReTxQCur.SeqNbr + ReTxQCur.SegLen) - SEG.ACK  <  ReTxQCur.SegLen
 *
 *                       See also 'NetTCP_RxPktConnHandlerRxQ_Conn()  Note #4c2'.
 *
 *                           - (3) In order to determine if a received segment's acknowledgement should
 *                       advance the TCP connection's un-re-transmitted sequence number(s), the
 *                       following unsigned arithmetic comparison MUST be true :
 *
 *                           - (A) (SEG.ACK - ReTxQ.UnReTxdSeqNbr)  <=  (SND.NXT - ReTxQ.UnReTxdSeqNbr)
 *******************************************************************************************************/
static void NetTCP_RxPktConnHandlerReTxQ(NET_TCP_CONN     *p_conn,
                                         NET_TCP_ACK_CODE ack_code,
                                         NET_BUF_HDR      *p_buf_hdr,
                                         RTOS_ERR         *p_err)
{
  NET_TCP_SEQ_NBR      seq_nbr_cur = 0u;
  NET_TCP_SEQ_NBR      seq_nbr_delta = 0u;
  NET_TCP_SEQ_NBR      seq_nbr_next_qd = 0u;
  NET_TCP_SEQ_NBR      ack_delta_seq = 0u;
  NET_TCP_SEQ_NBR      ack_delta_seq_align = 0u;
  NET_TCP_SEQ_NBR      ack_delta_seq_align_offset = 0u;
  NET_TCP_SEQ_NBR      ack_delta_unretxd = 0u;
  NET_TCP_SEQ_NBR      ack_delta_next = 0u;
  NET_TCP_SEQ_NBR      seq_delta_unretxd = 0u;
  NET_TCP_SEQ_NBR      seq_delta_next = 0u;
  NET_TCP_SEQ_NBR      seq_nbr_next = 0u;
  NET_TCP_SEQ_NBR      seq_nbr = 0u;
  NET_TCP_SEG_SIZE     seg_len = 0u;
  NET_TCP_SEG_SIZE     seg_len_tot = 0u;
  NET_TCP_SEG_SIZE     seg_len_data = 0u;
  NET_TCP_SEG_SIZE     seg_len_data_tot = 0u;
  NET_TCP_TX_RTT_TS_MS seg_rtt_ts_txd_ms = 0u;
  NET_TCP_TX_RTT_TS_MS seg_rtt_ts_rxd_ms = 0u;
  CPU_BOOLEAN          segs_re_txd = DEF_NO;
  CPU_BOOLEAN          seqs_ackd = DEF_NO;
  CPU_BOOLEAN          done = DEF_NO;
  CPU_BOOLEAN          tmr_update = DEF_NO;
  NET_BUF              *p_buf_q = DEF_NULL;
  NET_BUF              *p_buf_q_head = DEF_NULL;
  NET_BUF              *p_buf_q_prev = DEF_NULL;
  NET_BUF              *p_buf_q_next = DEF_NULL;
  NET_BUF_HDR          *p_buf_q_hdr = DEF_NULL;
  NET_BUF_HDR          *p_buf_q_head_hdr = DEF_NULL;
  NET_BUF_HDR          *p_buf_q_prev_hdr = DEF_NULL;

  //                                                               ---------------- VALIDATE TCP CONN -----------------
  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CLOSED:
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSING:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        default:
          RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
      }
      break;

    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSING:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CLOSED:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        default:
          RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
      }
      break;

    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    case NET_TCP_CONN_STATE_CLOSED:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  //                                                               ------------- UPDATE UNACK'D TX SEQ(S) -------------
  seq_nbr_cur = p_conn->TxSeqNbrUnAckd;
  seq_nbr_delta = p_conn->TxSeqNbrUnAckdAlignDelta;

  p_conn->TxSeqNbrUnAckdPrev = p_conn->TxSeqNbrUnAckd;          // Save prev tx unack'd seq nbr (see Note #4).
  p_conn->TxSeqNbrUnAckd = p_buf_hdr->TCP_AckNbr;               // Ack  prev'ly unack'd tx segs (see Note #2c1).

  if (p_conn->TxSeqNbrUnAckd == p_conn->TxSeqNbrLast) {         // If last tx'd seq ack'd, close TCP conn tx.
    switch (p_conn->TxQ_State) {
      case NET_TCP_TX_Q_STATE_CLOSING:
        p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSED;
        break;

      case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
        p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSED_SUSPEND;
        break;

      default:                                                  // 'default' case intentionally empty.
        break;
    }
  }

  //                                                               --------- REMOVE ACK'D SEG(S) FROM RE-TX Q ---------
  if (ack_code != NET_TCP_CONN_RX_ACK_VALID) {                  // If ack NOT valid, non-dup ack; ...
    goto exit;                                                  // ... do NOT update re-tx Q (see Note #3).
  }

  p_buf_q_head = p_conn->ReTxQ_Head;
  p_buf_q_prev = DEF_NULL;
  p_buf_q = p_buf_q_head;
  seg_len_tot = 0u;
  seg_len_data_tot = 0u;
  //                                                               Chk re-tx'd seg(s) [see Notes #8a2A1 & #4].
  segs_re_txd = (p_conn->TxSeqNbrUnAckdPrev == p_conn->TxSeqNbrUnReTxd)
                ?  DEF_NO : DEF_YES;
  seqs_ackd = DEF_NO;
  done = DEF_NO;

  while ((p_buf_q != DEF_NULL)                                  // While NOT @ re-tx Q tail, ...
         && (done == DEF_NO)) {                                 // ... srch for ack'd tx segs to remove (see Note #2c2).
    p_buf_q_hdr = &p_buf_q->Hdr;
    p_buf_q_next = p_buf_q_hdr->NextPrimListPtr;
    seq_nbr = p_buf_q_hdr->TCP_SeqNbr;
    seg_len = p_buf_q_hdr->TCP_SegLen;
    seg_len_data = seg_len;
    if (p_buf_q_hdr->TCP_SegSync == DEF_YES) {                  // If sync  seg                           ...
      if (seg_len_data >= NET_TCP_SEG_LEN_SYNC) {               // ... &        seg len >= sync  seg len, ...
        seg_len_data -= NET_TCP_SEG_LEN_SYNC;                   // ... dec data seg len by sync  seg len.
      }
    }
    if (p_buf_q_hdr->TCP_SegClose == DEF_YES) {                 // If close seg                           ...
      if (seg_len_data >= NET_TCP_SEG_LEN_CLOSE) {              // ... &        seg len >= close seg len, ...
        seg_len_data -= NET_TCP_SEG_LEN_CLOSE;                  // ... dec data seg len by close seg len.
      }
    }

    seq_nbr_next_qd = seq_nbr + p_conn->TxSeqNbrUnAckdAlignDelta;
    if (seq_nbr_cur != seq_nbr_next_qd) {                       // If next q'd seg's seq nbr NOT consecutive, ...
                                                                // ... close TCP conn (see Note #5).
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
      NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
      RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
      goto exit;
    }

    //                                                             Chk if rx'd seg acks cur re-tx Q seg.
    ack_delta_next = (p_conn->TxSeqNbrNext - p_buf_hdr->TCP_AckNbr);
    seq_nbr_next = (seq_nbr + seg_len);
    seq_delta_next = (p_conn->TxSeqNbrNext - seq_nbr_next);

    if (ack_delta_next <= seq_delta_next) {                     // If seg fully acks cur re-tx Q seg (see Note #9b1A),
      p_buf_q_prev = p_buf_q;
      p_buf_q = p_buf_q_next;                                   // ... adv to next re-tx Q seg.
      p_conn->TxSeqNbrUnAckdAlignDelta = 0u;
      seg_len_tot += seg_len;
      seg_len_data_tot += seg_len_data;
      seqs_ackd = DEF_YES;

      if (p_buf_q == p_buf_q_prev) {
        done = DEF_YES;
      }

      seq_nbr_cur += (seg_len - seq_nbr_delta);
      seq_nbr_delta = 0u;
    } else {                                                    // Else chk partial re-tx Q seg ack (see Note #9b2A) :
      ack_delta_seq = p_buf_hdr->TCP_AckNbr - seq_nbr;
      if (ack_delta_seq < 1) {                                  // If NO   seqs ack'd for cur re-tx Q seg, ...
        ;                                                       // ... do NOT update seg.
      } else if (ack_delta_seq < seg_len) {                     // If SOME seqs ack'd for cur re-tx Q seg,  ...
                                                                // Align partial ack to word boundary (see Note #6).
        ack_delta_seq_align_offset = (ack_delta_seq % sizeof(CPU_ALIGN));
        ack_delta_seq_align = (ack_delta_seq - ack_delta_seq_align_offset);
        p_conn->TxSeqNbrUnAckdAlignDelta = ack_delta_seq_align_offset;

        //                                                         ...   update cur seg's seq nbr & seg len ...
        p_buf_q_hdr->TCP_SeqNbr += ack_delta_seq_align;
        p_buf_q_hdr->TCP_SegLen -= ack_delta_seq_align;
        p_buf_q_hdr->TCP_SegLenData -= ack_delta_seq_align;
        seg_len_tot += ack_delta_seq_align;
        seg_len_data_tot += ack_delta_seq_align;
        //                                                         ... & update TCP tx buf ctrls.
        p_buf_q_hdr->DataIx += ack_delta_seq_align;
        p_buf_q_hdr->DataLen -= ack_delta_seq_align;
        p_buf_q_hdr->TotLen -= ack_delta_seq_align;

        p_buf_q_hdr->TCP_SegReTxCtr = 0u;                       // Reset re-tx ctr (see Note #7b).

        seqs_ackd = DEF_YES;
      } else {                                                  // Else fully-ack'd-seg chk failed?; close TCP conn?
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxDataInvalidCtr);
        NetTCP_ConnClose(p_conn, p_buf_hdr, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
        RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
        goto exit;
      }

      done = DEF_YES;
    }
  }

  //                                                               --------------- UPDATE TCP CONN RTO ----------------
  if (seqs_ackd == DEF_YES) {                                   // If ANY  re-tx Q seq(s) ack'd                     ..
    if (segs_re_txd == DEF_NO) {                                // .. & NO re-tx Q seg(s) re-tx'd (see Note #8a2);  ..
                                                                // ..   get tx'd seg RTT ts       (see Note #8a1A1) ..
      p_buf_q_head_hdr = &p_buf_q_head->Hdr;
      seg_rtt_ts_txd_ms = p_buf_q_head_hdr->TCP_RTT_TS_Txd_ms;
      //                                                           ..   get rx'd ack RTT ts       (see Note #8a1A2) ..
      seg_rtt_ts_rxd_ms = p_buf_hdr->TCP_RTT_TS_Rxd_ms;
      //                                                           .. & calc/update RTT/RTO       (see Note #1a3).
      NetTCP_TxConnRTT_RTO_Calc(p_conn, NET_TCP_CONN_TX_RTT_RTO_CALC, seg_rtt_ts_txd_ms, seg_rtt_ts_rxd_ms);
    }

    ack_delta_unretxd = p_buf_hdr->TCP_AckNbr - p_conn->TxSeqNbrUnReTxd;
    seq_delta_unretxd = p_conn->TxSeqNbrNext  - p_conn->TxSeqNbrUnReTxd;
    if (ack_delta_unretxd <= seq_delta_unretxd) {               // If (ack - un-re-tx'd) < (next - un-re-tx'd), ...
                                                                // ... acks ALL re-tx'd seg(s)        [see Note #9b3A],
      p_conn->TxSeqNbrUnReTxd = p_buf_hdr->TCP_AckNbr;          // ... adv   un-re-tx'd seq(s) to ack (see Note #8a2A2).
    }
  }

  //                                                               ------------- UPDATE TCP CONN RE-TX Q --------------
  tmr_update = seqs_ackd;                                       // Update re-tx Q tmr if ANY re-tx Q seqs ack'd ...
                                                                // ... (see Note #8b3).
  if (p_buf_q != p_buf_q_head) {                                // If ANY re-tx Q segs fully ack'd, update re-tx Q.
    if (p_buf_q != DEF_NULL) {                                  // If re-tx Q still NOT empty, . ..
      p_buf_q_prev_hdr = &p_buf_q_prev->Hdr;
      p_buf_q_prev_hdr->NextPrimListPtr = DEF_NULL;
      //                                                           ... update re-tx Q head.
      p_conn->ReTxQ_Head = p_buf_q;
      p_buf_q_hdr->PrevPrimListPtr = DEF_NULL;
    } else {                                                    // Else clr   re-tx Q.
      p_conn->ReTxQ_Head = DEF_NULL;
      p_conn->ReTxQ_Tail = DEF_NULL;

      if (p_conn->ReTxQ_Tmr != DEF_NULL) {                      // Free  re-tx Q      tmr (see Note #8b2).
        NetTmr_Free(p_conn->ReTxQ_Tmr);
      }
      p_conn->ReTxQ_Tmr = DEF_NULL;
      tmr_update = DEF_NO;

      NetTCP_TxConnTxQ_TimeoutIdleSet(p_conn);                  // Start    tx Q idle tmr (see Note #1a6).
    }

    (void)NetTCP_TxPktFree(p_buf_q_head);                       // Free ALL fully ack'd seg pkt buf(s).
  }

  if (tmr_update == DEF_YES) {                                  // Update re-tx Q tmr.
    NetTCP_TxConnReTxQ_TimeoutSet(p_conn, DEF_NO, NET_TCP_CONN_CLOSE_ALL, p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
  }

  //                                                               ----------- UPDATE TCP CONN TX WIN SIZES -----------
  //                                                               Inc TCP conn's tx win sizes (see Note #1b).
  NetTCP_TxConnWinSizeHandlerCfgd(p_conn, seg_len_data_tot, NET_TCP_CONN_TX_WIN_INC);

  NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn,
                                      DEF_NULL,
                                      NET_TCP_CONN_RX_ACK_NONE,
                                      seg_len_data_tot,
                                      NET_TCP_CONN_TX_WIN_INC,
                                      p_err);

exit:
  return;
}

/****************************************************************************************************//**
 *                                   NetTCP_RxPktConnHandlerListenQ_IsAvail()
 *
 * @brief    Check if application layer listen queue is available to queue a new connection.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @param    p_err   Pointer to variable that will receive the return error code from this function.
 *
 * @return   DEF_YES, if application connection's listen queue is available to queue a new connection.
 *           DEF_NO,  otherwise..
 *
 * @note     (1) (a) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.11, Pages 257-258 states
 *                   that :
 *
 *               - (1) "Each listening end point has a fixed length queue of connections that have been
 *                       accepted by TCP (i.e., the three-way handshake is complete), but not yet accepted
 *                       by the application."
 *
 *               - (2) "The application specifies a limit to this queue, commonly called the backlog" :
 *
 *                   - (A) "This backlog must be between 0 and 5, inclusive."
 *                   - (B) "(Most applications specify the maximum value of 5.)"
 *
 *               - (3) "When a connection request arrives (i.e., the SYN segment), ... the current number
 *                       of connections already queued for this listening end point [is checked] to see
 *                       whether to accept the connection or not."
 *
 *               - (4) "If there is room on this listening end point's queue for this new connection, ...
 *                       the TCP module ACKs the SYN and completes the connection."
 *
 *               - (5) "If there is not room on the queue for the new connection" :
 *
 *                   - (A) "TCP just ignores the received SYN."
 *                   - (B) "Nothing is sent back (i.e., no RST segment)."
 *
 *           - (b) (A) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 15.9, Page 455
 *                       reiterates that :
 *
 *                   - (2) A "listen ... socket ... specifies a limit on the number of connections that can
 *                           be queued on the socket," ...
 *
 *                   - (5) "after which the socket layer refuses to queue additional connection requests.
 *                           When this occurs, TCP ignores incoming connection requests."
 *
 *               - (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 28.2, Page 930
 *                       also states that :
 *
 *                   - (5) (A) "By silently dropping the segment" ...
 *                       - (B) "and not replying with an RST,"    ...
 *                       - (C) "The client's connection request should time out, causing the client to
 *                               retransmit the SYN."
 *
 *               - (C) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 18.11, Pages 259-260
 *                       summarizes that :
 *
 *                   - (5) (A) "TCP ignores the incoming SYN when the queue is full," ...
 *                       - (B) "and doesn't respond with an RST,"                     ...
 *
 *                       - (C) (1) "because ... this condition could change in a short while ... [and] by
 *                                   ignoring the SYN, the server forces the client TCP to re-transmit the
 *                                   SYN later, hoping that the queue will then have room for the new
 *                                   connection".
 *
 *                           - (2) Whereas page 259-260 counters that "if the server's TCP responded with
 *                                   a reset, the client's active open would abort".
 *
 *               See also 'net_sock.c  NetSock_ListenQ_IsAvail()  Note #2'.
 *
 * @note     (2) The 'NET_CONN_CFG_FAMILY' pre-processor 'else'-conditional code will never be compiled/linked
 *               since 'net_conn.h' ensures that the family type configuration constant (NET_CONN_CFG_FAMILY)
 *               is configured with an appropriate family type value (see 'net_conn.h  CONFIGURATION ERRORS').
 *               The 'else'-conditional code is included for completeness & as an extra precaution in case
 *               'net_conn.h' is incorrectly modified.
 *******************************************************************************************************/
static CPU_BOOLEAN NetTCP_RxPktConnHandlerListenQ_IsAvail(NET_TCP_CONN *p_conn,
                                                          RTOS_ERR     *p_err)
{
  NET_CONN_ID conn_id;
  NET_CONN_ID conn_id_app;
  CPU_BOOLEAN q_avail = DEF_NO;

  //                                                               ------------- VALIDATE TCP CONN STATE --------------
  if (p_conn->ConnState != NET_TCP_CONN_STATE_LISTEN) {
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  conn_id = p_conn->ID_Conn;
  conn_id_app = NetConn_ID_AppGet(conn_id);                     // Get TCP listen conn's app conn id.
  if (conn_id_app == NET_CONN_ID_NONE) {
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

  //                                                               -------------- CHK APP LISTEN Q AVAIL --------------
  if (p_conn->FnctAppListenQ_IsAvail != DEF_NULL) {
    q_avail = p_conn->FnctAppListenQ_IsAvail(conn_id_app);
  } else {
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidCtr);
    RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
    goto exit;
  }

exit:
  return (q_avail);
}

/****************************************************************************************************//**
 *                                   NetTCP_RxPktConnHandlerSignalConn()
 *
 * @brief    (1) Signal application layer that TCP/transport layer connection's state is now connected :
 *
 *           - (a) From passive SYN-RECEIVED             state,  signal application layer that
 *                       connection request received; connection accept now available.
 *
 *           - (b) From active  SYN-RECEIVED or SYN-SENT states, signal application layer that
 *                       connection request complete.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @param    state   Current TCP connection state at time of connection signal.
 *
 * @param    p_err   Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) The 'NET_CONN_CFG_FAMILY' pre-processor 'else'-conditional code will never be compiled/linked
 *                   since 'net_conn.h' ensures that the family type configuration constant (NET_CONN_CFG_FAMILY)
 *                   is configured with an appropriate family type value (see 'net_conn.h  CONFIGURATION ERRORS').
 *                   The 'else'-conditional code is included for completeness & as an extra precaution in case
 *                   'net_conn.h' is incorrectly modified.
 *******************************************************************************************************/
static void NetTCP_RxPktConnHandlerSignalConn(NET_TCP_CONN       *p_conn,
                                              NET_TCP_CONN_STATE state,
                                              RTOS_ERR           *p_err)
{
  NET_CONN_ID conn_id;
  NET_CONN_ID conn_id_app;
  CPU_BOOLEAN err_conn;

  conn_id = p_conn->ID_Conn;

  //                                                               ------------------- SIGNAL CONN --------------------
  switch (state) {
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:                   // See Note #1a.
                                                                // Get app conn id clone.
      conn_id_app = NetConn_ID_AppCloneGet(conn_id);
      if (conn_id_app == NET_CONN_ID_NONE) {
        RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
        goto exit;
      }
      //                                                           Signal app conn accept.
      NetSock_ConnSignalAccept((NET_SOCK_ID)conn_id_app,
                               (NET_CONN_ID)conn_id);
      break;

    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:                    // See Note #1b.
    case NET_TCP_CONN_STATE_SYNC_TXD:
      //                                                           Get app conn id.
      conn_id_app = NetConn_ID_AppGet(conn_id);
      if (conn_id_app == NET_CONN_ID_NONE) {
        RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
        goto exit;
      }
      //                                                           Signal app conn req.
      NetSock_ConnSignalReq((NET_SOCK_ID) conn_id_app);
      break;

    case NET_TCP_CONN_STATE_SYNC_RXD:                           // See Notes #1a & #1b.
                                                                // Get app conn id.
      err_conn = DEF_NO;
      conn_id_app = NetConn_ID_AppGet(conn_id);
      if (conn_id_app == NET_CONN_ID_NONE) {
        err_conn = DEF_YES;
      }

      if (err_conn == DEF_YES) {                                // If app conn id get failed, get app conn id clone.
        conn_id_app = NetConn_ID_AppCloneGet(conn_id);
        if (conn_id_app == NET_CONN_ID_NONE) {
          RTOS_ERR_SET(*p_err, RTOS_ERR_RX);
          goto exit;
        }
      }

      //                                                           Signal app conn req.
      NetSock_ConnSignalReq((NET_SOCK_ID)conn_id_app);

      //                                                           Signal app conn accept.
      NetSock_ConnSignalAccept((NET_SOCK_ID)conn_id_app,
                               conn_id);
      break;

    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                   NetTCP_RxPktConnHandlerSignalClose()
 *
 * @brief    Signal application layer that TCP/transport layer connection's state is now closed.
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    data_avail  Indicate whether application data is still available on the TCP connection's
 *                       application receive queue :
 *                       DEF_YES                         Application data is     available on the
 *                       closing TCP connection's application
 *                       receive queue.
 *                       DEF_NO                          Application data is NOT available for the
 *                       closing TCP connection's application
 *                       receive queue.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (1) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                       FIN-WAIT-2 STATE' states that "if the retransmission queue is empty, the user's
 *                       CLOSE can be acknowledged".
 *
 *                           - (b) However, TCP connection should signal the application layer that "the user's close
 *                       [is] acknowledged" whenever its re-transmit queue becomes &/or is empty :
 *
 *                           - (1) Transition from LISTEN     to CLOSED
 *                           - (2) Transition from SYN-SENT   to CLOSED
 *
 *                           - (3) Transition from FIN-WAIT-1 to ...           See also 'NetTCP_RxPktConnHandlerFinWait1()
 *                       Note #2d2B2'
 *                           - (A) FIN-WAIT-2
 *                           - (B) TIME-WAIT
 *
 *                           - (4) Transition from CLOSING    to TIME-WAIT     See also 'NetTCP_RxPktConnHandlerClosing()
 *                       Note #2d2B2a2'
 *
 *                           - (5) Transition from LAST-ACK   to CLOSED
 *
 * @note     (2) Once an application connection has been signaled of its close, the application connection is
 *                       responsible for closing its remaining connection(s).
 *
 *                       See also 'NetTCP_ConnCloseHandler()  Note #2b1B'.
 *
 * @note     (3) The 'NET_CONN_CFG_FAMILY' pre-processor 'else'-conditional code will never be compiled/linked
 *                       since 'net_conn.h' ensures that the family type configuration constant (NET_CONN_CFG_FAMILY)
 *                       is configured with an appropriate family type value (see 'net_conn.h  CONFIGURATION ERRORS').
 *                       The 'else'-conditional code is included for completeness & as an extra precaution in case
 *                       'net_conn.h' is incorrectly modified.
 *******************************************************************************************************/
static void NetTCP_RxPktConnHandlerSignalClose(NET_TCP_CONN *p_conn,
                                               CPU_BOOLEAN  data_avail,
                                               RTOS_ERR     *p_err)
{
  NET_CONN_ID conn_id;
  NET_CONN_ID conn_id_app;

  //                                                               Get conn id's.
  conn_id = p_conn->ID_Conn;
  conn_id_app = NetConn_ID_AppGet(conn_id);

  if (conn_id_app == NET_CONN_ID_NONE) {
    goto exit;
  }

  //                                                               ------------- VALIDATE TCP CONN STATE --------------
  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_LISTEN:                             // See Note #1b1.
    case NET_TCP_CONN_STATE_SYNC_TXD:                           // See Note #1b2.
    case NET_TCP_CONN_STATE_FIN_WAIT_1:                         // See Note #1b3.
    case NET_TCP_CONN_STATE_CLOSING:                            // See Note #1b4.
    case NET_TCP_CONN_STATE_LAST_ACK:                           // See Note #1b5.
      break;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    case NET_TCP_CONN_STATE_CLOSED:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  //                                                               ------------------- SIGNAL CLOSE -------------------
  //                                                               Signal app conn close.
  NetSock_ConnSignalClose((NET_SOCK_ID)conn_id_app,
                          data_avail,
                          p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit;
  }

  //                                                               Clr app close flag; ...
  p_conn->ConnCloseAppFlag = DEF_NO;                            // ... app closes rem'ing conn(s) [see Note #2].

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnIsValidSeq()
 *
 * @brief    Validate a received segment's sequence number with current TCP connection.
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @return   NET_TCP_CONN_RX_SEQ_INVALID,      if received sequence number invalid for the TCP connection.
 *
 *           NET_TCP_CONN_RX_SEQ_VALID,        if received sequence number   valid for the TCP connection.
 *
 *           NET_TCP_CONN_RX_SEQ_SYNC_INVALID, if received sequence number is an invalid synchronization
 *                                               for the TCP connection.
 *
 *           NET_TCP_CONN_RX_SEQ_SYNC,         if received sequence number is a    valid synchronization
 *                                               for the TCP connection.
 *
 * @note     (1) Validate received TCP connection sequence numbers :
 *
 *               - (A) Some TCP receive sequence number validation logic implemented in previous
 *                       functions; include duplicate validation logic in NetTCP_RxPktConnIsValidSeq()
 *                       only if debug/validation code is enabled.
 *
 *           - (a) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation : 1' states
 *                   that "if [a] connection [is] ... CLOSED then a reset is sent in response to any
 *                   incoming segment".  Thus ALL received segments are invalid.
 *
 *           - (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State]' :
 *
 *               - (1) "If the SYN bit is set ... the connection state should be changed to SYN-
 *                       RECEIVED ... and any other control or text should be queued for processing
 *                       later ... Note that any other incoming control or data ... will be processed
 *                       in the SYN-RECEIVED state."
 *
 *                       Therefore, the ONLY TCP segment data that may be queued in the LISTEN state
 *                       MUST be received in a TCP connection request segment.
 *
 *               - (2) Otherwise "any other control or text-bearing segment (not containing SYN)
 *                       must have an ACK and thus would be discarded by the ACK processing ...
 *                       [so] drop the segment".
 *
 *           - (c) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                   Check SYN Bit' :
 *
 *               - (1) "If ... our SYN has been ACKed ... change the connection state to
 *                       ESTABLISHED ... [and] if there are other controls or text in the
 *                       segment then continue processing" as for the ESTABLISHED state
 *                       (see Note #1d).
 *
 *               - (2) "Otherwise enter SYN-RECEIVED ... [and] if there are other controls or
 *                       text in the segment, queue them for processing after the ESTABLISHED
 *                       state has been reached."
 *
 *               - (3) Otherwise "if neither the SYN or RST bits is set then drop the segment".
 *
 *                       Therefore, the ONLY TCP segment data that may be queued in the SYN-SENT
 *                       state MUST be received in a TCP connection request segment.
 *
 *           - (d) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence
 *                   Number' states that for the "SYN-RECEIVED STATE, ESTABLISHED STATE, FIN-
 *                   WAIT-1 STATE, FIN-WAIT-2 STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK
 *                   STATE, TIME-WAIT STATE ... there are four cases for the acceptability test
 *                   for an incoming segment :
 *
 *                                   Local
 *                       Segment  Receive
 *                       Length   Window   Test
 *                       -------  -------  -------------------------------------------------------
 *
 *               - (1)     0        0        SEG.SEQ =  RCV.NXT
 *
 *               - (2)     0       >0        RCV.NXT =< SEG.SEQ               < RCV.NXT + RCV.WND
 *
 *               - (3)    >0        0        not acceptable
 *
 *               - (4)    >0       >0        RCV.NXT =< SEG.SEQ               < RCV.NXT + RCV.WND
 *                                           or RCV.NXT =< SEG.SEQ + SEG.LEN - 1 < RCV.NXT + RCV.WND
 *
 *                   If the RCV.WND is zero, no segments will be acceptable, but special allowance
 *                   should be made to accept valid ACKs ... and RSTs.
 *
 *                   If an incoming segment is not acceptable, an acknowledgment should be sent in
 *                   reply".
 *
 *                   See also Note #2.
 *
 *           - (e) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN Bit'
 *                   states that in the "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT STATE-1,
 *                   FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-WAIT
 *                   STATE ... if the SYN is in the window it is an error, send a reset, any
 *                   outstanding RECEIVEs and SEND[s] should receive 'reset' responses, all segment
 *                   queues should be flushed, the user should also receive an unsolicited general
 *                   'connection reset' signal[, and] enter the CLOSED state".
 *
 * @note     (2) RFC #793 does NOT provide nor suggest any logic to determine/handle sequence number
 *               comparisons for sequence number windows that overflow the sequence number space.
 *
 *           - (a) For example, the next sequence octet to receive (RCV.NXT) is typically less than
 *                   or equal to  the next received sequence octet (SEG.SEQ) :
 *
 *                   - (1) RCV.NXT <= SEG.SEQ
 *
 *                   SEG.SEQ itself is also typically less than RCV.NXT plus the current receive window
 *                   size (RCV.WND) :
 *
 *                   - (2) SEG.SEQ < (RCV.NXT + RCV.WND)
 *
 *                   However, if (RCV.NXT + RCV.WND) or SEG.SEQ overflows the sequence number space,
 *                   these values will be MUCH less than SEG.SEQ or RCV.NXT, respectively, until
 *                   SEG.SEQ & RCV.NXT also overflow :
 *
 *                   - (3) RCV.NXT + RCV.WND << RCV.NXT
 *                                           << SEG.SEQ
 *
 *                   - (4) SEG.SEQ           << RCV.NXT
 *
 *           - (b) Therefore, in order to validate a received segment's sequence value as within the
 *                   TCP connection's current receive window, one of the following unsigned arithmetic
 *                   comparisons MUST be true :
 *
 *                   - (1) (A) (RCV.NXT + RCV.WND) -  SEG.SEQ       <=  (RCV.NXT + RCV.WND) - RCV.NXT
 *
 *                       - (B) (RCV.NXT + RCV.WND) -  SEG.SEQ       <=             RCV.WND
 *
 *                       - (C) (RCV.NXT + RCV.WND) -  SEG.SEQ - 1   <   RCV.WND
 *
 *                       - (D) (RCV.NXT + RCV.WND) - (SEG.SEQ + 1)  <   RCV.WND
 *
 *                           - (a) Comparison #2b1C's left-hand side decremented by one to modify the
 *                                   conditional test from less-than-or-equal-to to just less-than in
 *                                   order to satisfy the exact boundary conditions shown in the incoming
 *                                   segment acceptability test comparisons (see Notes #1d2 & #1d4).
 *
 *                   - (2) Substituting (SEG.SEQ + SEG.LEN - 1) into SEG.SEQ :
 *
 *                       - (A) (RCV.NXT + RCV.WND)  -  (SEG.SEQ + SEG.LEN - 1 + 1)  <  RCV.WND
 *
 *                       - (B) (RCV.NXT + RCV.WND)  -  (SEG.SEQ + SEG.LEN)          <  RCV.WND
 *
 *           - (c) In order to determine if a received segment's sequence value is within but NOT
 *                   following a closing TCP connection's last valid receive sequence numbers, the
 *                   following unsigned arithmetic comparison MUST be checked :
 *
 *                   - (1)  RX.LAST  - (SEG.SEQ + SEG.LEN)  <=  (RX.LAST - RX.NXT)
 *******************************************************************************************************/
static NET_TCP_SEQ_CODE NetTCP_RxPktConnIsValidSeq(NET_TCP_CONN *p_conn,
                                                   NET_BUF_HDR  *p_buf_hdr)
{
  NET_TCP_SEQ_CODE seq_code = NET_TCP_CONN_RX_SEQ_INVALID;
  NET_TCP_SEQ_NBR  seq_nbr;
  NET_TCP_SEQ_NBR  seq_win;
  NET_TCP_SEQ_NBR  seq_win_next;
  NET_TCP_SEQ_NBR  seq_win_delta;

  if (p_conn != DEF_NULL) {
    switch (p_conn->ConnState) {
      case NET_TCP_CONN_STATE_CLOSED:                           // See Note #1a.
        break;

      case NET_TCP_CONN_STATE_LISTEN:                           // See Note #1b.
        if (p_buf_hdr->TCP_SegSync == DEF_YES) {                // If sync rx'd, ..
          seq_code = NET_TCP_CONN_RX_SEQ_SYNC;                  // .. sync's seq nbr valid (see Note #1b1).
        }
        break;

      case NET_TCP_CONN_STATE_SYNC_TXD:                         // See Note #1c.
        if (p_buf_hdr->TCP_SegSync == DEF_YES) {                // If valid sync rx'd, ..
          seq_code = NET_TCP_CONN_RX_SEQ_SYNC;                  // .. sync's seq nbr valid.
        }
        break;

      case NET_TCP_CONN_STATE_SYNC_RXD:                         // See Notes #1d & #1e.
      case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
      case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
      case NET_TCP_CONN_STATE_CONN:
      case NET_TCP_CONN_STATE_FIN_WAIT_1:
      case NET_TCP_CONN_STATE_FIN_WAIT_2:
      case NET_TCP_CONN_STATE_CLOSING:
      case NET_TCP_CONN_STATE_TIME_WAIT:
      case NET_TCP_CONN_STATE_CLOSE_WAIT:
      case NET_TCP_CONN_STATE_LAST_ACK:
        if (p_buf_hdr->TCP_SegSync != DEF_NO) {                 // If sync rx'd, ...
          seq_code = NET_TCP_CONN_RX_SEQ_SYNC_INVALID;
          goto exit;                                            // ... rtn invalid sync (see Note #1e).
        }

        if (p_conn->RxWinSizeActual > 0) {                      // If rx win size > 0, ...
                                                                // ... chk for seg seq within rx win.
          switch (p_conn->RxQ_State) {
            case NET_TCP_RX_Q_STATE_SYNC:
            case NET_TCP_RX_Q_STATE_CONN:
              seq_win_next = (NET_TCP_SEQ_NBR)(p_conn->RxSeqNbrNext  + p_conn->RxWinSizeActual);
              seq_nbr = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + 1u);
              seq_win_delta = (NET_TCP_SEQ_NBR)(seq_win_next         - seq_nbr);

              if (seq_win_delta == p_conn->RxWinSizeActual) {
                //                                                 Keep-Alive message received.
                seq_code = NET_TCP_CONN_RX_SEQ_KEEP_ALIVE;
              } else if (seq_win_delta < p_conn->RxWinSizeActual) {
                //                                                 If [(next + win) -     seq    ] < win size,
                seq_code = NET_TCP_CONN_RX_SEQ_VALID;                   // .. seq nbr within rx win (see Note #1d2).
              } else if (p_buf_hdr->TCP_SegLen > 0) {
                seq_nbr = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + p_buf_hdr->TCP_SegLen);
                seq_win_delta = (NET_TCP_SEQ_NBR)(seq_win_next         - seq_nbr);
                //                                                 If [(next + win) - (seq + len)] < win size,
                if (seq_win_delta < p_conn->RxWinSizeActual) {
                  //                                               .. seq nbr within rx win (see Note #1d4).
                  seq_code = NET_TCP_CONN_RX_SEQ_VALID;
                }
              } else {
                ;
              }
              break;

            case NET_TCP_RX_Q_STATE_CLOSED:
            case NET_TCP_RX_Q_STATE_CLOSING:
              seq_win_next = p_conn->RxSeqNbrLast;
              seq_nbr = (NET_TCP_SEQ_NBR)(p_buf_hdr->TCP_SeqNbr + p_buf_hdr->TCP_SegLen);
              seq_win_delta = seq_win_next - seq_nbr;
              seq_win = p_conn->RxSeqNbrLast  - p_conn->RxSeqNbrNext;
              if (seq_win_delta <= seq_win) {                   // If [last - (seq + len)] <= [last - next], ..
                seq_code = NET_TCP_CONN_RX_SEQ_VALID;                   // .. seq nbr within close win (see Note #2c1).
              }
              break;

            case NET_TCP_RX_Q_STATE_NONE:
            default:
              seq_code = NET_TCP_CONN_RX_SEQ_INVALID;
              goto exit;
          }
        } else {                                                // Else chk for valid, zero-len seg.
          if (p_buf_hdr->TCP_SegLenData > 0) {                  // If seg len > 0, ...
            seq_code = NET_TCP_CONN_RX_SEQ_INVALID;
            NET_CTR_ERR_INC(Net_ErrCtrs.TCP.RxHdrSegLenCtr);
            goto exit;                                          // ... rtn invalid seg len (see Note #1d3).
          }

          if (p_buf_hdr->TCP_SeqNbr == p_conn->RxSeqNbrNext) {            // If seq nbr equals next rx seq expected, ..
            seq_code = NET_TCP_CONN_RX_SEQ_VALID;               // .. seq nbr valid (see Note #1d1).
          }
        }
        break;

      case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
        break;

      case NET_TCP_CONN_STATE_FREE:
      case NET_TCP_CONN_STATE_NONE:
      default:
        RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, NET_TCP_CONN_RX_SEQ_INVALID);
    }
  }

exit:
  return (seq_code);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnIsValidAck()
 *
 * @brief    Validate a received segment's acknowledgement number with current TCP connection.
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @return   NET_TCP_CONN_RX_ACK_INVALID, if    received acknowledgement number invalid for the TCP connection.
 *
 *           NET_TCP_CONN_RX_ACK_VALID,   if    received acknowledgement number   valid for the TCP connection.
 *
 *           NET_TCP_CONN_RX_ACK_NONE,    if NO received acknowledgement number.
 *
 *           NET_TCP_CONN_RX_ACK_DUP,     if    received acknowledgement number is a          duplicate for the
 *                                           TCP connection.
 *
 *           NET_TCP_CONN_RX_ACK_PREV,    if    received acknowledgement number is a previous duplicate for the
 *                                           TCP connection.
 *
 * @note     (1) Validate received TCP connection acknowledgements :
 *
 *           - (a) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation : 1' states
 *                   that "if [a] connection [is] ... CLOSED then a reset is sent in response to any
 *                   incoming segment".  Thus ALL received segments, including acknowledgement
 *                   segments, are invalid.
 *
 *           - (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State] :
 *                   Check for ACK' states that "any acknowledgment is bad if it arrives on a
 *                   connection still in the LISTEN state".
 *
 *           - (c) (1) The following sections generalize that "if SND.UNA < SEG.ACK =< SND.NXT then
 *                       the ACK is acceptable", whereas "if SEG.ACK =< SND.UNA, or SEG.ACK > SND.NXT"
 *                       then the acknowledgement is unacceptable :
 *
 *                   - (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT
 *                               [State] : Check ACK Bit'
 *                   - (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK
 *                               Field : SYN-RECEIVED STATE'
 *                   - (C) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK
 *                               Field : ESTABLISHED  STATE'
 *
 *                       Including states with similar "processing as for the ESTABLISHED STATE" (see
 *                       RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field') :
 *
 *                   - (D) FIN-WAIT-1 STATE
 *                   - (E) FIN-WAIT-2 STATE
 *                   - (F) CLOSING    STATE
 *                   - (G) CLOSE-WAIT STATE
 *
 *                       See also Note #3a.
 *
 *               - (2) However, RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT
 *                       [State] : Check SYN Bit' also states to "check the SYN bit ... if the ACK is
 *                       ok, or there is no ACK".
 *
 *                       Therefore, the lack of an acknowledgement in the SYN-SENT state is acceptable.
 *
 *               - (3) However, RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check
 *                       ACK Field : ESTABLISHED STATE' also states that in the "ESTABLISHED STATE"
 *                       or any state with similar "processing as for the ESTABLISHED STATE ... if
 *                       the ACK is a duplicate (SEG.ACK =< SND.UNA), it can be ignored".
 *
 *                       See also Note #3b.
 *
 *           - (d) (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                           TIME-WAIT STATE' states that "the only thing that can arrive in this state is
 *                           a retransmission of the remote FIN".
 *
 *                   - (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                           LAST-ACK STATE' states that "the only thing that can arrive in this state is
 *                           an acknowledgement of our FIN".
 *
 *               - (2) However, it is possible that some but NOT all transmitted data has been received
 *                       by the remote host.  In other words, the remote host may have received some but
 *                       NOT ALL transmitted data preceding this host's connection close request.
 *
 *                       Therefore, acknowledgements validated by as within the transmit window MUST
 *                       be received & processed as in connected states.
 *
 * @note     (2) RFC #793 contains multiple errors/inconsistencies regarding the boundary conditions
 *               of TCP sequence/acknowledgement inequalities -- i.e. some of the expressions incorrectly
 *               include or exclude the equality condition.
 *
 *               RFC #1122, Section 4.2.2.20 corrects some but NOT all of these errors/inconsistencies.
 *
 * @note     (3) RFC #793 does NOT provide nor suggest any logic to determine/handle sequence number
 *               comparisons for sequence number windows that overflow the sequence number space.
 *
 *           - (a) (1) For example, the next sequence octet to transmit (SND.NXT) is typically greater
 *                       than or equal to the last unacknowledged transmit sequence octet (SND.UNA) :
 *
 *                       - (A) SND.NXT >= SND.UNA
 *
 *                       However, when SND.NXT overflows the sequence number space, it will be MUCH less
 *                       than SND.UNA until SND.UNA also overflows :
 *
 *                       - (B) SND.NXT << SND.UNA
 *
 *               - (2) Therefore, in order to validate a received segment's acknowledgement value
 *                       (SEG.ACK) as within the TCP connection's current transmit acknowledgement
 *                       window, the following unsigned arithmetic comparison MUST be true :
 *
 *                       - (A) (SND.NXT - SEG.ACK)  <  (SND.NXT - SND.UNA)
 *
 *           - (b) (1) Typically, duplicate acknowledgements are less than or equal to the last
 *                       unacknowledged transmit sequence octet (SND.UNA) :
 *
 *                       - (A) SEG.ACK <= SND.UNA
 *
 *                       However, when SND.UNA overflows the sequence number space, it will be MUCH less
 *                       than duplicate acknowledgements until these duplicates also overflow :
 *
 *                       - (B) SEG.ACK >> SND.UNA
 *
 *               - (2) Therefore, in order to validate SEG.ACK as a recent duplicate acknowledgement
 *                       for the TCP connection's current transmit acknowledgement window, the following
 *                       unsigned arithmetic comparison MUST be true :
 *
 *                       - (A) (SND.UNA - SEG.ACK)  <=  (WIN_SIZE_SCALE * TxWinSizeRemote)
 *
 *                                   where
 *
 *                                       WIN_SIZE_SCALE          is some window-size scalar multiplier
 *                                       TxWinSizeRemote         is the remote host's last-advertised
 *                                                                   receive window size, which is this
 *                                                                   host's transmit remote window size
 *******************************************************************************************************/
static NET_TCP_ACK_CODE NetTCP_RxPktConnIsValidAck(NET_TCP_CONN *p_conn,
                                                   NET_BUF_HDR  *p_buf_hdr)
{
  NET_TCP_ACK_CODE ack_code = NET_TCP_CONN_RX_ACK_INVALID;
  NET_TCP_SEQ_NBR  ack_delta_next;
  NET_TCP_SEQ_NBR  ack_delta_unackd;
  NET_TCP_SEQ_NBR  ack_win;
  NET_TCP_SEQ_NBR  ack_dup_win;

  if (p_conn != DEF_NULL) {
    switch (p_conn->ConnState) {
      case NET_TCP_CONN_STATE_CLOSED:                           // See Note #1a.
      case NET_TCP_CONN_STATE_LISTEN:                           // See Note #1b.
        if (p_buf_hdr->TCP_SegAck != DEF_NO) {                  // If ack rx'd, ...
          ack_code = NET_TCP_CONN_RX_ACK_INVALID;               // ... rtn invalid ack.
          goto exit;
        }
        ack_code = NET_TCP_CONN_RX_ACK_NONE;
        break;

      case NET_TCP_CONN_STATE_SYNC_TXD:
        if (p_buf_hdr->TCP_SegAck == DEF_NO) {                  // If NO ack rx'd, ...
          ack_code = NET_TCP_CONN_RX_ACK_NONE;                  // ... rtn valid ack (see Note #1c2).
          goto exit;
        }
      //                                                           'break' intentionally omitted; MUST execute ...
      //                                                           ...  the following case (see Note #1c1A) :  ...
      //                                                           fallthrough
      //                                                           -------- ... 'NET_TCP_CONN_STATE_SYNC_RXD'. --------
      case NET_TCP_CONN_STATE_SYNC_RXD:                         // See Note #1c1B.
      case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
      case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
        if (p_buf_hdr->TCP_SegAck != DEF_YES) {                 // If NO ack rx'd, ...
          ack_code = NET_TCP_CONN_RX_ACK_NONE;                  // ... rtn NO ack.
          goto exit;
        }

        ack_delta_next = p_conn->TxSeqNbrNext - p_buf_hdr->TCP_AckNbr;
        ack_win = p_conn->TxSeqNbrNext - p_conn->TxSeqNbrUnAckd;

        if (p_buf_hdr->TCP_SegClose == DEF_YES) {
          ack_win++;
        }

        if (ack_delta_next < ack_win) {                         // If (next - ack) < ack win, ...
          ack_code = NET_TCP_CONN_RX_ACK_VALID;                 // ... ack is within ack win (see Note #3a2A).
        }
        break;

      case NET_TCP_CONN_STATE_CONN:                             // See Note #1c1C.
      case NET_TCP_CONN_STATE_FIN_WAIT_1:                       // See Note #1c1D.
      case NET_TCP_CONN_STATE_FIN_WAIT_2:                       // See Note #1c1E.
      case NET_TCP_CONN_STATE_CLOSING:                          // See Note #1c1F.
      case NET_TCP_CONN_STATE_CLOSE_WAIT:                       // See Note #1c1G.
      case NET_TCP_CONN_STATE_TIME_WAIT:                        // See Note #1d2.
      case NET_TCP_CONN_STATE_LAST_ACK:                         // See Note #1d2.
        if (p_buf_hdr->TCP_SegAck != DEF_YES) {                 // If NO ack rx'd, ...
          ack_code = NET_TCP_CONN_RX_ACK_NONE;                  // ... rtn NO ack.
          goto exit;
        }

        ack_delta_next = p_conn->TxSeqNbrNext - p_buf_hdr->TCP_AckNbr;
        ack_win = p_conn->TxSeqNbrNext - p_conn->TxSeqNbrUnAckd;

        if (p_buf_hdr->TCP_SegClose == DEF_YES) {
          ack_win++;
        }

        if (ack_delta_next < ack_win) {                         // If (next - ack) < ack win, ...
          ack_code = NET_TCP_CONN_RX_ACK_VALID;                 // ... ack is within ack win (see Note #3a2A).
        } else {
          ack_delta_unackd = p_conn->TxSeqNbrUnAckd - p_buf_hdr->TCP_AckNbr;
          if (ack_delta_unackd < 1) {                           // If (unackd - ack) = 0, ...
            ack_code = NET_TCP_CONN_RX_ACK_DUP;                 // ... ack is           dup ack.
                                                                // ... (see Note  #1c3).
          } else {
            ack_dup_win = (NET_TCP_SEQ_NBR)(NET_TCP_ACK_NBR_DUP_WIN_SIZE_SCALE * p_conn->TxWinSizeRemote);
            if (ack_delta_unackd <= ack_dup_win) {              // If (unackd - ack) <= dup ack win, ...
              ack_code = NET_TCP_CONN_RX_ACK_PREV;                 // ... ack is recent    dup ack      ...
                                                                   // ... (see Notes #1c3 & #3b2A).
            } else {
              ack_code = NET_TCP_CONN_RX_ACK_OTW;
            }
          }
        }
        break;

      case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
        break;

      case NET_TCP_CONN_STATE_FREE:
      case NET_TCP_CONN_STATE_NONE:
      default:
        RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, NET_TCP_CONN_RX_ACK_INVALID);
    }
  }

exit:
  return (ack_code);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxPktConnIsValidReset()
 *
 * @brief    Validate a received segment's reset flag, if any, with current TCP connection.
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @return   NET_TCP_CONN_RX_RESET_INVALID, if    received reset flag invalid for the TCP connection.
 *
 *           NET_TCP_CONN_RX_RESET_VALID,   if    received reset flag   valid for the TCP connection;
 *                                               i.e. reset the TCP connection.
 *
 *           NET_TCP_CONN_RX_RESET_NONE,    if NO received reset flag.
 *
 * @note     (1) See the following RFC's for TCP reset validation summary :
 *
 *           - (a) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing'
 *           - (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES'
 *           - (c) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2
 *
 * @note     (2) Validate received TCP connection resets :
 *
 *               - (A) Some TCP receive reset validation logic implemented in previous functions; include
 *                       duplicate validation logic in NetTCP_RxPktConnIsValidReset() only if debug/validation
 *                       code is enabled.
 *
 *           - (a) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : CLOSED [State]' states
 *                       that "if the state is CLOSED ... an incoming segment containing a RST is discarded".
 *
 *               - (2) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State]'
 *                           states that if "the state is LISTEN ... an incoming RST should be ignored".
 *
 *                   - (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
 *                           that "if the receiver ... of a RST ... was in the LISTEN state, it ignores it".
 *
 *               - (3) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                           Check RST Bit' states that "if the RST bit is set [and] if the ACK was
 *                           acceptable then ... enter CLOSED state".
 *
 *                   - (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' reiterates
 *                           that "in the SYN-SENT state (a RST received in response to an initial SYN), the
 *                           RST is acceptable if the ACK field acknowledges the SYN".
 *
 *                       - (1) However, since receiving a TCP connection request/synchronization segment
 *                               with no acknowledgement number in the SYN-SENT state is permitted, then
 *                               a received TCP reset segment with no acknowledgement number MUST also be
 *                               acceptable.
 *
 *                       See also Note #2a5C.
 *
 *               - (4) (A) (1) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing'
 *                               summarizes that "in all states except SYN-SENT, all reset (RST) segments
 *                               are validated by checking their SEQ-fields.  A reset is valid if its
 *                               sequence number is in the window".
 *
 *                       - (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
 *                               reiterates that the received segment's reset is valid if and only if its
 *                               sequence number is valid since it follows RFC #793, Section 3.9 'Event
 *                               Processing : SEGMENT ARRIVES : Check Sequence Number'.
 *
 *                       - (3) RFC #793, Section 3.3 states "that when the receive window is zero no
 *                               segments should be acceptable except ACK segments ... However, even when
 *                               the receive window is zero, a TCP must process the RST ... fields of all
 *                               incoming segments".
 *
 *                               However, this contradicts the following sections which state that a
 *                               "received segment's reset is valid if and only if its sequence number if
 *                               valid" & that "if an incoming segment is not acceptable ... [and] the RST
 *                               bit is set, ... drop the segment" :
 *
 *                           - (a) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing'
 *                           - (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check
 *                                       Sequence Number'
 *
 *                           See also Note #2a5B.
 *
 *                   - (B) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
 *                               states that in the "SYN-RECEIVED STATE" that "if the RST bit is set [and]
 *                               this connection was initiated with a passive OPEN (i.e., came from the
 *                               LISTEN state), then return this connection to the LISTEN state ... If this
 *                               connection was initiated with an active OPEN (i.e., came from SYN-SENT state)
 *                               then the connection was refused, ... enter the CLOSED state".
 *
 *                       - (2) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing'
 *                               reiterates that "if the receiver ... of a RST ... was in SYN-RECEIVED state
 *                               and had previously been in the LISTEN state, then the receiver returns to
 *                               the LISTEN state, otherwise the receiver aborts the connection and goes to
 *                               the CLOSED state".
 *
 *                       - (3) However, since TCP connections opened from the LISTEN state are cloned from
 *                               the original LISTEN-state TCP connection, it is NOT necessary to return ANY
 *                               reset TCP connection from the SYN-RECEIVED state back to the LISTEN state.
 *
 *                           See also Note #2a5A.
 *
 *                   - (C) (1) RFC #793, Section 3.4 'Establishing a Connection : Reset Processing' states
 *                               that "if the receiver ... of a RST ... was in any other state [other than
 *                               LISTEN or SYN-RECEIVED], it aborts the connection and advises the user and
 *                               goes to the CLOSED state".
 *
 *                       - (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
 *                               states that in the "ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT" states
 *                               that "if the RST bit is set then, any outstanding RECEIVEs and SEND[s] should
 *                               receive 'reset' responses.  All segment queues should be flushed.  Users
 *                               should also receive an unsolicited general 'connection reset' signal[, and]
 *                               enter the CLOSED state".
 *
 *                       - (3) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
 *                               states that in the "CLOSING STATE, LAST-ACK STATE, TIME-WAIT" states that
 *                               "if the RST bit is set then, enter the CLOSED state".
 *
 *                           See also Note #2a5A.
 *
 *               - (5) (A) RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling of a segment
 *                           with the RST bit when in a synchronized state" to "provide some protection against
 *                           ... blind reset attack[s] using the RST bit" :
 *
 *                       - (a) "If the RST bit is set and the sequence number is outside the expected window,
 *                               silently drop the segment."
 *
 *                       - (b) "If the RST bit is exactly the next expected sequence number [sic], reset the
 *                               connection"; it is assumed that this should read "if the RST bit is set and
 *                               the sequence number is exactly the next expected sequence number, reset the
 *                               connection."
 *
 *                       - (c) "If the RST bit is set and the sequence number does not exactly match
 *                               the next expected sequence value, yet is within the acceptable window
 *                               (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send an acknowledgment."
 *
 *                   - (B) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that this
 *                           amendment applies only to the "handling of a ... RST ... when in a synchronized
 *                           state", it is assumed that this should also apply to the SYN-RECEIVED state.
 *
 *                   - (C) (1) In addition, it is assumed that a similar validation should also
 *                               apply to the SYN-SENT state.  Since the SYN-SENT state validates a
 *                               received TCP reset segment based only on the segment's acknowledgement,
 *                               a similar validation could require that the acknowledgement "exactly
 *                               match the next expected sequence value" -- i.e. the initial connection
 *                               synchronization sequence number plus one.
 *
 *                       - (2) However, a specific check for the exact acknowledgement is NOT necessary
 *                               since NO data is transmitted from the SYN-SENT state.  Therefore, the ONLY
 *                               value to be acknowledged is the initial connection synchronization sequence
 *                               number.
 *
 *                   - (D) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a precedence
 *                           priority for handling TCP segments received with BOTH the RST & SYN bits set.
 *
 *                           Therefore, since it does NOT seem reasonable to reset a TCP connection
 *                           due to a TCP segment that also attempted to synchronize the TCP connection,
 *                           it is assumed that the amended handling of the SYN bit should take precedence
 *                           over the amended handling of the RST bit.
 *
 *           - (b) RFC #1122, Section 4.2.2.12 states that "a TCP SHOULD allow a received RST segment
 *                   to include data".
 *******************************************************************************************************/
static NET_TCP_RESET_CODE NetTCP_RxPktConnIsValidReset(NET_TCP_CONN *p_conn,
                                                       NET_BUF_HDR  *p_buf_hdr)
{
  NET_TCP_RESET_CODE reset_code = NET_TCP_CONN_RX_RESET_INVALID;

  if (p_buf_hdr->TCP_SegReset != DEF_YES) {                     // If NO reset rx'd, ...
    reset_code = NET_TCP_CONN_RX_RESET_NONE;                    // ... rtn NONE.
    goto exit;
  }

  if (p_conn != DEF_NULL) {
    switch (p_conn->ConnState) {
      case NET_TCP_CONN_STATE_CLOSED:                           // See Note #2a1.
      case NET_TCP_CONN_STATE_LISTEN:                           // See Note #2a2.
        break;

      case NET_TCP_CONN_STATE_SYNC_TXD:                         // See Note #2a3.
        reset_code = NET_TCP_CONN_RX_RESET_VALID;
        break;

      case NET_TCP_CONN_STATE_SYNC_RXD:                         // See Notes #2a4B & #2a5B.
      case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
      case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
      case NET_TCP_CONN_STATE_CONN:                             // See Notes #2a4C & #2a5A.
      case NET_TCP_CONN_STATE_FIN_WAIT_1:
      case NET_TCP_CONN_STATE_FIN_WAIT_2:
      case NET_TCP_CONN_STATE_CLOSING:
      case NET_TCP_CONN_STATE_TIME_WAIT:
      case NET_TCP_CONN_STATE_CLOSE_WAIT:
      case NET_TCP_CONN_STATE_LAST_ACK:
        if (p_buf_hdr->TCP_SeqNbr == p_conn->RxSeqNbrNext) {          // If seq nbr equals next rx seq expected ...
          reset_code = NET_TCP_CONN_RX_RESET_VALID;             // ... (see Note #2a5Ab), rtn valid reset.
        }
        break;

      case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
        break;

      case NET_TCP_CONN_STATE_FREE:
      case NET_TCP_CONN_STATE_NONE:
      default:
        RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, NET_TCP_CONN_RX_RESET_INVALID);
        goto exit;
    }
  }

exit:
  return (reset_code);
}

/****************************************************************************************************//**
 *                                           NetTCP_RxPktFree()
 *
 * @brief    Free network buffer(s).
 *
 * @param    p_buf_q     Pointer to network buffer queue.
 *******************************************************************************************************/
static NET_BUF_QTY NetTCP_RxPktFree(NET_BUF *p_buf_q)
{
  NET_BUF_QTY nbr_freed;

  nbr_freed = NetBuf_FreeBufQ_PrimList(p_buf_q, DEF_NULL);

  return (nbr_freed);
}

/****************************************************************************************************//**
 *                                           NetTCP_RxConnWinSizeCfg()
 *
 * @brief    (1) Configure TCP connection's receive window controls :
 *
 *           - (a) Configure TCP connection's receive window update threshold
 *
 *
 * Argument(s) : p_conn       Pointer to a TCP connection.
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) A TCP connection's receive window controls SHOULD be updated only after the
 *                   following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's configured receive window  size ('RxWinSizeCfgd')
 *                   [see 'NetTCP_RxConnWinSizeCfgUpdateTh()  Note #2a']
 *
 *                       - (b) TCP connection's connection maximum segment size ('MaxSegSizeConn')
 *                   [see 'NetTCP_RxConnWinSizeCfgUpdateTh()  Note #2b']
 *
 * @note     (3) RFC #1122, Section 4.2.3.3 states that "the suggested SWS avoidance algorithm for
 *                   the receiver is ... to avoid advancing the right window edge RCV.NXT+RCV.WND ...
 *                   until the reduction satisfies" :
 *
 *                       - (a) RCV.BUFF - RCV.USER - RCV.WND  >=  min(Fr * RCV.BUFF, Eff.snd.MSS)
 *
 *                   where
 *                       - (1) RCV.BUFF        Total receive buffer space
 *                       - (2) RCV.USER        Data  received but not yet consumed
 *                       - (3) RCV.WND         Space advertised to sender
 *                       - (4) Fr              Fraction whose recommended value is 1/2
 *                       - (5) Eff.snd.MSS     Effective send MSS for the connection
 *
 * @note     (4) A TCP connection's receive window update threshold SHOULD be updated only after
 *                   the following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's configured receive window  size ('RxWinSizeCfgd')
 *                   [see 'NetTCP_ConnClr()  Note #4']
 *
 *                       - (b) TCP connection's connection maximum segment size ('MaxSegSizeConn')
 *                   [see 'NetTCP_ConnCfgMaxSegSize()  Note #1']
 *******************************************************************************************************/
static void NetTCP_RxConnWinSizeCfg(NET_TCP_CONN *p_conn)
{
  NET_TCP_WIN_SIZE rx_win_size_th;

  p_conn->RxWinSizeCalcd = p_conn->RxWinSizeCfgd;
  p_conn->RxWinSizeActual = p_conn->RxWinSizeCfgd;

  //                                                               Cfg silly win min th (see Note #3a).
  rx_win_size_th = (p_conn->RxWinSizeCfgd * NET_TCP_RX_SILLY_WIN_NUMER) / NET_TCP_RX_SILLY_WIN_DENOM;
  p_conn->RxWinSizeUpdateTh = DEF_MIN(p_conn->MaxSegSizeConn, rx_win_size_th);
}

/****************************************************************************************************//**
 *                                       NetTCP_RxConnWinSizeHandler()
 *
 * @brief    (1) Handle TCP connection's receive window :
 *
 *           - (a) Handle   TCP connection receive window                      See Notes #2 & #3
 *           - (b) Transmit TCP connection acknowledgment                      See Note  #4
 *
 * @param    p_conn              Pointer to a TCP connection.
 *
 * @param    p_buf_hdr           Pointer to network buffer header that received TCP packet.
 *
 * @param    win_update_size     Size to update TCP connection's receive window (in octets).
 *
 * @param    win_update_code     Indicate how to update TCP connection receive window :
 *                               NET_TCP_CONN_RX_WIN_RESET   Reset     TCP connection's available
 *                               receive window size.
 *                               NET_TCP_CONN_RX_WIN_INIT    Init      TCP connection's available
 *                               receive window size.
 *                               NET_TCP_CONN_RX_WIN_INC     Increment TCP connection's available
 *                               receive window size.
 *                               NET_TCP_CONN_RX_WIN_DEC     Decrement TCP connection's available
 *                               receive window size.
 *
 * @note     (2) RFC #793, Section 3.7 'Data Communication : Managing the Window' states that :
 *
 *                                   - (a) "The window sent in each segment indicates the range of sequence numbers the
 *                               sender of the window (the data receiver) is currently prepared to accept.
 *                               There is an assumption that this is related to the currently available data
 *                               buffer space available for this connection."
 *
 *                                   - (1) A TCP connection's advertised receive window MUST NEVER be decreased to zero
 *                               if NO receive data is available & ready to be read by the application layer.
 *
 *                               In other words, if NO received data starting from the next expected receive
 *                               sequence number(s) is queued, then NO data is available to be read by the
 *                               application layer.  Therefore, the receive window size MUST NOT be decreased
 *                               to zero, otherwise the receive window would deadlock since the application
 *                               layer would NOT be able to read & extract any data from the receive window
 *                               & the TCP connection would NOT be able to receive any more data into the
 *                               receive window.
 *
 *                               See also 'NetTCP_RxPktConnHandlerRxQ_AppData()  Note #6b'.
 *
 *                                   - (b) "The mechanisms provided allow a TCP to advertise a large window and to
 *                               subsequently advertise a much smaller window without having accepted that
 *                               much data.  This ... 'shrinking the window' is strongly discouraged.  The
 *                               robustness principle dictates that TCPs will not shrink the window ... but
 *                               will be prepared for such behavior on the part of other TCPs."
 *
 *                                   - (c) "Note that ... acknowledgments should not be delayed or unnecessary
 *                               retransmissions will result.  One strategy would be to send an acknowledgment
 *                               when a small segment arrives (with out [sic] updating the window information),
 *                               and then to send another acknowledgment with new window information when the
 *                               window is larger."
 *
 *                                   - (1) However, the following sections retract this delayed acknowledgement
 *                               prohibition & state that "a TCP SHOULD implement a delayed ACK" :
 *
 *                                   - (A) RFC # 813, Section 5
 *                                   - (B) RFC #1122, Section 4.2.3.2
 *                                   - (C) RFC #2581, Section 4.2
 *
 *                               See also Note #4 & 'NetTCP_TxConnAck()  Note #6'.
 *
 * @note     (3) (a) RFC #813, Section 2 states that "a bad implementation of the window algorithm
 *                               can lead to extremely poor performance ... This particular phenomenon ... has
 *                               been given the name of Silly Window Syndrome, or SWS".
 *
 *                               Section 3 elaborates that "SWS is a degeneration in the throughput which develops
 *                               ... whenever the acknowledgement of a small segment ... cause[s] another segment
 *                               of the same small size to be sent, until ... the network ... becomes clogged with
 *                               many small segments, and an equal number of acknowledgements".
 *
 *                                   - (b) (1) RFC #813, Section 4 states that "the receiver of data can take a very simple
 *                               step to eliminate SWS.  When it disposes of a small amount of data, it can
 *                               artificially reduce the offered window in subsequent acknowledgements, so
 *                               that the useable window computed by the sender does not permit the sending
 *                               of any further data.
 *
 *                               At some later time, when the receiver has processed a substantially larger
 *                               amount of incoming data, the artificial limitation on the offered window
 *                               can be removed all at once, so that the sender computes a sudden large jump
 *                               rather than a sequence of small jumps in the useable window.
 *
 *                               For a simple implementation, ... artificially reduce the offered window until
 *                               the reduction constitutes one half of the available space ... [or] at least
 *                               permit one reasonably large segment".
 *
 *                                   - (2) RFC #1122, Section 4.2.3.3 reiterates that "a TCP MUST include a SWS avoidance
 *                               algorithm in the receiver ... This algorithm combines with the delayed ACK
 *                               algorithm ... to determine when an ACK segment containing the current window
 *                               will really be sent to the receiver [sic]".
 *
 *                               "The solution to receiver SWS is to avoid advancing the right window edge
 *                               RCV.NXT+RCV.WND in small increments, even if data is received from the
 *                               network in small segments ...  The suggested SWS avoidance algorithm for
 *                               the receiver is to keep RCV.NXT+RCV.WND fixed until the reduction satisfies :
 *
 *                                   - (A) RCV.BUFF - RCV.USER - RCV.WND  >=  min(Fr * RCV.BUFF, Eff.snd.MSS)
 *
 *                               where
 *                                   - (1) RCV.BUFF        Total receive buffer space
 *                                   - (2) RCV.USER        Data  received but not yet consumed
 *                                   - (3) RCV.WND         Space advertised to sender
 *                                   - (4) Fr              Fraction whose recommended value is 1/2
 *                                   - (5) Eff.snd.MSS     Effective send MSS for the connection
 *
 *                               Note that the general effect of this algorithm is to advance RCV.WND in
 *                               increments of the Eff.snd.MSS."
 *
 * @note     (4) (a) RFC #813, Section 5 states that "the receiver of data will refrain from
 *                               sending an acknowledgement under certain circumstances ... Postpone
 *                               sending an acknowledgement if ... the following conditions hold" :
 *
 *                                   - (1) "There is no revised window information to be sent back."
 *
 *                                   - (A) However, if any local receive window size is available to update to
 *                               the remote host, an acknowledgement should be immediately transmitted.
 *
 *                                   - (1) HOWEVER, since  local receive window size updates will continually
 *                               occur for "a host that is receiving a stream of TCP data segments"
 *                               (RFC #1122, Section 4.2.3.2); it is NOT possible to both update the
 *                               local receive window & implement a delayed acknowledgement.
 *
 *                                   - (a) #### Therefore, in order to implement a delayed acknowledgement,
 *                               the only local receive window size updates that SHOULD transmit
 *                               an immediate acknowledgement :
 *
 *                                   - (1) Local receive window size sets/resets
 *                                   - (2) Local receive window size increases
 *                                   - (3) Local receive window size decreases to zero-sized
 *
 *                                   - (b) The following local receive window size updates SHOULD NOT
 *                               transmit an immediate acknowledgement :
 *
 *                                   - (1) Local receive window size decreases
 *
 *                                   - (b) RFC #1122, Section 4.2.3.2 states that "a delayed ACK gives the application an
 *                               opportunity to update the window and perhaps to send an immediate response".
 *
 *                               See also 'NetTCP_TxConnAck()  Notes #4b1, #6, & #7'.
 *
 * @note     (5) If the configured receive window size is allowed to be asynchronously modified by
 *                               the application layer (see 'NetTCP_ConnCfgRxWinSizeHandler()  Note #3'), changes in
 *                               the calculated &/or advertised receive window size MUST be appropriately validated
 *                               to any possible new value for the configured receive window size :
 *
 *                                   - (a) During receive window size increases, if the currently calculated receive
 *                               window size is already greater than the currently configured receive window
 *                               size; then the calculated window size is NOT increased, but is allowed to
 *                               remain greater than  the configured window size until the calculated window
 *                               size decreases below the configured window size.
 *
 *                                   - (b) During receive window size decreases, if the currently calculated receive
 *                               window size is already greater than the currently configured receive window
 *                               size; then the calculated window size is further decreased, but is allowed to
 *                               remain greater than  the configured window size until the calculated window
 *                               size decreases below the configured window size.
 *
 *                                   - (c) During receive window size decreases, if the currently configured receive
 *                               window size is less than the actual configured receive window size; then
 *                               the actual configured receive window size is also decremented by the window
 *                               size decrease.
 *******************************************************************************************************/
static void NetTCP_RxConnWinSizeHandler(NET_TCP_CONN     *p_conn,
                                        NET_BUF_HDR      *p_buf_hdr,
                                        CPU_INT16U       val,
                                        NET_TCP_WIN_CODE win_update_code)
{
  CPU_BOOLEAN       tx_ack = DEF_NO;
  NET_TCP_ACK_CODE  tx_ack_code = NET_TCP_CONN_TX_ACK_NONE;
  NET_TCP_WIN_SIZE  rx_payload_max = 0;
  NET_TCP_WIN_SIZE  win_size_calc = 0;
  NET_TCP_WIN_SIZE  win_size_avail = 0;
  NET_TCP_WIN_SIZE  win_size_delta = 0;
  NET_IF_NBR        if_nbr = NET_IF_NBR_NONE;
  CPU_BOOLEAN       ipv6 = DEF_NO;
  NET_PROTOCOL_TYPE protocol = NET_PROTOCOL_TYPE_TCP_V4;
  RTOS_ERR          local_err;

#ifndef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  ipv6 = NetConn_IsIPv6(p_conn->ID_Conn);
  if (ipv6 == DEF_YES) {
    protocol = NET_PROTOCOL_TYPE_TCP_V6;
  }

  if (p_buf_hdr == DEF_NULL) {
    RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
    if_nbr = NetConn_IF_NbrGet(p_conn->ID_Conn);
  } else {
    if_nbr = p_buf_hdr->IF_Nbr;
  }

  rx_payload_max = NetIF_GetPayloadRxMax(if_nbr, protocol);
  win_size_calc = rx_payload_max * val;
#else

  PP_UNUSED_PARAM(rx_payload_max);
  PP_UNUSED_PARAM(win_size_calc);
  PP_UNUSED_PARAM(if_nbr);
  PP_UNUSED_PARAM(protocol);
  PP_UNUSED_PARAM(ipv6);
#endif

  switch (win_update_code) {
    case NET_TCP_CONN_RX_WIN_ZERO:
      p_conn->RxWinSizeCalcd = 0;
      p_conn->RxWinSizeCfgd = 0;
      p_conn->RxWinSizeActual = 0;
      break;

    case NET_TCP_CONN_RX_WIN_INIT:
      p_conn->RxWinSizeCalcd = val;
      p_conn->RxWinSizeCfgd = val;
      p_conn->RxWinSizeActual = val;
      tx_ack = DEF_YES;
      tx_ack_code = NET_TCP_CONN_TX_ACK_IMMED;                         // See Note #4a1A1a1.
      break;

    case NET_TCP_CONN_RX_WIN_SET:
      if (p_conn->RxWinSizeActual < val) {                              // If actual rx win size < win update, ...
        p_conn->RxWinSizeActual = val;                                  // ... set   rx win size.
        p_conn->RxWinSizeCalcd = val;
        tx_ack = DEF_YES;
        tx_ack_code = NET_TCP_CONN_TX_ACK_IMMED;                        // See Note #4a1A1a1.
      }
      break;

    case NET_TCP_CONN_RX_WIN_INC:
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
      if (val < 1) {                                                   // If NO win update, MUST NOT update win.
        break;
      }

      if (p_conn->RxWinSizeCalcd <= p_conn->RxWinSizeCfgd) {            // If <= cfg'd win size (see Note #5a), ...
                                                                        // ... inc  rx win size.
        win_size_avail = p_conn->RxWinSizeCfgd - p_conn->RxWinSizeCalcd;
        if (win_size_avail > val) {                                    // If avail rx win size >  win update, ...
          p_conn->RxWinSizeCalcd += val;                               // ... inc  rx win size by win update.
        } else {                                                        // Else lim to cfg'd rx win size.
          p_conn->RxWinSizeCalcd = p_conn->RxWinSizeCfgd;
        }

        if (p_conn->RxWinSizeCalcd > p_conn->RxWinSizeActual) {
          win_size_delta = p_conn->RxWinSizeCalcd - p_conn->RxWinSizeActual;
          if (win_size_delta >= p_conn->RxWinSizeUpdateTh) {             // If calc'd - actual rx win size >= th, ...
                                                                         // ... update rx win size (see Note #3b2).
            p_conn->RxWinSizeActual = p_conn->RxWinSizeCalcd;
            tx_ack = DEF_YES;
            tx_ack_code = NET_TCP_CONN_TX_ACK_IMMED;                             // See Note #4a1A1a2.
          }
        } else {                                                        // Prevent rx win shrink (see Note #2b).
          p_conn->RxWinSizeCalcd = p_conn->RxWinSizeActual;
        }
      }

#else
      if (val < 1) {                                        // If NO win update, MUST NOT update win.
        break;
      }

      if (p_conn->RxWinSizeCalcd <= p_conn->RxWinSizeCfgd) {        // If <= cfg'd win size (see Note #5a), ...
        //                                                         ... inc  rx win size.
        win_size_avail = p_conn->RxWinSizeCfgd - p_conn->RxWinSizeCalcd;
        if (win_size_avail > win_size_calc) {                   // If avail rx win size >  win update, ...
          p_conn->RxWinSizeCalcd += win_size_calc;              // ... inc  rx win size by win update.
        } else {                                                // Else lim to cfg'd rx win size.
          p_conn->RxWinSizeCalcd = p_conn->RxWinSizeCfgd;
        }

        if (p_conn->RxWinSizeCalcd > p_conn->RxWinSizeActual) {
          win_size_delta = p_conn->RxWinSizeCalcd - p_conn->RxWinSizeActual;
          if (win_size_delta >= p_conn->RxWinSizeUpdateTh) {            // If calc'd - actual rx win size >= th, ...
            //                                                     ... update rx win size (see Note #3b2).
            p_conn->RxWinSizeActual = p_conn->RxWinSizeCalcd;
            tx_ack = DEF_YES;
            tx_ack_code = NET_TCP_CONN_TX_ACK_IMMED;                          // See Note #4a1A1a2.
          }
        } else {                                                // Prevent rx win shrink (see Note #2b).
          p_conn->RxWinSizeCalcd = p_conn->RxWinSizeActual;
        }
      }
#endif
      break;

    case NET_TCP_CONN_RX_WIN_DEC:
#ifdef  NET_TCP_CFG_OLD_WINDOW_MGMT_EN
      if (val < 1) {                                                    // If NO win update, MUST NOT update win.
        break;
      }

      if (p_conn->RxWinSizeCalcd > val) {                               // If calc'd rx win size >  win update, ...
        p_conn->RxWinSizeCalcd -= val;                                  // ... dec   rx win size by win update.
      } else {
        p_conn->RxWinSizeCalcd = 0u;                                    // Else lim to min rx win size.
      }

      if (p_conn->RxWinSizeActual > 0) {
        if (p_conn->RxWinSizeActual > val) {                            // If actual rx win size >  win update, ...
          p_conn->RxWinSizeActual -= val;                               // ... dec   rx win size by win update.
          tx_ack_code = NET_TCP_CONN_TX_ACK;                            // See Note #4a1A1b1.
        } else {
          p_conn->RxWinSizeActual = 0u;                                     // Else lim to min rx win size.
          tx_ack_code = NET_TCP_CONN_TX_ACK_IMMED;                          // See Note #4a1A1a3.
        }

        tx_ack = DEF_YES;
      }

#else
      if (val < 1) {                                         // If NO win update, MUST NOT update win.
        break;
      }

      if (p_conn->RxWinSizeCalcd > win_size_calc) {             // If calc'd rx win size >  win update, ...
        p_conn->RxWinSizeCalcd -= win_size_calc;                // ... dec   rx win size by win update.
      } else {
        p_conn->RxWinSizeCalcd = 0u;                            // Else lim to min rx win size.
      }

      if (p_conn->RxWinSizeActual > 0) {
        if (p_conn->RxWinSizeActual > win_size_calc) {          // If actual rx win size >  win update, ...
          p_conn->RxWinSizeActual -= win_size_calc;             // ... dec   rx win size by win update.
          tx_ack_code = NET_TCP_CONN_TX_ACK;                         // See Note #4a1A1b1.
        } else {
          p_conn->RxWinSizeActual = 0u;                         // Else lim to min rx win size.
          tx_ack_code = NET_TCP_CONN_TX_ACK_IMMED;                        // See Note #4a1A1a3.
        }
        tx_ack = DEF_YES;
      }
#endif
      break;

    case NET_TCP_CONN_RX_WIN_RESET:
    default:
      if (p_conn->RxWinSizeCalcd < p_conn->RxWinSizeCfgd) {            // If < cfg'd win size  (see Note #5a), ...
        p_conn->RxWinSizeCalcd = p_conn->RxWinSizeCfgd;                // ... reset calc'd win size to cfg'd win size.
      }
      if (p_conn->RxWinSizeActual < p_conn->RxWinSizeCalcd) {          // Do NOT shrink rx win (see Note #2b).
        p_conn->RxWinSizeActual = p_conn->RxWinSizeCalcd;
        tx_ack = DEF_YES;
        tx_ack_code = NET_TCP_CONN_TX_ACK_IMMED;                       // See Note #4a1A1a1.
      }
      break;
  }

  //                                                               ----------------- TX TCP CONN ACK ------------------
  if (tx_ack == DEF_YES) {                                      // If rx win updated, tx ack (see Note #4a1A).
    if (p_buf_hdr != DEF_NULL) {                                // If rx'd pkt avail, req tx ack; but ack ...
      p_buf_hdr->TCP_SegAckTxReqCode = (CPU_INT08U)tx_ack_code;       // ... NOT tx'd until after rx'd pkt handling.
    } else {
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, tx_ack_code, NET_TCP_CONN_CLOSE_ALL, &local_err);
    }
  }
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnWinSizeCfg()
 *
 * @brief    (1) Configure TCP connection's transmit window controls :
 *
 *           - (a) Configure TCP connection's transmit window congestion controls
 *           - (b) Configure TCP connection's transmit window minimum    threshold
 *
 *
 * Argument(s) : p_conn       Pointer to a TCP connection.
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) A TCP connection's transmit window controls SHOULD be updated only after the
 *                   following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's maximum   transmit remote window size ('TxWinSizeRemoteMax')
 *                   [see 'NetTCP_TxConnWinSizeCfgCongCtrl()  Note #5a'
 *                   & 'NetTCP_TxConnWinSizeCfgMinTh()     Note #2a']
 *
 *                       - (b) TCP connection's remaining transmit remote window size ('TxWinSizeRemoteRem')
 *                   [see 'NetTCP_TxConnWinSizeCfgCongCtrl()  Note #5b']
 *
 *                       - (c) TCP connection's connection maximum segment size ('MaxSegSizeConn')
 *                   [see 'NetTCP_TxConnWinSizeCfgCongCtrl()  Note #5c']
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeCfg(NET_TCP_CONN *p_conn)
{
  p_conn->TxWinSizeCfgdRem = p_conn->TxWinSizeCfgd;

  NetTCP_TxConnWinSizeCfgCongCtrl(p_conn);
  NetTCP_TxConnWinSizeCfgMinTh(p_conn);
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnWinSizeCfgCongCtrl()
 *
 * @brief    (1) Configure TCP connection's transmit window congestion controls :
 *
 *           - (a) Configure TCP connection's transmit window slow start threshold         See Note #2
 *           - (b) Configure TCP connection's transmit window congestion controls          See Note #3
 *           - (c) Reset     TCP connection's transmit window duplicate acknowledgement
 *                       controls
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (2) RFC #2581, Section 3.1 states that "the initial value of ssthresh [slow start
 *                   threshold] MAY be arbitrarily high (for example, some implementations use the
 *                   size of the advertised window)".
 *
 *                       - (a) This amends RFC #2001, Section 2.1 which previously stated that "initialization
 *                   for a given connection sets ... ssthresh to 65535 bytes".
 *
 *                       - (b) To always ensure a sufficiently high initial value, the slow start threshold
 *                   initializes to the TCP connection's maximum remote window size.
 *
 * @note     (3) "The initial value of cwnd [congestion window], MUST be less than or equal to 2*SMSS
 *                   bytes and MUST NOT be more than 2 segments."
 *
 *                       - (a) This amends RFC #2001, Section 2.1 which previously stated that "initialization
 *                   for a given connection sets cwnd to one segment".
 *
 * @note     (4) (a) RFC #2001, Section 2.2 states that "the TCP output routine never sends more than
 *                   the minimum of cwnd and the receiver's advertised window".
 *
 *                       - (b) RFC #2581, Section 3.1 reiterates that "the minimum of cwnd and rwnd [receiver's
 *                   advertised window] governs data transmission".
 *
 *                   See also 'NetTCP_TxConnWinSizeUpdateAvail()  Note #1'.
 *
 * @note     (5) A TCP connection's transmit window congestion controls SHOULD be updated only after
 *                   the following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's maximum    transmit remote window size ('TxWinSizeRemoteMax')
 *                   [see 'NetTCP_RxPktConnHandlerTxWinRemote()   Note  #1a2A'
 *                   & 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Notes #3a2A & #3b']
 *
 *                       - (b) TCP connection's remaining  transmit remote window size ('TxWinSizeRemoteRem')
 *                   [see 'NetTCP_RxPktConnHandlerTxWinRemote()   Note  #1a2A'
 *                   & 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Notes #3a2A']
 *
 *                       - (c) TCP connection's connection maximum segment size ('MaxSegSizeConn')
 *                   [see 'NetTCP_ConnCfgMaxSegSize()  Note #1']
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeCfgCongCtrl(NET_TCP_CONN *p_conn)
{
  //                                                               Cfg tx slow start th (see Note #2b).
  p_conn->TxWinSizeSlowStartThInit = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeRemoteMax;
  p_conn->TxWinSizeSlowStartTh = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeSlowStartThInit;

  //                                                               Cfg tx cong ctrls    (see Note #3a).
  p_conn->TxWinSizeCongInit = (NET_TCP_WIN_SIZE)p_conn->MaxSegSizeConn * NET_TCP_CONG_WIN_MSS_SCALAR_INIT;
  p_conn->TxWinSizeCongCalcdActual = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeCongInit;
  p_conn->TxWinSizeCongCalcdCur = (NET_TCP_WIN_SIZE)0u;
  p_conn->TxWinSizeCongRem = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeCongCalcdActual;

  //                                                               Cfg tx win avail     (see Note #4).
  NetTCP_TxConnWinSizeUpdateAvail(p_conn);

  NetTCP_TxConnWinSizeDupAckCtrlReset(p_conn);                  // Reset dup ack ctrls.
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnWinSizeCfgMinTh()
 *
 * @brief    Configure TCP connection's transmit silly window minimum threshold.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) RFC #1122, Section 4.2.3.4 states that "the sender's SWS avoidance algorithm is ...
 *                   [to] send data ... if at least a fraction Fs of the maximum window can be sent ...
 *                   Fs is a fraction whose recommended value is 1/2".
 *
 * @note     (2) A TCP connection's transmit window minimum threshold SHOULD be updated only after
 *                   the following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's maximum transmit remote window size ('TxWinSizeRemoteMax')
 *                   [see 'NetTCP_RxPktConnHandlerTxWinRemote()   Note  #1a2A'
 *                   & 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Notes #3a2A & #3b']
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeCfgMinTh(NET_TCP_CONN *p_conn)
{
  //                                                               Cfg silly win min th (see Note #1).
  p_conn->TxWinSizeMinTh = (NET_TCP_WIN_SIZE)(((CPU_INT32U)p_conn->TxWinSizeRemoteMax * NET_TCP_TX_SILLY_WIN_NUMER)
                                              / NET_TCP_TX_SILLY_WIN_DENOM);
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnWinSizeHandlerCfgd()
 *
 * @brief    (1) Handle TCP connection's configured transmit window :
 *
 *           - (a) Update TCP connection configured transmit window
 *           - (b) Update TCP connection total transmit data queued
 *
 * @param    p_conn              Pointer to a TCP connection.
 *
 * @param    win_update_size     Size to update TCP connection's transmit window (in octets).
 *
 * @param    win_update_code     Indicate how to update TCP connection transmit window :
 *                               NET_TCP_CONN_TX_WIN_RESET       Reset     TCP connection's available
 *                               transmit window size.
 *                               NET_TCP_CONN_TX_WIN_SET         Set       TCP connection's available
 *                               transmit window size.
 *                               NET_TCP_CONN_TX_WIN_INC         Increment TCP connection's available
 *                               transmit window size.
 *                               NET_TCP_CONN_TX_WIN_DEC         Decrement TCP connection's available
 *                               transmit window size.
 *
 * @note     (2) (a) RFC #793, Section 3.7 'Data Communication : Managing the Window' states
 *                               that "the window sent in each segment indicates the range of sequence
 *                               numbers the sender of the window (the data receiver) is currently
 *                               prepared to accept.  There is an assumption that this is related to the
 *                               currently available data buffer space available for this connection".
 *
 *                                   - (b) Thus a TCP connection's configured transmit window is constrained by
 *                               the available network resources; of which, network buffers are the
 *                               primary transmit window network resource.
 *
 *                               However, since network buffers are discrete resources with non-discrete
 *                               packet size; it is NOT necessary to enforce exact/strict compliance with
 *                               a TCP connection's configured transmit window.
 *
 *                               In other words, network buffers allocated for TCP connection transmit
 *                               SHOULD be fully used even if the TCP connection's configured transmit
 *                               window is zero.
 *
 * @note     (3) If the configured transmit window size is allowed to be asynchronously modified
 *                               by the application layer, changes in the remaining transmit window size MUST be
 *                               appropriately validated to any possible new value for the configured transmit
 *                               window size :
 *
 *                                   - (a) During transmit window size increases, if the remaining transmit window
 *                               size is already greater than the currently configured   transmit window
 *                               size; then the remaining window size is NOT increased, but is allowed to
 *                               remain greater than  the configured window size until the remaining window
 *                               size decreases below the configured window size.
 *
 *                                   - (b) During transmit window size decreases, if the remaining transmit window
 *                               size is already greater than the currently configured   transmit window
 *                               size; then the remaining window size is further decreased, but is allowed
 *                               to remain greater than the configured window size until the remaining
 *                               window size decreases below the configured window size.
 *
 *                                   - (c) Window size update is NOT validated for transmit window size resets.
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeHandlerCfgd(NET_TCP_CONN     *p_conn,
                                            NET_TCP_WIN_SIZE win_update_size,
                                            NET_TCP_WIN_CODE win_update_code)
{
  CPU_BOOLEAN      q_prevly_full;
  NET_TCP_WIN_SIZE win_size_avail;
  NET_TCP_CONN_ID  conn_id_tcp;

  switch (win_update_code) {
    case NET_TCP_CONN_TX_WIN_RESET:                             // Reset cfg'd tx win size (see Note #1c).
    default:
      p_conn->TxWinSizeCfgdRem = p_conn->TxWinSizeCfgd;
      break;

    case NET_TCP_CONN_TX_WIN_SET:
      if (p_conn->TxWinSizeCfgdRem < win_update_size) {         // If rem cfg'd win size < win update, ...
        p_conn->TxWinSizeCfgdRem = win_update_size;             // .. set cfg'd win size.
        break;
      }                                                         // Else inc; do NOT shrink win.
    //                                                             'break' intentionally omitted; MUST ...
    //                                                             ...  execute the following case :   ...
    //                                                             ---------- ... 'NET_TCP_CONN_TX_WIN_INC'. ----------
    //                                                             fallthrough
    case NET_TCP_CONN_TX_WIN_INC:
      if (win_update_size < 1) {                                // If NO win update, do NOT update win.
        break;
      }

      q_prevly_full = (p_conn->TxWinSizeCfgdRem < 1) ? DEF_YES : DEF_NO;

      if (p_conn->TxWinSizeCfgdRem < p_conn->TxWinSizeCfgd) {
        //                                                         If < cfg'd  win size (see Note #3a), ...
        //                                                         ... inc  tx win size.
        win_size_avail = p_conn->TxWinSizeCfgd - p_conn->TxWinSizeCfgdRem;
        if (win_size_avail > win_update_size) {                 // If avail tx win size >  win update, ...
                                                                // ... inc  tx win size by win update.
          p_conn->TxWinSizeCfgdRem += win_update_size;
        } else {
          //                                                       Else lim to cfg'd tx win size.
          p_conn->TxWinSizeCfgdRem = p_conn->TxWinSizeCfgd;
        }
      }

      if (q_prevly_full == DEF_YES) {                           // If tx Q prev'ly full, ...
        conn_id_tcp = p_conn->ID;
        NetTCP_TxQ_Signal(conn_id_tcp);                         // ... signal tx Q.
      }
      break;

    case NET_TCP_CONN_TX_WIN_DEC:
      if (win_update_size < 1) {                                // If NO win update, do NOT update win.
        break;
      }

      if (p_conn->TxWinSizeCfgdRem > win_update_size) {         // If rem tx win size >  win update, ..
        p_conn->TxWinSizeCfgdRem -= win_update_size;            // .. dec tx win size by win update.
      } else {
        p_conn->TxWinSizeCfgdRem = 0u;                          // Else lim to min tx  win size.
      }
      break;
  }
}

/****************************************************************************************************//**
 *                                   NetTCP_TxConnWinSizeHandlerCongCtrl()
 *
 * @brief    (1) Handle TCP connection's transmit window congestion controls :
 *
 *           - (a) Perform slow start / congestion avoidance algorithms            See Note #2c2A
 *           - (b) Perform fast re-transmit / fast recovery  algorithms            See Note #2c2B
 *           - (c) Handle  remote host's receive window updates                    See Note #3
 *
 * @param    p_conn              Pointer to a TCP connection.
 *
 * @param    p_buf_hdr           Pointer to network buffer header that received TCP packet.
 *
 * @param    ack_code            Indicates the received segment's acknowledgement condition :
 *                               NET_TCP_CONN_RX_ACK_NONE            NO received acknowledgement number.
 *                               NET_TCP_CONN_RX_ACK_INVALID            Received acknowledgement number
 *                               is invalid for the TCP connection.
 *                               NET_TCP_CONN_RX_ACK_VALID              Received acknowledgement number
 *                               is   valid for the TCP connection.
 *                               NET_TCP_CONN_RX_ACK_DUP                Received acknowledgement number
 *                               is a          duplicate for the
 *                               TCP connection.
 *                               NET_TCP_CONN_RX_ACK_PREV               Received acknowledgement number
 *                               is a previous duplicate for the
 *                               TCP connection.
 *
 * @param    win_update_size     Size to update TCP connection's transmit window (in octets).
 *
 * @param    win_update_code     Indicate how to update TCP connection transmit window :
 *                               NET_TCP_CONN_TX_WIN_RESET           Reset     TCP connection's congestion
 *                               control transmit window size.
 *                               NET_TCP_CONN_TX_WIN_SEG_RXD         Update    TCP connection's congestion
 *                               control transmit window size
 *                               based on received segment.
 *                               NET_TCP_CONN_TX_WIN_TIMEOUT         Update    TCP connection's congestion
 *                               control transmit window size
 *                               based on transmission timeout.
 *                               NET_TCP_CONN_TX_WIN_INC             Increment TCP connection's congestion
 *                               control transmit window sizes.
 *                               NET_TCP_CONN_TX_WIN_DEC             Decrement TCP connection's
 *                               transmit window sizes.
 *                               NET_TCP_CONN_TX_WIN_REMOTE_UPDATE   Update    TCP connection's remote
 *                               receive  window size.
 *
 * @param    p_err               Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) (a) (1) The following sections define, specify, &/or require "TCP's four intertwined congestion
 *                               control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery" :
 *
 *                                   - (A) RFC #2001                                               See Note  #2c1
 *                                   - (B) RFC #2581                                               See Notes #2c2, #2a2, & #2e
 *                                   - (C) RFC #1122
 *                                   - (1) Section 4.2.2.15
 *                                   - (2) Section 4.2.2.21
 *                                   - (3) Section 4.2.3.9                                     See 'net_tcp.c  Note #1e'
 *                                   - (a) 'Source Quench'                                 See Note #2e2
 *                                   - (b) 'Destination Unreachable -- Codes 2-4'
 *
 *                                   - (2) Although RFC #2581, Section 1 states that "this document is an update of [RFC #2001]";
 *                               both references are included as complementary specifications of the congestion control
 *                               algorithms.
 *
 *                               However, since RFC #2581 is the update to RFC #2001, its specifications supercede
 *                               those of RFC #2001; & ALL differences are implemented by RFC #2581 specifications.
 *
 *                                   - (b) (1) (A) RFC #2581, Section 3.1 states that "the slow start and congestion avoidance
 *                               algorithms MUST be used by a TCP sender to control the amount of outstanding
 *                               data being injected into the network".
 *
 *                                   - (B) RFC #1122, Section 4.2.2.15 reiterates that "a TCP MUST implement ... 'slow
 *                               start' with 'congestion avoidance'".
 *
 *                                   - (2) (A) RFC #2001, Section 1 states that "the sender's ... congestion window ... is
 *                               flow control imposed by the sender, while the advertised window is flow control
 *                               imposed by the receiver.  The former is based on the sender's assessment of
 *                               perceived network congestion; the latter is related to the amount of available
 *                               buffer space at the receiver for this connection".
 *
 *                                   - (B) RFC #2581, Section 3.1 reiterates that "the congestion window ... is a sender-
 *                               side limit on the amount of data the sender can transmit into the network
 *                               before receiving an acknowledgment (ACK), while the receiver's advertised
 *                               window ... is a receiver-side limit on the amount of outstanding data."
 *
 *                                   - (3) (A) (1) RFC #2001, Section 1 states that "the sender can transmit up to the minimum
 *                               of the congestion window and the advertised window."
 *
 *                                   - (2) RFC #2001, Section 2.2 reiterates that "the TCP output routine never sends
 *                               more than the minimum of cwnd and the receiver's advertised window".
 *
 *                                   - (3) RFC #2581, Section 3.1 also reiterates that "the minimum of cwnd and rwnd
 *                               [receiver's advertised window] governs data transmission".
 *
 *                                   - (B) RFC #2581, Section 3 also states that "a TCP MUST NOT be more aggressive than
 *                               the [congestion control] algorithms allow (that is, MUST NOT send data when
 *                               the value of cwnd computed by the [congestion control] algorithms would not
 *                               allow the data to be sent)".
 *
 *                                   - (C) TCP transmit resulting from TCP congestion controls update handled by appropriate
 *                               TCP connection state receive handler function(s).
 *
 *                               See 'NetTCP_RxPktConnHandlerSyncRxd()    Note #1c3',
 *                               'NetTCP_RxPktConnHandlerSyncTxd()    Note #1c3',
 *                               'NetTCP_RxPktConnHandlerConn()       Note #1c',
 *                               'NetTCP_RxPktConnHandlerFinWait1()   Note #1c',
 *                               'NetTCP_RxPktConnHandlerClosing()    Note #1c',
 *                               'NetTCP_RxPktConnHandlerCloseWait()  Note #1c',
 *                               & 'NetTCP_RxPktConnHandlerLastAck()    Note #1c'.
 *
 *                                   - (4) (A) RFC #2001, Sections 3 & 4 state that "since ... a duplicate ACK is caused by
 *                               a lost segment or just a reordering of segments, ... [fast retransmit] waits
 *                               for a small number of duplicate ACKs to be received ... [as] a strong indication
 *                               that a segment has been lost ... [and] then performs a retransmission of what
 *                               appears to be the missing segment, without waiting for a retransmission timer
 *                               to expire.
 *
 *                               After fast retransmit sends ... the missing segment, congestion avoidance,
 *                               but not slow start is performed.  This is the fast recovery algorithm".
 *
 *                                   - (B) RFC #2581, Section 3.2 reiterates that "the TCP sender SHOULD use the 'fast
 *                               retransmit' algorithm to detect and repair loss, based on ... the arrival of
 *                               3 duplicate ACKs (4 identical ACKs without the arrival of any other intervening
 *                               packets) as an indication that a segment has been lost.  After receiving 3
 *                               duplicate ACKs, TCP performs a retransmission of what appears to be the missing
 *                               segment, without waiting for the retransmission timer to expire.
 *
 *                               After the fast retransmit algorithm sends ... the missing segment, the 'fast
 *                               recovery' algorithm ... can continue to transmit new segments ... (using a
 *                               reduced cwnd) ... until a non-duplicate ACK arrives".
 *
 *                                   - (c) (1) (A) RFC #2001, Section 2 states that the "congestion avoidance and slow start ...
 *                               combined algorithm operates as follows" :
 *
 *                                   - (1) "Initialization for a given connection sets" :
 *
 *                                   - (a) "cwnd to one segment" ...
 *                                   - (b) "and ssthresh to 65535 bytes."
 *
 *                                   - (3) (a) (1) "When congestion occurs (indicated by" :
 *
 *                                   - (A) "a timeout"                            ...
 *                                   - (B) "or the reception of duplicate ACKs)," ...
 *
 *                                   - (2) "one-half of the current window size" :
 *
 *                                   - (A) "the minimum of" :
 *                                   - (1) "cwnd"                                 ...
 *                                   - (2) "and the receiver's advertised window" ...
 *                                   - (B) "but at least two segments" ...
 *
 *                                   - (3) "is saved in ssthresh [slow start threshold]."
 *
 *                                   - (b) (1) "Additionally, if the congestion is indicated by a timeout," ...
 *                                   - (2) "cwnd is set to one segment (i.e., slow start)."
 *
 *                                   - (4) "When new data is acknowledged by the other end, increase cwnd, but the way
 *                               it increases depends on whether TCP is performing slow start or congestion
 *                               avoidance" :
 *
 *                                   - (a) (1) (A) (1) (a) "If cwnd is less than or equal to ssthresh," ...
 *                                   - (b) "TCP is in slow start."
 *
 *                                   - (2) "Slow start continues until TCP is halfway to where it was
 *                               when congestion occurred (since it recorded half of the
 *                               window size that caused the problem)."
 *
 *                                   - (B) (1) "Slow start has cwnd" :
 *
 *                                   - (a) "Begin at one segment," ...
 *
 *                                   - (b) (1) "and be incremented by one segment" ...
 *                                   - (2) "every time an ACK is received."
 *
 *                                   - (2) "The increase in cwnd ... [for] slow start increments cwnd
 *                               by the number of ACKs received in a round-trip time ...
 *                               [which] opens the window exponentially: send one segment,
 *                               then two, then four, and so on."
 *
 *                                   - (2) RFC #2001, Section 1 states that :
 *
 *                                   - (A) "Early implementations performed slow start only if the other
 *                               end was on a different network."
 *
 *                                   - (B) "Current implementations always perform slow start."
 *
 *                                   - (b) (1) (A) "If cwnd is [not] less than or equal to ssthresh," ...
 *                                   - (B) "TCP is performing congestion avoidance."
 *
 *                                   - (2) (A) (1) "cwnd [is] incremented by segsize*segsize/cwnd" ...
 *                                   - (a) "where segsize is the segment size" ...
 *                                   - (b) "and cwnd is maintained in bytes";  ...
 *                                   - (2) "each time an ACK is received."
 *
 *                                   - (B) "This is a linear growth of cwnd ... The increase in cwnd should
 *                               be at most one segment each round-trip time (regardless how many
 *                               ACKs are received in that RTT)."
 *
 *                                   - (B) RFC #2001, Section 4 states that "the fast retransmit and fast recovery
 *                               algorithms are usually implemented together as follows" :
 *
 *                                   - (1) "When the third duplicate ACK in a row is received" :
 *
 *                                   - (a) "Set ssthresh to" :
 *                                   - (1) "one-half the current congestion window, cwnd" ...
 *                                   - (2) "but no less than two segments."
 *
 *                                   - (b) "Retransmit the missing segment."
 *
 *                                   - (c) "Set cwnd to ssthresh plus 3 times the segment size."
 *
 *                                   - (2) "Each time another duplicate ACK arrives" :
 *
 *                                   - (a) "Increment cwnd by the segment size."
 *                                   - (b) "Transmit a packet, if allowed by the new value of cwnd."
 *
 *                                   - (3) "When the next ACK arrives that acknowledges new data" :
 *
 *                                   - (a) "Set cwnd to ssthresh" (see Note #2c1B1a).
 *
 *                                   - (2) (A) RFC #2581, Section 3.1 defines the "slow start and congestion avoidance algorithms"
 *                               as follows :
 *
 *                                   - (1) (a) "The initial value of cwnd, MUST be" :
 *
 *                                   - (1) "less than or equal to 2*SMSS bytes" ...
 *                                   - (2) "and MUST NOT be more than 2 segments."
 *
 *                                   - (b) "The initial value of ssthresh MAY be arbitrarily high" :
 *                                   - (1) "some implementations use the size of the advertised window."
 *
 *                                   - (2) (a) "The slow start algorithm is used when cwnd < ssthresh," ...
 *                                   - (b) "While the congestion avoidance algorithm is used when cwnd > ssthresh."
 *                                   - (c) "When cwnd and ssthresh are equal the sender may use either slow start or
 *                               congestion avoidance."
 *
 *                                   - (3) (a) "During slow start" :
 *
 *                                   - (1) "a TCP increments cwnd by at most SMSS bytes" ...
 *                                   - (2) "for each ACK received that acknowledges new data."
 *
 *                                   - (b) "Slow start ends when" :
 *
 *                                   - (1) "cwnd exceeds ... or ... reaches ... ssthresh" ...
 *                                   - (2) "or when congestion is observed."
 *
 *                                   - (4) (a) "During congestion avoidance" :
 *
 *                                   - (1) "cwnd is incremented by 1 full-sized segment per round-trip time (RTT)."
 *
 *                                   - (2) (A) "One formula commonly used to update cwnd during congestion avoidance
 *                               is given" by :
 *
 *                                   - (2) cwnd += (SMSS * SMSS) / cwnd
 *
 *                                   - (B) "Another acceptable way to increase cwnd during congestion avoidance
 *                               is to count the number of bytes that have been acknowledged by ACKs
 *                               for new data" :
 *
 *                                   - (1) "When the number of bytes acknowledged reaches cwnd," ...
 *                                   - (2) "then cwnd can be incremented by up to SMSS bytes."
 *
 *                                   - (3) "This adjustment is executed on every incoming non-duplicate ACK."
 *
 *                                   - (b) "Congestion avoidance continues until congestion is detected."
 *
 *                                   - (5) "When a TCP sender detects segment loss using the retransmission timer" :
 *
 *                                   - (a) "the value of ssthresh MUST be set to no more than" :
 *
 *                                   - (3) ssthresh = max (FlightSize / 2, 2 * SMSS)
 *
 *                                   - (A) "FlightSize is the amount of outstanding data ... that has been
 *                               sent but not yet acknowledged."
 *
 *                                   - (b) "cwnd MUST be set to no more than ... 1 full-sized segment."
 *
 *                                   - (c) "Therefore, after retransmitting the dropped segment the TCP sender uses
 *                               the slow start algorithm to increase the window."
 *
 *                                   - (B) RFC #2581, Section 3.2 states that "the fast retransmit and fast recovery algorithms
 *                               are usually implemented together as follows" :
 *
 *                                   - (1) "When the third duplicate ACK is received" (see Note #2d1) :
 *
 *                                   - (a) "Set ssthresh to no more than the value given [by the] equation"
 *                               (see Note #2c2A5a3), ...
 *
 *                                   - (b) "Retransmit the lost segment"
 *                               (see Note #2d2),     ...
 *
 *                                   - (c) "Set cwnd to ssthresh plus 3*SMSS."
 *                                   - (1) "This artificially 'inflates' the congestion window by the number of
 *                               segments (three) that have left the network and which the receiver
 *                               has buffered."
 *
 *                                   - (2) "For each additional duplicate ACK received" :
 *
 *                                   - (a) "Increment cwnd by SMSS."
 *                                   - (1) "This artificially inflates the congestion window in order to reflect
 *                               the additional segment that has left the network."
 *
 *                                   - (b) (1) "Transmit a segment, if allowed by" :
 *
 *                                   - (A) "the new value of cwnd" ...
 *                                   - (B) "and the receiver's advertised window."
 *
 *                                   - (2) TCP transmit resulting from TCP congestion controls update handled by
 *                               appropriate TCP connection state receive handler function(s).
 *
 *                               See also Note #2b3C.
 *
 *                                   - (3) (a) "When the next ACK arrives that acknowledges new data," ...
 *                                   - (b) "Set cwnd to ssthresh" (see Note #2c2B1a).
 *
 *                                   - (d) (1) (A) RFC #1122, Section 4.2.2.21 states that "'fast retransmit' ... counts the number of
 *                               ... 'redundant' ACK's ... received with" :
 *
 *                                   - (1) "the same value of SEG.ACK and" ...
 *                                   - (2) "the same right window edge".
 *
 *                                   - (B) Although it is not directly stated, it is inferred that duplicate acknowledgements
 *                               SHOULD be :
 *
 *                                   - (1) Acknowledgement-only segments
 *                                   - (a) i.e. with NO transmit data                              See Note #2d1C1
 *                                   - (1) i.e. with NO TCP segment length
 *                                   - (2) With NO sequence number      update
 *                                   - (3) With NO receive  window size update                         See Note #2d1C2
 *
 *                                   - (C) Also although RFC #2581, Section 3.2 states that "the TCP sender SHOULD use the
 *                               'fast retransmit' algorithm ... based on ... the arrival of ... 4 identical ACKs
 *                               without the arrival of any other intervening packets"; it seems reasonable that
 *                               the TCP fast retransmit algorithm MUST NOT consider the arrival of non-duplicate
 *                               acknowledgement segments as "intervening packets".
 *
 *                               In other words, TCP fast retransmit MUST ignore the following TCP packets as
 *                               duplicate acknowledgement packets :
 *
 *                                   - (1) TCP data segments
 *                                   - (2) Remote host receive window updates
 *
 *                                   - (2) RFC #1122, Section 4.2.2.21 reiterates that "with this ... 'fast retransmit' ...
 *                               algorithm, the sender uses the redundant ACK's to deduce that a segment has been
 *                               lost before the retransmission timer has expired.  If more than a threshold number
 *                               of such ACK's is received, then the segment containing the octets starting at
 *                               SEG.ACK is assumed to have been lost and is retransmitted, without awaiting a
 *                               timeout".
 *
 *                                   - (e) (1) RFC #2581, Section 4.1 states that "after TCP has been idle for a relatively long period
 *                               of time ... use slow start to restart transmission" :
 *
 *                                   - (A) (1) "If the TCP has not sent data in an interval exceeding the retransmission timeout"
 *                                   - (2) "cwnd is reduced to ... no more than ... the value of the restart window"
 *                               (see Note #2c2A1).
 *
 *                               See also 'NetTCP_TxConnTxQ_TimeoutIdle()  Note #2a'.
 *
 *                                   - (B) Although NO RFC specifies that a TCP connection's slow start threshold should be
 *                               reset following a TCP transmit idle timeout; it seems reasonable to reset the slow
 *                               start threshold whenever the TCP transmit congestion window is reset.
 *
 *                               See also 'NetTCP_TxConnWinSizeCfgCongCtrl()  Notes #2 & #3'.
 *
 *                                   - (2) RFC #1122, Section 4.2.3.9 'Source Quench' states that "TCP MUST react to a Source Quench
 *                               by slowing transmission on the connection.  The RECOMMENDED procedure is ... to trigger a
 *                               'slow start', as if a retransmission timeout had occurred".
 *
 * @note     (3) (a) (1) The following sections ... :
 *
 *                                   - (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                               ESTABLISHED STATE'
 *                                   - (B) RFC #1122, Section 4.2.2.20.(c)
 *                                   - (C) RFC #1122, Section 4.2.2.20.(f)
 *
 *                                   - (2) ... generalize that "the following variables should be set ... [when] the send
 *                               window should be updated" :
 *
 *                                   - (A) SND.WND <- SEG.WND
 *
 *                                   - (1) A TCP connection's remote host receive window advertisements are relative
 *                               to the received window advertisement acknowledgement sequence number, &
 *                               are asynchronous to the TCP connection's recent transmitted sequences.
 *
 *                               Therefore, the actual transmit remote window size MUST be compensated by
 *                               the difference in the remote host receive window advertisement & the TCP
 *                               connection's number of recently transmitted sequences :
 *
 *                                   - (a) TxWinSizeRemoteActual  =  SEG.WIN  -  (SND.NXT - SEG.ACK)
 *
 *                               where
 *
 *                               TxWinSizeRemoteActual   TCP connection's actual transmit
 *                               remote window size
 *
 *                                   - (B) SND.WL1 <- SEG.SEQ
 *                                   - (C) SND.WL2 <- SEG.ACK
 *
 *                                   - (b) RFC #1122, Section 4.2.3.4 'IMPLEMENTATION' states that "because the sender does not
 *                               know (directly) the receiver's total buffer space RCV.BUFF ... An approach [that] has
 *                               been found to work well is for the sender to calculate Max(SND.WND), the maximum send
 *                               window it has seen so far on the connection, and to use this value as an estimate of
 *                               RCV.BUFF".
 *
 *                                   - (c) RFC #1122, Section 4.2.2.17 states that although "a TCP MAY keep its offered receive
 *                               window closed indefinitely ... the sending TCP MUST allow the connection to stay open
 *                               ... as long as the receiving TCP continues to send acknowledgments in response to ...
 *                               probe segments".
 *
 *                               See also 'NetTCP_TxConnWinSizeZeroWinHandler()  Note #1'.
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeHandlerCongCtrl(NET_TCP_CONN     *p_conn,
                                                NET_BUF_HDR      *p_buf_hdr,
                                                NET_TCP_ACK_CODE ack_code,
                                                NET_TCP_WIN_SIZE win_update_size,
                                                NET_TCP_WIN_CODE win_update_code,
                                                RTOS_ERR         *p_err)
{
  CPU_BOOLEAN      ack_dup;
  NET_TCP_WIN_SIZE tx_win_size_remote_actual;
  NET_TCP_WIN_SIZE tx_win_size_remote_actual_min;

  switch (win_update_code) {
    case NET_TCP_CONN_TX_WIN_RESET:
    default:
      NetTCP_TxConnWinSizeCfgCongCtrl(p_conn);                  // Reset tx cong ctrls (see Note #2e).
      break;

    case NET_TCP_CONN_TX_WIN_SEG_RXD:
      switch (ack_code) {
        case NET_TCP_CONN_RX_ACK_VALID:
          //                                                       ------------------ FAST RECOVERY -------------------
          //                                                       If valid ack rx'd after fast re-tx th, ..
          if (p_conn->TxWinRxdAckDupCtr >= NET_TCP_FAST_RE_TX_ACK_DUP_TH) {
            //                                                     .. perform fast recovery (see Note #2c2B3) :
            //                                                     .. set cong win to slow start th       ..
            //                                                     ..                       (see Note #2c2B3b).
            NetTCP_TxConnWinSizeCongSet(p_conn, NET_TCP_CONN_TX_WIN_CONG_SET_SLOW_START);
            NetTCP_TxConnWinSizeUpdateAvail(p_conn);               // Update avail tx win (see Note #2b3).
          } else {                                              // ----------- SLOW START / CONG AVOIDANCE ------------
                                                                // If cong win <  slow start th ..
                                                                // .. (see Notes #2c2A2a),      ..
            if (p_conn->TxWinSizeCongCalcdActual < p_conn->TxWinSizeSlowStartTh) {
              //                                                   .. perform slow start  (see Note #2c2A3) :
              //                                                   .. inc cong win by MSS (see Note #2c2A3a1).
              NetTCP_TxConnWinSizeCongInc(p_conn, p_buf_hdr, 0u, NET_TCP_CONN_TX_WIN_CONG_INC_SLOW_START);
            } else {                                            // If cong win >= slow start th     ..
                                                                // .. (see Note #2c2A2b & #2c2A2c), ..
                                                                // .. perform cong avoid  (see Note #2c2A4) :
                                                                // .. inc cong win        (see Note #2c2A4a2B).
              NetTCP_TxConnWinSizeCongInc(p_conn, p_buf_hdr, 0u, NET_TCP_CONN_TX_WIN_CONG_INC_CONG_AVOID);
            }

            NetTCP_TxConnWinSizeUpdateAvail(p_conn);               // Update avail tx win (see Note #2b3A).
          }

#if 0                                                           // Tx avail seg(s)     [see Note #2b3C].
          NetTCP_TxConnTxQ(p_conn, p_buf_hdr, ack_code, DEF_NO, NET_TCP_CONN_CLOSE_ALL, DEF_YES, p_err);
          switch (RTOS_ERR_CODE_GET(*p_err)) {
            case RTOS_ERR_NONE:
            case RTOS_ERR_NET_IF_LINK_DOWN:
              break;

            default:
              goto exit;
          }
#endif
          //                                                       Reset dup ack ctrls.
          NetTCP_TxConnWinSizeDupAckCtrlUpdate(p_conn, p_buf_hdr, DEF_YES);
          break;

        case NET_TCP_CONN_RX_ACK_DUP:                           // ------------ FAST RE-TX / FAST RECOVERY ------------
                                                                // Chk dup ack (see Notes #2b4 & #2d1).
          ack_dup = ((p_buf_hdr->TCP_SeqNbr == p_conn->TxWinRxdLastSeqNbr)
                     && (p_buf_hdr->TCP_AckNbr == p_conn->TxWinRxdLastAckNbr)
                     && (p_buf_hdr->TCP_WinSize == p_conn->TxWinRxdLastWinSize)
                     && (p_buf_hdr->TCP_SegLen < 1)) ? DEF_YES : DEF_NO;

          if (ack_dup == DEF_YES) {                             // If     dup ack, ..
            p_conn->TxWinRxdAckDupCtr++;                        // .. inc dup ack ctr.

            //                                                     If equal to fast re-tx th,                ..
            if (p_conn->TxWinRxdAckDupCtr == NET_TCP_FAST_RE_TX_ACK_DUP_TH) {
              //                                                   .. perform fast re-tx (see Note #2c2B1) : ..
              //                                                   .. calc slow start th (see Note #2c2B1a); ..
              NetTCP_TxConnWinSizeCalcSlowStartTh(p_conn);
              //                                                   .. re-tx unack'd seg  (see Note #2c2B1b); ..
              NetTCP_TxConnReTxQ(p_conn, DEF_NO, NET_TCP_CONN_CLOSE_ALL, p_err);
              switch (RTOS_ERR_CODE_GET(*p_err)) {
                case RTOS_ERR_NONE:
                case RTOS_ERR_NET_IF_LINK_DOWN:                  // Ignore transitory re-tx err(s).
                  break;

                default:
                  goto exit;
              }
              //                                                   .. set cong win to fast recovery th      ..
              //                                                   ..                    (see Note #2c2B1c).
              NetTCP_TxConnWinSizeCongSet(p_conn, NET_TCP_CONN_TX_WIN_CONG_SET_FAST_RECOVERY);
              NetTCP_TxConnWinSizeUpdateAvail(p_conn);                 // Update avail tx win   (see Note #2b3).

              //                                                   Else if  > fast re-tx th,                ..
            } else if (p_conn->TxWinRxdAckDupCtr > NET_TCP_FAST_RE_TX_ACK_DUP_TH) {
              //                                                   .. perform fast recovery (see Note #2c2B2) :
              //                                                   .. inc cong win by MSS   (see Note #2c2B2a),
              NetTCP_TxConnWinSizeCongInc(p_conn, p_buf_hdr, 0u, NET_TCP_CONN_TX_WIN_CONG_INC_SLOW_START);
              NetTCP_TxConnWinSizeUpdateAvail(p_conn);                 // .. update avail tx win   (see Note #2b3) ..
#if 0                                                           // .. & tx avail seg(s)     [see Note #2c2B2b].
              NetTCP_TxConnTxQ(p_conn, p_buf_hdr, ack_code, DEF_NO, NET_TCP_CONN_CLOSE_ALL, DEF_YES, p_err);
              switch (RTOS_ERR_CODE_GET(*p_err)) {
                case RTOS_ERR_NONE:
                case RTOS_ERR_NET_IF_LINK_DOWN:
                  break;

                default:
                  goto exit;
              }
#endif
            } else {
              ;
            }
          } else {                                              // Else update dup ack ctrls (see Note #2d1C).
            NetTCP_TxConnWinSizeDupAckCtrlUpdate(p_conn, p_buf_hdr, DEF_NO);
          }
          break;

        case NET_TCP_CONN_RX_ACK_PREV:                          // Ignore prev dup acks.
          goto exit;

        case NET_TCP_CONN_RX_ACK_NONE:
        case NET_TCP_CONN_RX_ACK_INVALID:
        default:
          RTOS_ERR_SET(*p_err, RTOS_ERR_TX);
          goto exit;
      }
      break;

    case NET_TCP_CONN_TX_WIN_TIMEOUT:                           // -------------------- SLOW START --------------------
                                                                // On timeout (see Note #2c2A5),             ..
                                                                // .. perform slow start (see Note #2c2A5c) :
      NetTCP_TxConnWinSizeCalcSlowStartTh(p_conn);              // .. calc slow start th (see Note #2c2A5a); ..
                                                                // .. set cong win to timeout th             ..
                                                                // ..                    (see Note #2c2A5b).
      NetTCP_TxConnWinSizeCongSet(p_conn, NET_TCP_CONN_TX_WIN_CONG_SET_TIMEOUT);
      NetTCP_TxConnWinSizeUpdateAvail(p_conn);                  // Update avail tx win   (see Note #2b3).
      break;

    case NET_TCP_CONN_TX_WIN_INC:
      if (win_update_size < 1) {                                // If NO win update, do NOT update win.
        break;
      }
      //                                                           Inc rem cong win size.
      NetTCP_TxConnWinSizeCongInc(p_conn, p_buf_hdr, win_update_size, NET_TCP_CONN_TX_WIN_CONG_INC_REM);
      NetTCP_TxConnWinSizeUpdateAvail(p_conn);                  // Update avail tx win (see Note #2b3).
      break;

    case NET_TCP_CONN_TX_WIN_DEC:
      if (win_update_size < 1) {                                // If NO win update, do NOT update win.
        break;
      }

      if (p_conn->TxWinSizeCongRem > win_update_size) {         // If rem cong   win size >  win update, ..
        p_conn->TxWinSizeCongRem -= win_update_size;            // .. dec cong   win size by win update.
      } else {
        p_conn->TxWinSizeCongRem = 0u;                          // Else lim to min cong   win size.
      }

      if (p_conn->TxWinSizeRemoteRem > win_update_size) {         // If rem remote win size >  win update, ..
        p_conn->TxWinSizeRemoteRem -= win_update_size;          // .. dec remote win size by win update.
      } else {
        p_conn->TxWinSizeRemoteRem = 0u;                        // Else lim to min remote win size.
      }

      NetTCP_TxConnWinSizeUpdateAvail(p_conn);                  // Update avail tx win (see Note #2b3).
      break;

    case NET_TCP_CONN_TX_WIN_REMOTE_UPDATE:
      //                                                           Calc actual tx remote win (see Note #3a2A1a).
      tx_win_size_remote_actual = (NET_TCP_WIN_SIZE)(p_buf_hdr->TCP_WinSize - (p_conn->TxSeqNbrNext - p_buf_hdr->TCP_AckNbr));
      tx_win_size_remote_actual_min = (NET_TCP_WIN_SIZE) DEF_MIN(p_buf_hdr->TCP_WinSize, tx_win_size_remote_actual);
      //                                                           Update      tx remote win (see Note #3a2).
      p_conn->TxWinSizeRemote = (NET_TCP_WIN_SIZE) p_buf_hdr->TCP_WinSize;
      p_conn->TxWinSizeRemoteActual = (NET_TCP_WIN_SIZE) tx_win_size_remote_actual_min;
      p_conn->TxWinSizeRemoteRem = (NET_TCP_WIN_SIZE) p_conn->TxWinSizeRemoteActual;
      p_conn->TxWinUpdateSeqNbr = (NET_TCP_SEQ_NBR) p_buf_hdr->TCP_SeqNbr;
      p_conn->TxWinUpdateAckNbr = (NET_TCP_SEQ_NBR) p_buf_hdr->TCP_AckNbr;
      p_conn->TxWinUpdateWinSize = (NET_TCP_WIN_SIZE) p_buf_hdr->TCP_WinSize;

      if (p_conn->TxWinSizeRemoteMax < p_conn->TxWinSizeRemote) {        // If max < updated remote win size, ...
        p_conn->TxWinSizeRemoteMax = p_conn->TxWinSizeRemote;          // ... set as new max   (see Note #3b).

        NetTCP_TxConnWinSizeCfgMinTh(p_conn);                   // Cfg new tx silly win min th.
      }
      //                                                           Handle zero win size (see Note #3c).
      NetTCP_TxConnWinSizeZeroWinHandler(p_conn, NET_TCP_CONN_TX_WIN_REMOTE_UPDATE, NET_TCP_CONN_CLOSE_ALL);

      NetTCP_TxConnWinSizeUpdateAvail(p_conn);                  // Update avail tx win  (see Note #2b3).
      break;
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                   NetTCP_TxConnWinSizeCalcSlowStartTh()
 *
 * @brief    Calculate TCP connection's transmit slow start threshold.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) RFC #2581, Section 3.1 states that :
 *
 *                       - (a) "the value of ssthresh MUST be set to no more than" :
 *
 *                       - (3) ssthresh = max (FlightSize / 2, 2 * SMSS)
 *
 *                       - (A) "FlightSize is the amount of outstanding data ... that has been sent but
 *                   not yet acknowledged."
 *
 *                   See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2c2A5a'.
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeCalcSlowStartTh(NET_TCP_CONN *p_conn)
{
  NET_TCP_SEQ_NBR  tx_data_unackd;
  NET_TCP_SEQ_NBR  tx_data_unackd_th;
  NET_TCP_SEG_SIZE max_seg_size_th;

  //                                                               Calc slow start th (see Note #1a3).
  tx_data_unackd = (NET_TCP_SEQ_NBR) (p_conn->TxSeqNbrNext - p_conn->TxSeqNbrUnAckd);
  tx_data_unackd_th = (NET_TCP_SEQ_NBR)((tx_data_unackd * NET_TCP_SST_UNACKD_DATA_NUMER)
                                        / NET_TCP_SST_UNACKD_DATA_DENOM);

  max_seg_size_th = (NET_TCP_SEG_SIZE)p_conn->MaxSegSizeConn * NET_TCP_SST_MSS_SCALAR;

  p_conn->TxWinSizeSlowStartTh = (NET_TCP_WIN_SIZE)DEF_MAX(tx_data_unackd_th,
                                                           max_seg_size_th);
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnWinSizeCongSet()
 *
 * @brief    Set TCP connection's transmit congestion window.
 *
 * @param    p_conn          Pointer to a TCP connection.
 *
 * @param    win_inc_code    Indicate how to set TCP connection transmit congestion window :
 *                           NET_TCP_CONN_TX_WIN_CONG_SET_SLOW_START         Set TCP connection's congestion
 *                           control transmit window size
 *                           based on slow start.
 *                           NET_TCP_CONN_TX_WIN_CONG_SET_FAST_RECOVERY      Set TCP connection's congestion
 *                           control transmit window size
 *                           based on fast recovery
 *                           (see Note #1a).
 *                           NET_TCP_CONN_TX_WIN_CONG_SET_TIMEOUT            Set TCP connection's congestion
 *                           control transmit window size
 *                           based on transmission timeout
 *                           (see Note #1b).
 *
 * @note     (1) (a) RFC #2581, Section 3.2 states that "when the third duplicate ACK is received ...
 *                           [for] fast recovery ... set cwnd to ssthresh plus 3*SMSS".
 *
 *                           See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2c2B1c'.
 *
 *                               - (b) RFC #2581, Section 3.1 states that "when a TCP sender detects segment loss using the
 *                           retransmission timer ... cwnd MUST be set to no more than ... 1 full-sized segment".
 *
 *                           See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2c2A5b'.
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeCongSet(NET_TCP_CONN     *p_conn,
                                        NET_TCP_WIN_CODE win_inc_code)
{
  NET_TCP_WIN_SIZE win_size_set;

  switch (win_inc_code) {
    case NET_TCP_CONN_TX_WIN_CONG_SET_SLOW_START:
      win_size_set = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeSlowStartTh;
      break;

    case NET_TCP_CONN_TX_WIN_CONG_SET_FAST_RECOVERY:            // See Note #1a.
      win_size_set = (NET_TCP_WIN_SIZE)p_conn->TxWinSizeSlowStartTh;
      win_size_set += (NET_TCP_WIN_SIZE)p_conn->MaxSegSizeConn * NET_TCP_FAST_RECOVERY_MSS_SCALAR;
      break;

    case NET_TCP_CONN_TX_WIN_CONG_SET_TIMEOUT:                  // See Note #1b.
    default:
      win_size_set = (NET_TCP_WIN_SIZE)p_conn->MaxSegSizeConn * NET_TCP_CONG_WIN_MSS_SCALAR_TIMEOUT;
      break;
  }

  p_conn->TxWinSizeCongCalcdActual = win_size_set;
  p_conn->TxWinSizeCongCalcdCur = 0u;
  p_conn->TxWinSizeCongRem = p_conn->TxWinSizeCongCalcdActual;
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnWinSizeCongInc()
 *
 * @brief    Increment TCP connection's transmit congestion window.
 *
 * @param    p_conn              Pointer to a TCP connection.
 *
 * @param    p_buf_hdr           Pointer to network buffer header that received TCP packet.
 *
 * @param    win_update_size     Size to increment TCP connection's transmit congestion window (in octets).
 *
 * @param    win_inc_code        Indicate how to increment TCP connection transmit congestion window :
 *                               NET_TCP_CONN_TX_WIN_CONG_INC_SLOW_START     Increment TCP connection's congestion
 *                               control transmit window size
 *                               based on slow start
 *                               (see Note #1a).
 *                               NET_TCP_CONN_TX_WIN_CONG_INC_CONG_AVOID     Increment TCP connection's congestion
 *                               control transmit window size
 *                               based on congestion avoidance
 *                               (see Note #1b).
 *                               NET_TCP_CONN_TX_WIN_CONG_INC_REM            Increment TCP connection's congestion
 *                               control transmit window size
 *                               remaining.
 *
 * @note     (1) RFC #2581, Section 3.1 states that :
 *
 *                                   - (a) "During slow start, a TCP increments cwnd by at most SMSS bytes for each ACK received
 *                               that acknowledges new data."
 *
 *                               See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2c2A3a'.
 *
 *                                   - (b) "During congestion avoidance, cwnd is incremented by 1 full-sized segment per round-
 *                               trip time (RTT) ... [An] acceptable way to increase cwnd during congestion avoidance
 *                               is to" :
 *
 *                                   - (1) "Count the number of bytes that have been acknowledged by ACKs for new data."
 *
 *                                   - (A) The following equation calculates the number of octets that acknowledge
 *                               new data for a TCP connection :
 *
 *                               Number of Octets Acknowledged  =  (SEG.ACK - SND.UNA)
 *
 *                                   - (B) However, since TCP connection transmit congestion controls are
 *                               updated following any TCP connection re-transmit queue handling
 *                               (see 'NetTCP_RxPktConnHandlerSeg()  Notes #1c & #1d'); the saved
 *                               previous value of the TCP connection's last unacknowledged
 *                               transmit sequence number ('TxSeqNbrUnackdPrev') MUST be used
 *                               (see 'NetTCP_RxPktConnHandlerReTxQ()  Note #4').
 *
 *                                   - (2) "When the number of bytes acknowledged reaches cwnd," ...
 *                                   - (3) "then cwnd can be incremented by up to SMSS bytes."
 *
 *                               See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2c2A4'.
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeCongInc(NET_TCP_CONN     *p_conn,
                                        NET_BUF_HDR      *p_buf_hdr,
                                        NET_TCP_WIN_SIZE win_update_size,
                                        NET_TCP_WIN_CODE win_inc_code)
{
  CPU_BOOLEAN      win_size_rem_update;
  NET_TCP_WIN_SIZE win_size_inc;
  NET_TCP_WIN_SIZE win_size_inc_mss;
  NET_TCP_WIN_SIZE win_size_inc_rem;
  NET_TCP_WIN_SIZE win_size_avail;

  win_size_rem_update = DEF_NO;
  win_size_inc_mss = (NET_TCP_WIN_SIZE)p_conn->MaxSegSizeConn * NET_TCP_CONG_WIN_MSS_SCALAR_INC;

  switch (win_inc_code) {
    case NET_TCP_CONN_TX_WIN_CONG_INC_SLOW_START:               // See Note #1a.
    default:
      win_size_avail = NET_TCP_WIN_SIZE_MAX - p_conn->TxWinSizeCongCalcdActual;
      if (win_size_inc_mss < win_size_avail) {                  // If inc < max avail, ..
        p_conn->TxWinSizeCongCalcdActual += win_size_inc_mss;          // .. inc cong win by MSS (see Note #1a).
      } else {
        p_conn->TxWinSizeCongCalcdActual = NET_TCP_WIN_SIZE_MAX;           // Else set cong win to max.
      }

      p_conn->TxWinSizeCongCalcdCur = 0u;
      win_size_rem_update = DEF_YES;
      win_size_inc_rem = win_size_inc_mss;
      break;

    case NET_TCP_CONN_TX_WIN_CONG_INC_CONG_AVOID:               // See Note #1b.
                                                                // Calc nbr ack'd octets   (see Note #1b1).
      win_size_inc = (NET_TCP_WIN_SIZE)(p_buf_hdr->TCP_AckNbr - p_conn->TxSeqNbrUnAckdPrev);

      win_size_avail = NET_TCP_WIN_SIZE_MAX - p_conn->TxWinSizeCongCalcdActual;
      if (win_size_inc < win_size_avail) {                      // If inc < max avail, ..
        p_conn->TxWinSizeCongCalcdCur += win_size_inc;          // .. inc nbr ack'd octets (see Note #1b1).
                                                                // If  >= cong win         (see Note #1b2),
                                                                // .. inc cong win by MSS  (see Note #1b3).
        if (p_conn->TxWinSizeCongCalcdCur >= p_conn->TxWinSizeCongCalcdActual) {
          p_conn->TxWinSizeCongCalcdCur -= p_conn->TxWinSizeCongCalcdActual;

          win_size_avail = NET_TCP_WIN_SIZE_MAX - p_conn->TxWinSizeCongCalcdActual;
          if (win_size_inc_mss < win_size_avail) {
            p_conn->TxWinSizeCongCalcdActual += win_size_inc_mss;
          } else {
            p_conn->TxWinSizeCongCalcdActual = NET_TCP_WIN_SIZE_MAX;
          }
          //                                                       Cfg rem cong win inc by MSS.
          win_size_rem_update = DEF_YES;
          win_size_inc_rem = win_size_inc_mss;
        }
      } else {                                                  // Else set cong win to max.
        p_conn->TxWinSizeCongCalcdActual = NET_TCP_WIN_SIZE_MAX;

        win_size_avail = NET_TCP_WIN_SIZE_MAX - p_conn->TxWinSizeCongCalcdCur;
        if (win_size_inc < win_size_avail) {                    // If inc < max avail, ..
          p_conn->TxWinSizeCongCalcdCur += win_size_inc;            // .. inc nbr ack'd octets (see Note #1b1).
        } else {                                                // Else set nbr ack'd octets to inc ovf ...
          p_conn->TxWinSizeCongCalcdCur = win_size_inc - win_size_avail;
          //                                                       ... & cfg rem cong win inc by MSS.
          win_size_rem_update = DEF_YES;
          win_size_inc_rem = win_size_inc_mss;
        }
      }
      break;

    case NET_TCP_CONN_TX_WIN_CONG_INC_REM:                      // Cfg rem cong win inc by win update size.
      win_size_rem_update = DEF_YES;
      win_size_inc_rem = win_update_size;
      break;
  }

  if (win_size_rem_update == DEF_YES) {                         // If rem tx cong win update req'd  ...
    if (p_conn->TxWinSizeCongRem < p_conn->TxWinSizeCongCalcdActual) {     // ... & < actual tx cong win size, ...
      //                                                           ... inc rem tx cong win size.
      win_size_avail = p_conn->TxWinSizeCongCalcdActual - p_conn->TxWinSizeCongRem;
      if (win_size_inc_rem < win_size_avail) {                  // If avail win size > rem inc, ...
        p_conn->TxWinSizeCongRem += win_size_inc_rem;           // ... inc rem tx cong win size by rem inc.
      } else {                                                  // Else lim to actual tx cong win size.
        p_conn->TxWinSizeCongRem = p_conn->TxWinSizeCongCalcdActual;
      }
    }
  }
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnWinSizeUpdateAvail()
 *
 * @brief    Update TCP connection's available transmit window.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) (a) RFC #2001, Section 1 states that "the sender can transmit up to the minimum
 *                   of the congestion window and the advertised window."
 *
 *                       - (b) RFC #2001, Section 2.2 reiterates that "the TCP output routine never sends
 *                   more than the minimum of cwnd and the receiver's advertised window".
 *
 *                       - (c) RFC #2581, Section 3.1 also reiterates that "the minimum of cwnd and rwnd
 *                   [receiver's advertised window] governs data transmission".
 *
 *                   See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2b3'.
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeUpdateAvail(NET_TCP_CONN *p_conn)
{
  //                                                               Calc avail tx win (see Note #1).
  p_conn->TxWinSizeAvail = DEF_MIN(p_conn->TxWinSizeCongRem,
                                   p_conn->TxWinSizeRemoteRem);
}

/****************************************************************************************************//**
 *                                   NetTCP_TxConnWinSizeDupAckCtrlReset()
 *
 * @brief    Reset TCP connection's transmit window duplicate acknowledgement controls.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeDupAckCtrlReset(NET_TCP_CONN *p_conn)
{
  p_conn->TxWinRxdLastSeqNbr = p_conn->RxSeqNbrNext;
  p_conn->TxWinRxdLastAckNbr = p_conn->TxSeqNbrNext;
  p_conn->TxWinRxdLastWinSize = p_conn->TxWinSizeRemote;
  p_conn->TxWinRxdAckDupCtr = 0u;
}

/****************************************************************************************************//**
 *                                   NetTCP_TxConnWinSizeDupAckCtrlUpdate()
 *
 * @brief    Update TCP connection's transmit window duplicate acknowledgment controls.
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    reset_ctr   Indicate whether to reset the duplicate acknowledgment counter :
 *                       DEF_YES                Reset duplicate acknowledgment counter.
 *                       DEF_NO          Do NOT reset duplicate acknowledgment counter.
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeDupAckCtrlUpdate(NET_TCP_CONN *p_conn,
                                                 NET_BUF_HDR  *p_buf_hdr,
                                                 CPU_BOOLEAN  reset_ctr)
{
  p_conn->TxWinRxdLastSeqNbr = p_buf_hdr->TCP_SeqNbr;
  p_conn->TxWinRxdLastAckNbr = p_buf_hdr->TCP_AckNbr;
  p_conn->TxWinRxdLastWinSize = p_buf_hdr->TCP_WinSize;

  if (reset_ctr == DEF_YES) {
    p_conn->TxWinRxdAckDupCtr = 0u;
  }
}

/****************************************************************************************************//**
 *                                   NetTCP_TxConnWinSizeZeroWinHandler()
 *
 * @brief    Handle TCP connection's transmit queue zero window.
 *
 * @param    p_conn              Pointer to TCP connection.
 *
 * @param    win_update_code     Indicate how to update TCP connection transmit window :
 *                               NET_TCP_CONN_TX_WIN_REMOTE_UPDATE   Handle TCP connection's remote
 *                               receive      window size update.
 *                               NET_TCP_CONN_TX_WIN_TIMEOUT         Handle TCP connection's remote
 *                               receive zero window size timeout.
 *
 * @param    close_code          Select which close action(s) to perform; bit-field flags logically OR'd :
 *                               NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
 *                               NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
 *                               NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
 *                               NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
 *                               NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
 *                               NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
 *                               NET_TCP_CONN_CLOSE_TMR_KEEP_ALIVE       Close connection keep-alive             timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
 *                               NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
 *                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *
 * @note     (1) RFC #1122, Section 4.2.2.17 states that although "a TCP MAY keep its offered receive
 *                               window closed indefinitely ... the sending TCP MUST allow the connection to stay open
 *                               ... as long as the receiving TCP continues to send acknowledgments in response to ...
 *                               probe segments".
 *
 *                                   - (a) "Probing of zero (offered) windows MUST be supported."
 *
 *                                   - (1) "If zero window probing is not supported, a connection may hang forever when
 *                               an ACK segment that re-opens the window is lost."
 *
 *                               See also Note #1c2.
 *
 *                                   - (b) (1) "The transmitting host SHOULD send the first zero-window probe when a zero
 *                               window has existed for the retransmission timeout period," ...
 *
 *                                   - (2) "and SHOULD increase exponentially the interval between successive probes."
 *
 *                                   - (A) "Exponential backoff is recommended ... similar to ... the retransmission
 *                               algorithm, and it may be possible to combine the two procedures in the
 *                               implementation."
 *
 *                               See also 'NetTCP_TxConnRTO_CalcBackOff()  Notes #1 & #2'.
 *
 *                                   - (B) (1) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 22.2,
 *                               Page 325 reiterates that "the normal TCP exponential backoff is used
 *                               when calculating the persist timer".
 *
 *                                   - (2) However, "the persist timer is always bounded between 5 and 60 seconds".
 *
 *                                   - (C) Therefore, it seems reasonable to implement TCP zero window probes with
 *                               the same algorithm as TCP retransmissions, including limiting zero window
 *                               probes' minimum & maximum timeout values.
 *
 *                               See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2b1'.
 *
 *                                   - (c) (1) (A) "It is extremely important to remember that ACK (acknowledgment) segments
 *                               that contain no data are not reliably transmitted by TCP."
 *
 *                                   - (B) "This procedure minimizes delay if the zero-window condition is due to a
 *                               lost ACK segment containing a window-opening update."
 *
 *                                   - (C) Thus Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 22.2,
 *                               Page 325 adds that "window probes contain 1 byte of data" but unlike TCP
 *                               "retransmission ... TCP never gives up sending window probes ... [which]
 *                               continue to be sent ... until the window opens up or either of the
 *                               applications using the connection is terminated".
 *
 *                                   - (2) RFC #793, Section 3.7 'Data Communication : Managing the Window : Window
 *                               Management Suggestions' states that "if a segment containing a single data
 *                               octet sent to probe a zero window is accepted, it consumes one octet of the
 *                               window now available ... As time goes on, occasional pauses in the receiver
 *                               making window allocation available will result in ... the transmitted data
 *                               will be[ing] broken into alternating big and small segments ... And after
 *                               a while the data transmission will be in mostly small segments ... but TCP
 *                               implementations need to actively attempt to combine small window allocations
 *                               into larger windows, since the mechanisms for managing the window tend to
 *                               lead to many small windows".
 *
 *                                   - (3) So although it is suggested, NO RFC requires that a TCP zero window probe
 *                               include data.  Therefore, it seems reasonable to transmit TCP zero window
 *                               probes similar to TCP Keep-Alive probes, i.e. without any data from the TCP
 *                               connection's transmit queue.
 *
 *                               See also 'NetTCP_TxConnProbe()  Note #2b2'.
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeZeroWinHandler(NET_TCP_CONN       *p_conn,
                                               NET_TCP_WIN_CODE   win_update_code,
                                               NET_TCP_CLOSE_CODE close_code)
{
  CPU_BOOLEAN tmr_update;
  CPU_INT32U  timeout_ms;
  RTOS_ERR    local_err;

  //                                                               ------------- VALIDATE TCP CONN STATE --------------
  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      goto exit;

    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      break;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  //                                                               ----------- HANDLE TCP CONN TX ZERO WIN ------------
  tmr_update = DEF_NO;

  switch (win_update_code) {
    case NET_TCP_CONN_TX_WIN_REMOTE_UPDATE:
    default:
      if (p_conn->TxWinSizeRemote > 0) {                        // If remote win size > 0, ...
        if (p_conn->TxQ_ZeroWinTmr != DEF_NULL) {               // ... free zero win tmr.
          NetTmr_Free(p_conn->TxQ_ZeroWinTmr);
          p_conn->TxQ_ZeroWinTmr = DEF_NULL;
        }
      } else {                                                  // Else if remote win size zero            ...
        if (p_conn->TxQ_ZeroWinTmr == DEF_NULL) {               // ... & NO zero win tmr;                  ...
                                                                // ... set first tx zero win probe timeout ...
          timeout_ms = p_conn->TxRTT_RTO_ms;                    // ... = RTO (see Note #1b1).
          tmr_update = DEF_YES;
        }
      }
      break;

    case NET_TCP_CONN_TX_WIN_TIMEOUT:                           // On timeout,                             ...
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      NetTCP_TxConnProbe(p_conn,                                // ... tx zero-win probe   (see Note #1c3) ...
                         DEF_NO,
                         close_code,
                         &local_err);                           // Ignore transitory tx err(s).
                                                                // ... & calc next timeout (see Note #1b2).
      timeout_ms = (NET_TCP_TIMEOUT_MS)NetTCP_TxConnRTO_CalcBackOff(p_conn, p_conn->TxWinZeroWinTimeout_ms);
      tmr_update = DEF_YES;
      break;
  }

  if (tmr_update == DEF_YES) {                                  // If tx probe tmr update req'd, ...
                                                                // ... get tx zero win probe tmr.
    RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
    p_conn->TxQ_ZeroWinTmr = NetTmr_Get(NetTCP_TxConnWinSizeZeroWinTimeout,
                                        p_conn,
                                        timeout_ms,
                                        NET_TMR_OPT_NONE,
                                        &local_err);
    if (RTOS_ERR_CODE_GET(local_err) != RTOS_ERR_NONE) {
      goto exit;
    }

    p_conn->TxWinZeroWinTimeout_ms = timeout_ms;                // If NO err(s), cfg tx zero win probe timeout.
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                   NetTCP_TxConnWinSizeZeroWinTimeout()
 *
 * @brief    (1) (a) Handle TCP connection's transmit queue zero window persist timeout ... :
 *
 *               - (1) Clear  TCP connection's transmit zero window persist timer      See Notes #4a1A & #4a2
 *               - (2) Handle TCP connection   transmit zero window                    See Note  #2
 *
 *           - (b) ... for the following states :
 *
 *               - (1) ESTABLISHED
 *               - (2) FIN-WAIT-1
 *               - (3) CLOSING
 *               - (4) CLOSE-WAIT
 *               - (5) LAST-ACK
 *
 *
 * Argument(s) : p_conn_timeout       Pointer to TCP connection (see Note #3b).
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) RFC #1122, Section 4.2.2.17 states that the "probing of zero (offered) windows
 *                   ... SHOULD send the first zero-window probe when a zero window has existed for
 *                   the retransmission timeout period and SHOULD increase exponentially the interval
 *                   between successive probes".
 *
 *                   See also 'NetTCP_TxConnWinSizeZeroWinHandler()  Note #1'.
 *
 *               (3) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
 *                   type functions -- even though network timer API functions cast callback functions
 *                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
 *
 *                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
 *                           to an object ... may be converted to a pointer to a different object ...
 *                           [but] if the resulting pointer is not correctly aligned ... the behavior
 *                           is undefined".
 *
 *                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
 *                           pointer arguments, network timer callback functions MUST avoid incorrect
 *                           pointer conversion behavior between 'void' pointer parameters & non-'void'
 *                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
 *
 *                               - (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
 *                           to or from a pointer to any ... object ... A pointer to any ... object ...
 *                           may be converted to a pointer to void and back again; the result shall
 *                           compare equal to the original pointer".
 *
 *                               - (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
 *                           network object pointer objects, network timer callback functions MUST :
 *
 *                               - (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
 *                               - (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
 *                               - (A) in this case, a 'NET_TCP_CONN' pointer.
 *
 *                           See also 'net_tmr.c  NetTmr_Get()  Note #3'.
 *
 * @note     (4) This function is a network timer callback function :
 *
 *                               - (a) (1) For the following connection timer(s) ... :
 *
 *                               - (A) TCP connection transmit zero window persist timer ('TxQ_ZeroWinTmr')
 *
 *                               - (2) (A) Clear the timer pointer ... :
 *                               - (1) Cleared prior to next handler function(s); ...
 *                               - (2) Cleared prior to invalid state fault exit.
 *
 *                               - (B) but do NOT re-free the timer.
 *
 *                               - (b) Do NOT set the following close timer flag(s) :
 *
 *                               - (1) NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN
 *
 * @note     (5) Certain network connections MUST periodically suspend network transmit(s) to handle
 *                           network receive packet(s).  To protect TCP connections from transmit corruption while
 *                           suspended, ALL TCP data transmits & TCP transmit queue handling MUST be blocked for
 *                           suspended connections until the connection is no longer suspended.
 *
 *                           However, handling the TCP connection's transmit zero window timeout is permitted since
 *                           NO new TCP data is prepared from the TCP connection's transmit queue (see Note #1a).
 *
 *                           See also 'NetTCP_TxConnTxQ()                  Note #12b2A2',
 *                           'NetTCP_TxConnTxQ_TimeoutIdle()      Note #5',
 *                           'NetTCP_TxConnTxQ_TimeoutSillyWin()  Note #5',
 *                           & 'NetTCP_TxConnReTxQ_Timeout()        Note #5'.
 *******************************************************************************************************/
static void NetTCP_TxConnWinSizeZeroWinTimeout(void *p_conn_timeout)
{
  NET_TCP_CONN       *p_conn;
  NET_TCP_CLOSE_CODE close_code;

  p_conn = (NET_TCP_CONN *)p_conn_timeout;                      // See Note #3b2A.

  close_code = NET_TCP_CONN_CLOSE_ALL;
  //                                                               See Note #4b1.
  DEF_BIT_CLR(close_code, (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN);
  //                                                               ------- HANDLE TCP CONN TX ZERO WIN TIMEOUT --------
  p_conn->TxQ_ZeroWinTmr = DEF_NULL;                            // Clr    tx zero win tmr (see Note #4a2A1).

  //                                                               Handle tx zero win     (see Note #2).
  NetTCP_TxConnWinSizeZeroWinHandler(p_conn, NET_TCP_CONN_TX_WIN_TIMEOUT, close_code);
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnSync()
 *
 * @brief    (1) Prepare & transmit a TCP connection synchronization :
 *
 *           - (a) Validate TCP connection state
 *           - (b) Prepare  TCP connection synchronization :
 *               - (1) Get  timer
 *               - (2) Get  buffer
 *               - (3) Prepare TCP segment :
 *                   - (A) TCP segment  addresses
 *                   - (B) TCP segment  sequence numbers
 *                   - (C) TCP segment  transmit flags :
 *                       - (1) SYN
 *                       - (2) ACK
 *                   - (D) TCP segment  window size
 *                   - (E) TCP segment  options
 *                   - (F) IP  datagram parameters
 *                   - (G) TCP segment  packet buffer controls
 *           - (c) Update  TCP connection :
 *               - (1) Queue  TCP connection synchronization packet
 *               - (2) Update TCP connection sequence numbers
 *           - (d) Transmit   TCP connection synchronization
 *
 *       - (2) (a) RFC #793, Section 3.3 'Sequence Numbers : Initial Sequence Number Selection' states
 *                   that "for a [TCP] connection to be established or initialized, ... two TCP's must
 *                   synchronize ... each other's initial sequence numbers" by transmitting initial
 *                   connection request segments (i.e., segments with the SYN control bit set).
 *
 *                   RFC #793, Section 3.4 states that "this procedure normally is initiated by one TCP
 *                   and responded to by another TCP ... [but] works if two TCP simultaneously initiate
 *                   the procedure".
 *
 *           - (b) RFC #793, Section 3.9 'Event Processing : OPEN Call : CLOSED STATE' states that after
 *                   "a SYN segment ... is sent ... [to] set SND.UNA to ISS [initial send sequence number],
 *                   SND.NXT to ISS+1".
 *
 *                   The following sections confirm these sequence number configurations summary :
 *
 *               - (1) RFC #793, Section 3.9 'Event Processing : OPEN Call : LISTEN STATE'
 *               - (2) RFC #793, Section 3.9 'Event Processing : SEND Call : LISTEN STATE'
 *               - (3) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State] :
 *                           Check for SYN'
 *
 *       - (3) A TCP connection's transmit sequences are initialized when the initial TCP synchronization
 *               segment is queued for transmission :
 *
 *           - (a) 'TxSeqNbrSync' points to the initial, synchronization (SYN) transmit sequence number.
 *
 *           - (b) (1) 'TxSeqNbrNextQ' points to the next transmit sequence number to enqueue data octets.
 *               - (2) 'TxSeqNbrNext'  points to the next transmit sequence number to transmit.
 *
 *                           -----          -----------------------        Initial Synchronization
 *                           ^            |  Initial SEQ #(SYN) |  <---  Transmit Sequence Number
 *                           |            -----------------------            (see Note #3a)
 *                           |            |    Data Octet #1    |  ---
 *                           |            |    Data Octet #2    |   ^
 *                           |            |    Data Octet #3    |   |
 *                                           |          .          |   |         Next / Queued
 *                       TCP Connection     |          .          |   |   Transmit Sequence Number(s)
 *                   Transmit Sequences   |          .          |   |         (see Note #3b)
 *                       (see Note #3)      | Data Octet #(N - 2) |   |
 *                                           | Data Octet #(N - 1) |   v
 *                           |            | Data Octet #   N    |  ---
 *                           |            -----------------------
 *                           |            |   Close SEQ #(FIN)  |
 *                           |            -----------------------
 *                           v            |    Last SEQ #       |
 *                           -----          -----------------------
 *
 *               See also 'NetTCP_TxConnClose()  Note #2'.
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 * @param    state       Current TCP connection state at time of connection request.
 *
 *
 * Argument(s) : p_conn      Pointer to a TCP connection.
 *
 *               p_buf_hdr   Pointer to network buffer header that received TCP packet.
 *
 *               state       Current TCP connection state at time of connection request.
 *
 *               p_err       Pointer to variable that will receive the return error code from this function.
 *
 * Return(s)   : none.
 *
 * Note(s)     : (4) RFC #1122, Section 4.2.2.6 states that a "TCP SHOULD send an MSS (Maximum Segment Size)
 *                   option in every SYN segment".
 *
 *               (5) Network resources MUST be appropriately allocated/deallocated :
 *
 *                   (a) Increment network buffer's reference counter to include the TCP connection
 *                       synchronization segment now enqueued to the TCP connection's re-transmit
 *                       queue as a new reference to the network buffer.
 *
 *                       This differs from the handling of TCP connection   close segment's reference counter
 *                       since NetTCP_TxConnClose() defers incrementing the close segment's reference counter
 *                       to NetTCP_TxConnTxQ() when it enqueues the   TCP connection close segment to the TCP
 *                       connection's re-transmit queue (see 'NetTCP_TxConnClose()  Note #3a'); whereas
 *                       NetTCP_TxConnSync() immediately enqueues the TCP connection synchronization segment
 *                       to the TCP connection's re-transmit queue & transmits the segment.
 *
 *                           - (b) On ANY error(s), network resources MUST be appropriately freed :
 *
 *                           - (1) For any network resources NOT  yet       linked to the TCP connection, each
 *                       network resource  MUST be freed by appropriate function(s).
 *                           - (2) For all network resources that have been linked to the TCP connection, ALL
 *                       network resources are     freed by NetTCP_ConnClose().
 *
 * @note     (6) If transmitting a TCP synchronization packet from the SYN-SENT state :
 *
 *                           - (a) Connection timeout is reset to initial synchronization timeout value
 *                           - (b) Previous synchronization sequence number MUST be re-used
 *                           - (c) Previous synchronization packet in TCP connection's re-transmit queue is freed
 *
 *                       See also 'NetTCP_RxPktConnHandlerSyncTxd()  Note #2c3B2'.
 *
 * @note     (7) IP transmit options currently NOT implemented      See 'net_tcp.h  Note #1d'
 *******************************************************************************************************/
static void NetTCP_TxConnSync(NET_TCP_CONN       *p_conn,
                              NET_BUF_HDR        *p_buf_hdr,
                              NET_TCP_CONN_STATE state,
                              RTOS_ERR           *p_err)
{
#ifdef  NET_IPv4_MODULE_EN
  NET_IPv4_TTL   TTL;
  NET_IPv4_TOS   TOS;
  NET_IPv4_ADDR  src_addrv4;
  NET_IPv4_ADDR  dest_addrv4;
  NET_IPv4_FLAGS flags_ipv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
  NET_IPv6_TRAFFIC_CLASS traffic_class;
  NET_IPv6_FLOW_LABEL    flow_label;
  NET_IPv6_HOP_LIM       hop_lim;
  NET_IPv6_ADDR          src_addrv6;
  NET_IPv6_ADDR          dest_addrv6;
  NET_IPv6_FLAGS         flags_ipv6;
#endif
  NET_CONN_ID                  conn_id;
  NET_CONN                     *p_net_conn;
  NET_IF_NBR                   if_nbr;
  NET_BUF                      *p_seg_sync;
  NET_BUF_HDR                  *p_seg_sync_hdr;
  NET_BUF_SIZE                 data_len;
  NET_BUF_SIZE                 data_ix;
  NET_BUF_SIZE                 data_ix_offset;
  NET_TCP_PORT_NBR             src_port;
  NET_TCP_PORT_NBR             dest_port;
  NET_TCP_SEQ_NBR              seq_nbr;
  NET_TCP_SEQ_NBR              ack_nbr;
  NET_TCP_WIN_SIZE             win_size;
  NET_PROTOCOL_TYPE            protocol;
  NET_TCP_OPT_CFG_MAX_SEG_SIZE *p_opt_cfg_max_seg_size;
  NET_TCP_OPT_CFG_MAX_SEG_SIZE opt_cfg_max_seg_size;
  NET_TCP_FLAGS                flags_tcp;
  NET_PROTOCOL_TYPE            proto_type = NET_PROTOCOL_TYPE_NONE;

  //                                                               ------------ PREPARE TCP CONN SYNC SEG -------------
  //                                                               --------------------- GET TMR ----------------------
  NetTCP_TxConnReTxQ_TimeoutSet(p_conn, DEF_NO, NET_TCP_CONN_CLOSE_ALL, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit;
  }

  //                                                               --------------------- GET BUF ----------------------
  conn_id = p_conn->ID_Conn;
  p_net_conn = (NET_CONN *)&NetConn_Tbl[conn_id];

  if_nbr = NetConn_IF_NbrGet(conn_id);

  data_len = NET_TCP_DATA_LEN_TX_SYNC;

  switch (p_net_conn->Family) {
    case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
      proto_type = NET_PROTOCOL_TYPE_TCP_V4;
      break;

    case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
      proto_type = NET_PROTOCOL_TYPE_TCP_V6;
      break;

    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
  }

  data_ix = 0u;

  NetTCP_GetTxDataIx(if_nbr, proto_type, 4u, data_len, p_conn, &data_ix);

  p_seg_sync = NetBuf_Get(if_nbr,
                          NET_TRANSACTION_TX,
                          data_len, data_ix,
                          &data_ix_offset,
                          NET_BUF_FLAG_NONE,
                          p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {             // See Note #5b1.
    goto exit;
  }

  data_ix += data_ix_offset;
  p_seg_sync_hdr = &p_seg_sync->Hdr;
  //                                                               ----------------- PREPARE TCP HDR ------------------
  //                                                               Prepare seg addrs.
  if (p_buf_hdr != DEF_NULL) {                                  // If TCP pkt rx'd, cfg TCP tx                ...
                                                                // ...  src  addr from rx'd TCP pkt dest addr ...
    if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
      src_addrv4 = p_buf_hdr->IP_AddrDest;
      //                                                           .. & dest addr from rx'd TCP pkt src  addr.
      dest_addrv4 = p_buf_hdr->IP_AddrSrc;
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
      DEF_BIT_SET(p_seg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);

      src_addrv6 = p_buf_hdr->IPv6_AddrDest;
      //                                                           .. & dest addr from rx'd TCP pkt src  addr.
      dest_addrv6 = p_buf_hdr->IPv6_AddrSrc;
#endif
    }
    src_port = (NET_TCP_PORT_NBR)p_buf_hdr->TransportPortDest;
    dest_port = (NET_TCP_PORT_NBR)p_buf_hdr->TransportPortSrc;
  } else {                                                      // Else cfg TCP tx pkt addrs from TCP conn addrs.
    if (p_net_conn->Family == NET_CONN_FAMILY_IP_V4_SOCK) {
#ifdef  NET_IPv4_MODULE_EN
      NetTCP_TxConnPrepareSegAddrs(p_conn,
                                   (CPU_INT08U *)&src_addrv4,
                                   (CPU_INT08U *)&src_port,
                                   sizeof(src_addrv4),
                                   sizeof(src_port),
                                   (CPU_INT08U *)&dest_addrv4,
                                   (CPU_INT08U *)&dest_port,
                                   sizeof(dest_addrv4),
                                   sizeof(dest_port),
                                   p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {         // See Note #5b1.
        goto exit_discard;
      }
#endif
    } else if (p_net_conn->Family == NET_CONN_FAMILY_IP_V6_SOCK) {
#ifdef  NET_IPv6_MODULE_EN
      DEF_BIT_SET(p_seg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);
      NetTCP_TxConnPrepareSegAddrs(p_conn,
                                   (CPU_INT08U *)&src_addrv6,
                                   (CPU_INT08U *)&src_port,
                                   sizeof(src_addrv6),
                                   sizeof(src_port),
                                   (CPU_INT08U *)&dest_addrv6,
                                   (CPU_INT08U *)&dest_port,
                                   sizeof(dest_addrv6),
                                   sizeof(dest_port),
                                   p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {         // See Note #5b1.
        goto exit_discard;
      }
#endif
    }
  }

  //                                                               Prepare TCP sync seq nbrs.
  if (state != NET_TCP_CONN_STATE_SYNC_TXD) {                   // For non-sync-tx'd states (see Note #6b), ...
    NET_TCP_TX_GET_SEQ_NBR(seq_nbr);                            // ... get sync seq nbr.
  } else {
    seq_nbr = p_conn->TxSeqNbrSync;
  }
  ack_nbr = (state != NET_TCP_CONN_STATE_CLOSED) ? p_conn->RxSeqNbrNext
            : NET_TCP_ACK_NBR_NONE;

  //                                                               Prepare TCP tx flags (see Note #1b3C).
  flags_tcp = NET_TCP_FLAG_NONE
              | NET_TCP_FLAG_TX_SYNC;
  if (state != NET_TCP_CONN_STATE_CLOSED) {                     // For non-CLOSED state, ...
    DEF_BIT_SET(flags_tcp, NET_TCP_FLAG_TX_ACK);                // ... tx ACK.
  }

  //                                                               Prepare TCP rx win size.
  win_size = p_conn->RxWinSizeActual;

  //                                                               Prepare TCP max seg size opt (see Note #4).
  //                                                               Get IF's MTU's.
  if (DEF_BIT_IS_CLR(p_seg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
    protocol = NET_PROTOCOL_TYPE_TCP_V4;
  } else {
    protocol = NET_PROTOCOL_TYPE_TCP_V6;
  }

  //                                                               Calc TCP conn's local max seg size.
  p_conn->MaxSegSizeLocalActual = NetIF_GetPayloadRxMax(if_nbr, protocol);

  p_opt_cfg_max_seg_size = &opt_cfg_max_seg_size;
  p_opt_cfg_max_seg_size->Type = NET_TCP_OPT_TYPE_MAX_SEG_SIZE;
  p_opt_cfg_max_seg_size->MaxSegSize = p_conn->MaxSegSizeLocalActual;
  p_opt_cfg_max_seg_size->NextOptPtr = DEF_NULL;

  if (DEF_BIT_IS_CLR(p_seg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
    //                                                             Prepare IP params.
    NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL);
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6);
#endif
  }

  //                                                               Init buf ctrls.
  p_seg_sync_hdr = &p_seg_sync->Hdr;
  p_seg_sync_hdr->DataIx = (CPU_INT16U)data_ix;
  p_seg_sync_hdr->DataLen = (NET_BUF_SIZE)data_len;
  p_seg_sync_hdr->TotLen = (NET_BUF_SIZE)p_seg_sync_hdr->DataLen;

  if (DEF_BIT_IS_CLR(p_seg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
    p_seg_sync_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V4;
    p_seg_sync_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V4;
    p_seg_sync_hdr->IP_AddrSrc = (NET_IPv4_ADDR)src_addrv4;
    p_seg_sync_hdr->IP_AddrDest = (NET_IPv4_ADDR)dest_addrv4;
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    p_seg_sync_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V6;
    p_seg_sync_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V6;
    p_seg_sync_hdr->IPv6_AddrSrc = src_addrv6;
    p_seg_sync_hdr->IPv6_AddrDest = dest_addrv6;
#endif
  }

  p_seg_sync_hdr->TransportPortSrc = (NET_PORT_NBR)src_port;
  p_seg_sync_hdr->TransportPortDest = (NET_PORT_NBR)dest_port;

  p_seg_sync_hdr->TCP_SegLenInit = (NET_TCP_SEG_SIZE)NET_TCP_SEG_LEN_SYNC;
  p_seg_sync_hdr->TCP_SegLen = (NET_TCP_SEG_SIZE)p_seg_sync_hdr->TCP_SegLenInit;
  p_seg_sync_hdr->TCP_SegLenLast = (NET_TCP_SEG_SIZE)p_seg_sync_hdr->TCP_SegLenInit;
  p_seg_sync_hdr->TCP_SegLenData = (NET_TCP_SEG_SIZE)0u;
  p_seg_sync_hdr->TCP_SegSync = (CPU_BOOLEAN)DEF_YES;
  p_seg_sync_hdr->TCP_SegClose = (CPU_BOOLEAN)DEF_NO;
  p_seg_sync_hdr->TCP_SegAck = (CPU_BOOLEAN)DEF_BIT_IS_SET(flags_tcp, NET_TCP_FLAG_TX_ACK);
  p_seg_sync_hdr->TCP_SegReset = (CPU_BOOLEAN)DEF_NO;

  p_seg_sync_hdr->TCP_SeqNbrInit = (NET_TCP_SEQ_NBR)seq_nbr;
  p_seg_sync_hdr->TCP_SeqNbrLast = (NET_TCP_SEQ_NBR)p_seg_sync_hdr->TCP_SeqNbrInit;
  p_seg_sync_hdr->TCP_SeqNbr = (NET_TCP_SEQ_NBR)p_seg_sync_hdr->TCP_SeqNbrInit;
  p_seg_sync_hdr->TCP_AckNbr = (NET_TCP_SEQ_NBR)ack_nbr;
  p_seg_sync_hdr->TCP_AckNbrLast = (NET_TCP_SEQ_NBR)p_seg_sync_hdr->TCP_AckNbr;

  p_seg_sync_hdr->TCP_WinSizeLast = (NET_TCP_WIN_SIZE)win_size;

  p_seg_sync_hdr->TCP_Flags = (NET_TCP_FLAGS)flags_tcp;

  p_seg_sync_hdr->TCP_SegReTxCtr = (NET_PKT_CTR)0u;
  p_seg_sync_hdr->RefCtr++;                                     // TCP maintains ref until seg ack'd (see Note #5a).

  //                                                               ----------------- UPDATE TCP CONN ------------------
  //                                                               Q conn sync seg to TCP re-tx Q.
  NetTCP_ConnFreeBufQ(&p_conn->ReTxQ_Head, &p_conn->ReTxQ_Tail);   // Free re-tx Q (see Note #6c).
  p_conn->ReTxQ_Head = p_seg_sync;
  p_conn->ReTxQ_Tail = p_seg_sync;
  //                                                               Update TCP conn seq nbrs (see Notes #2 & #3).
  p_conn->TxSeqNbrSync = (NET_TCP_SEQ_NBR) seq_nbr;
  p_conn->TxSeqNbrNext = (NET_TCP_SEQ_NBR)(seq_nbr + p_seg_sync_hdr->TCP_SegLen);
  p_conn->TxSeqNbrNextQ = (NET_TCP_SEQ_NBR) p_conn->TxSeqNbrNext;
  p_conn->TxSeqNbrUnAckdPrev = (NET_TCP_SEQ_NBR) p_conn->TxSeqNbrUnAckd;
  p_conn->TxSeqNbrUnAckd = (NET_TCP_SEQ_NBR) p_conn->TxSeqNbrSync;
  p_conn->TxSeqNbrUnReTxd = (NET_TCP_SEQ_NBR) p_conn->TxSeqNbrUnAckd;

  //                                                               --------------- TX TCP CONN SYNC SEG ---------------
  if (DEF_BIT_IS_CLR(p_seg_sync_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
    NetTCP_TxPktHandlerIPv4(p_seg_sync,
                            src_addrv4,
                            src_port,
                            dest_addrv4,
                            dest_port,
                            seq_nbr,
                            ack_nbr,
                            win_size,
                            TOS,
                            TTL,
                            flags_tcp,
                            flags_ipv4,
                            p_opt_cfg_max_seg_size,
                            DEF_NULL,                           // See Note #7.
                            p_err);
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    NetTCP_TxPktHandlerIPv6(p_seg_sync,
                            &src_addrv6,
                            src_port,
                            &dest_addrv6,
                            dest_port,
                            seq_nbr,
                            ack_nbr,
                            win_size,
                            traffic_class,
                            flow_label,
                            hop_lim,
                            flags_tcp,
                            p_opt_cfg_max_seg_size,
                            p_err);
#endif
  }

  switch (RTOS_ERR_CODE_GET(*p_err)) {
    case RTOS_ERR_NONE:
      NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnSyncCtr);
      break;

    case RTOS_ERR_NET_IF_LINK_DOWN:
      p_seg_sync_hdr->RefCtr--;
      NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnSyncCtr);
      goto exit_discard;

    default:
      p_seg_sync_hdr->RefCtr--;
      NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, NET_TCP_CONN_CLOSE_CONN_ALL);
      goto exit_discard;
  }

  NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnSyncCtr);

  goto exit;

exit_discard:
  NetTCP_TxPktDiscard(p_seg_sync);

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnClose()
 *
 * @brief    (1) Prepare & transmit a TCP connection close :
 *
 *           - (a) Validate TCP connection state
 *           - (b) Prepare  TCP connection close segment :
 *               - (1) Get  buffer
 *               - (2) Prepare TCP segment :
 *                   - (A) TCP segment  addresses
 *                   - (B) TCP segment  sequence numbers
 *                   - (C) TCP segment  transmit flags :
 *                       - (1) ACK
 *                       - (2) FIN
 *                   - (D) TCP segment  window size
 *                   - (E) IP  datagram parameters
 *                   - (F) TCP segment  packet buffer controls
 *           - (c) Update  TCP connection :
 *               - (1) Queue  TCP connection close packet
 *               - (2) Update TCP connection sequence number(s)
 *           - (d) Transmit   TCP connection close segment
 *
 *       - (2) A TCP connection's transmit sequences are closed when the closing TCP segment is queued
 *               for transmission :
 *
 *           - (a) 'TxSeqNbrClose' points to the closing (FIN) transmit sequence number.
 *
 *           - (b) 'TxSeqNbrLast'  points to the last sequence number used to close the TCP connection
 *                                       transmit sequences when acknowledged.
 *
 *                               -----          -----------------------
 *                               ^            |  Initial SEQ #(SYN) |
 *                               |            -----------------------
 *                               |            |    Data Octet #1    |
 *                               |            |    Data Octet #2    |
 *                               |            |    Data Octet #3    |
 *                                           |          .          |
 *                           TCP Connection     |          .          |
 *                       Transmit Sequences   |          .          |
 *                           (see Note #2)      | Data Octet #(N - 2) |
 *                                           | Data Octet #(N - 1) |
 *                               |            | Data Octet #   N    |        Closing Transmit
 *                               |            -----------------------        Sequence Number
 *                               |            |   Close SEQ #(FIN)  |  <---  (see Note #2a)
 *                               |            -----------------------
 *                               v            |    Last SEQ #       |  <---   Last Transmit
 *                               -----          -----------------------        Sequence Number
 *                                                                           (see Note #2b)
 *
 *               See also 'NetTCP_TxConnSync()  Note #3'.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @param    state   Current TCP connection state at time of connection close.
 *
 * @param    p_err   Pointer to variable that will receive the return error code from this functio.
 *
 * @note     (3) Network resources MUST be appropriately allocated/deallocated :
 *
 *                       - (a) Network buffer's reference counter MUST be incremented to include the queued TCP
 *                   connection close segment as a new reference to the network buffer.  However, this
 *                   additional reference is handled when the TCP connection close segment is enqueued
 *                   to the TCP connection's re-transmit queue (see 'NetTCP_TxConnTxQ()  Note #10').
 *
 *                       - (b) On ANY error(s), network resources MUST be appropriately freed :
 *
 *                       - (1) For any network resources NOT  yet       linked to the TCP connection, each
 *                   network resource  MUST be freed by appropriate function(s).
 *                       - (2) For all network resources that have been linked to the TCP connection, ALL
 *                   network resources are     freed by NetTCP_ConnClose().
 *******************************************************************************************************/
static void NetTCP_TxConnClose(NET_TCP_CONN       *p_conn,
                               NET_TCP_CONN_STATE state,
                               RTOS_ERR           *p_err)
{
  NET_TCP_SEG_SIZE seg_len;
  NET_BUF_SIZE     data_len;
  NET_BUF_SIZE     data_ix;
  NET_BUF_SIZE     data_ix_offset;
  NET_CONN_ID      conn_id;

  NET_IF_NBR  if_nbr;
  NET_BUF     *p_seg_close;
  NET_BUF_HDR *p_seg_close_hdr;
#ifdef  NET_IPv4_MODULE_EN
  NET_IPv4_ADDR src_addrv4;
  NET_IPv4_ADDR dest_addrv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
  NET_IPv6_ADDR  src_addrv6;
  NET_IPv6_ADDR  dest_addrv6;
  NET_IPv6_FLAGS ip_flags;
#endif
  NET_TCP_PORT_NBR  src_port;
  NET_TCP_PORT_NBR  dest_port;
  NET_TCP_SEQ_NBR   seq_nbr;
  NET_TCP_FLAGS     flags_tcp;
  CPU_BOOLEAN       flag_ipv6;
  NET_PROTOCOL_TYPE proto_type = NET_PROTOCOL_TYPE_TCP_V4;

  PP_UNUSED_PARAM(state);

  //                                                               ------------ PREPARE TCP CONN CLOSE SEG ------------
  seg_len = NET_TCP_SEG_LEN_CLOSE;
  data_len = NET_TCP_DATA_LEN_TX_CLOSE;

  if (p_conn->TxQ_Tail != DEF_NULL) {                           // If tx Q NOT empty ...
    p_seg_close = p_conn->TxQ_Tail;                             // ... update tx Q tail seg as close seg.
    p_seg_close_hdr = &p_seg_close->Hdr;

    p_seg_close_hdr->DataLen += (NET_BUF_SIZE)data_len;
    p_seg_close_hdr->TotLen += (NET_BUF_SIZE)data_len;

    p_seg_close_hdr->TCP_SegLenInit += (NET_TCP_SEG_SIZE)seg_len;
    p_seg_close_hdr->TCP_SegLen += (NET_TCP_SEG_SIZE)seg_len;
    p_seg_close_hdr->TCP_SegLenData += (NET_TCP_SEG_SIZE)data_len;

    DEF_BIT_SET(p_seg_close_hdr->TCP_Flags, NET_TCP_FLAG_TX_CLOSE);
  } else {                                                      // Else get/cfg close seg buf.
                                                                // Get buf.
    conn_id = p_conn->ID_Conn;
    if_nbr = NetConn_IF_NbrGet(conn_id);

    //                                                             Find conn IP family.
    flag_ipv6 = DEF_NO;

#ifdef  NET_IPv6_MODULE_EN
    NetConn_IPv6TxParamsGet(conn_id,
                            DEF_NULL,
                            DEF_NULL,
                            DEF_NULL,
                            &ip_flags);

    if (DEF_BIT_IS_CLR(ip_flags, NET_IPv6_FLAG)) {
      proto_type = NET_PROTOCOL_TYPE_TCP_V4;
    } else {
      flag_ipv6 = DEF_YES;
      proto_type = NET_PROTOCOL_TYPE_TCP_V6;
    }
#endif

    data_ix = 0u;
    NetTCP_GetTxDataIx(if_nbr,
                       proto_type,
                       0u,
                       data_len,
                       p_conn,
                       &data_ix);

    p_seg_close = NetBuf_Get(if_nbr,
                             NET_TRANSACTION_TX,
                             data_len,
                             data_ix,
                             &data_ix_offset,
                             NET_BUF_FLAG_NONE,
                             p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }

    data_ix += data_ix_offset;
    p_seg_close_hdr = (NET_BUF_HDR *)&p_seg_close->Hdr;
    //                                                             ----------------- PREPARE TCP HDR ------------------

    //                                                             Prepare seg addrs.
    if (flag_ipv6 == DEF_NO) {
#ifdef  NET_IPv4_MODULE_EN
      NetTCP_TxConnPrepareSegAddrs(p_conn,
                                   (CPU_INT08U *)&src_addrv4,
                                   (CPU_INT08U *)&src_port,
                                   sizeof(src_addrv4),
                                   sizeof(src_port),
                                   (CPU_INT08U *)&dest_addrv4,
                                   (CPU_INT08U *)&dest_port,
                                   sizeof(dest_addrv4),
                                   sizeof(dest_port),
                                   p_err);

      p_seg_close_hdr->IP_AddrSrc = (NET_IPv4_ADDR)src_addrv4;
      p_seg_close_hdr->IP_AddrDest = (NET_IPv4_ADDR)dest_addrv4;
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
      NetTCP_TxConnPrepareSegAddrs(p_conn,
                                   (CPU_INT08U *)&src_addrv6,
                                   (CPU_INT08U *)&src_port,
                                   sizeof(src_addrv6),
                                   sizeof(src_port),
                                   (CPU_INT08U *)&dest_addrv6,
                                   (CPU_INT08U *)&dest_port,
                                   sizeof(dest_addrv6),
                                   sizeof(dest_port),
                                   p_err);

#endif
    }
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {           // See Note #3b1.
      NetBuf_Free(p_seg_close);
      goto exit;
    }

    //                                                             Prepare TCP seq nbr(s).
    seq_nbr = p_conn->TxSeqNbrNextQ;

    //                                                             Prepare TCP tx flags (see Note #1b2C).
    flags_tcp = NET_TCP_FLAG_NONE
                | NET_TCP_FLAG_TX_ACK
                | NET_TCP_FLAG_TX_CLOSE;

    //                                                             Init buf ctrls.
    p_seg_close_hdr = &p_seg_close->Hdr;
    p_seg_close_hdr->DataIx = (CPU_INT16U)data_ix;
    p_seg_close_hdr->DataLen = (NET_BUF_SIZE)data_len;
    p_seg_close_hdr->TotLen = (NET_BUF_SIZE)p_seg_close_hdr->DataLen;
    p_seg_close_hdr->TransportPortSrc = (NET_PORT_NBR)src_port;
    p_seg_close_hdr->TransportPortDest = (NET_PORT_NBR)dest_port;

    if (flag_ipv6 == DEF_NO) {
#ifdef  NET_IPv4_MODULE_EN
      p_seg_close_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V4;
      p_seg_close_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V4;
      p_seg_close_hdr->IP_AddrSrc = (NET_IPv4_ADDR)src_addrv4;
      p_seg_close_hdr->IP_AddrDest = (NET_IPv4_ADDR)dest_addrv4;
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
      p_seg_close_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V6;
      p_seg_close_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V6;
      Mem_Copy(&p_seg_close_hdr->IPv6_AddrSrc, &src_addrv6, NET_IPv6_ADDR_SIZE);
      Mem_Copy(&p_seg_close_hdr->IPv6_AddrDest, &dest_addrv6, NET_IPv6_ADDR_SIZE);
#endif
    }

    p_seg_close_hdr->TCP_SegLenInit = seg_len;
    p_seg_close_hdr->TCP_SegLen = p_seg_close_hdr->TCP_SegLenInit;
    p_seg_close_hdr->TCP_SegLenData = (NET_TCP_SEG_SIZE)data_len;
    p_seg_close_hdr->TCP_SegSync = DEF_NO;
    p_seg_close_hdr->TCP_SegClose = DEF_YES;
    p_seg_close_hdr->TCP_SegAck = DEF_YES;
    p_seg_close_hdr->TCP_SegReset = DEF_NO;

    p_seg_close_hdr->TCP_SeqNbrInit = seq_nbr;
    p_seg_close_hdr->TCP_SeqNbr = p_seg_close_hdr->TCP_SeqNbrInit;

    p_seg_close_hdr->TCP_Flags = flags_tcp;
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  //                                                               Q conn close seg to TCP tx Q : ...
  if (p_conn->TxQ_Tail == DEF_NULL) {                           // ... if tx Q empty, add close seg to empty tx Q.
    p_conn->TxQ_Head = p_seg_close;
    p_conn->TxQ_Tail = p_seg_close;
  }

  //                                                               Update TCP conn seq nbrs (see Note #2).
  p_conn->TxSeqNbrNextQ += (NET_TCP_SEQ_NBR) seg_len;           // Update next tx Q seq nbr by close seg len.
  p_conn->TxSeqNbrLast = (NET_TCP_SEQ_NBR) p_conn->TxSeqNbrNextQ;
  p_conn->TxSeqNbrClose = (NET_TCP_SEQ_NBR)(p_conn->TxSeqNbrLast - seg_len);

  //                                                               -------------- TX TCP CONN CLOSE SEG ---------------
  NetTCP_TxConnTxQ(p_conn,
                   DEF_NULL,
                   NET_TCP_CONN_TX_ACK_NONE,
                   DEF_NO,
                   NET_TCP_CONN_CLOSE_ALL,
                   DEF_YES,
                   p_err);
  switch (RTOS_ERR_CODE_GET(*p_err)) {
    case RTOS_ERR_NONE:
    case RTOS_ERR_NET_IF_LINK_DOWN:                             // Ignore transitory tx err(s).
      break;

    //                                                             Conn will be close in NetTCP_TxConnTxQ() in case of
    //                                                             a TX error and buffers will be free.
    default:
      return;
  }

  NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnCloseCtr);

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnAck()
 *
 * @brief    (1) Prepare & transmit a TCP connection acknowledgment :
 *
 *           - (a) Validate TCP connection for TCP acknowledgment          See Notes #2, #4, #5, & #6
 *           - (b) Prepare  TCP acknowledgment segment :
 *               - (1) Get  buffer
 *               - (2) Prepare TCP segment :
 *                   - (A) TCP segment  addresses
 *                   - (B) TCP segment  sequence numbers                   See Notes #4a1D1a1, #4a2A1
 *                                                                                   & #4a1D3b1B,
 *                   - (C) TCP segment  transmit flags :
 *                       - (1) ACK
 *                   - (D) TCP segment  window size
 *                   - (E) IP  datagram parameters                         See Note #9
 *                   - (F) TCP segment  packet buffer controls
 *           - (c) Transmit TCP connection acknowledgment
 *
 *       - (2) NetTCP_TxConnAck() transmits TCP connection acknowledgments in response to certain
 *               received TCP packets or TCP connection events (see Note #4).  TCP acknowledgments
 *               transmitted with other TCP controls &/or data SHOULD NOT be transmitted with
 *               NetTCP_TxConnAck().
 *
 *               See also 'NetTCP_TxConnTxQ()  Note #2'.
 *
 * @param    p_conn          Pointer to a TCP connection.
 *
 * @param    p_buf_hdr       Pointer to network buffer header that received TCP packet.
 *
 * @param    tx_ack_code     Indicate whether & how to transmit a TCP acknowledgment segment :
 *                           NET_TCP_CONN_TX_ACK_NONE        Do NOT transmit a TCP acknowledgment segment.
 *                           NET_TCP_CONN_TX_ACK                    Transmit a TCP acknowledgment segment.
 *                           NET_TCP_CONN_TX_ACK_IMMED              Transmit a TCP acknowledgment segment
 *                           immediately (see Note #4a5).
 *                           NET_TCP_CONN_TX_ACK_FAULT              Transmit a TCP acknowledgment segment
 *                           immediately in response to an invalid
 *                           received TCP packet (see Note #4a1).
 *                           NET_TCP_CONN_TX_ACK_TIMEOUT            Transmit a TCP acknowledgment segment
 *                           immediately in response to a delayed
 *                           acknowledgment timeout (see Note #6).
 *
 * @param    close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
 *                           NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
 *                           NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
 *                           NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
 *                           NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
 *                           NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgment delay  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
 *                           NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
 *                           See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @note     (3) See the following RFC's for TCP acknowledgment generation summary :
 *
 *                               - (a) RFC # 793, Section  3.9 'Event Processing : SEGMENT ARRIVES'
 *                               - (b) RFC # 813, Section  5
 *                               - (c) RFC #1122, Section  4.2.3.2
 *                               - (d) RFC #2581, Sections 3.2 & 4.2
 *                               - (e) RFC Draft-IETF-TCPm-TCPSecure #00, Sections 2 & 3
 *
 * @note     (4) (a) TCP connection acknowledgments are transmitted when certain segments are received :
 *
 *                               - (A) Some TCP transmit acknowledgment validation logic implemented in previous
 *                           functions; include duplicate validation logic in NetTCP_TxConnAck() only
 *                           if debug/validation code is enabled.
 *
 *                               - (1) (A) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation : 1' states that
 *                           "if [a] connection does not exist (CLOSED) then a reset is sent in response to any
 *                           incoming segment except another reset".
 *
 *                           Thus ONLY resets are transmitted from the CLOSED state; never acknowledgments.
 *
 *                               - (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State]' allows
 *                           for the transmission of TCP connection reset & connection synchronization segments
 *                           ONLY; never acknowledgment-only segments (see also Note #2).
 *
 *                               - (C) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                           Check SYN Bit' states that "if ... our SYN has been ACKed ... change the
 *                           connection state to ESTABLISHED, form an ACK segment ... and send it".
 *
 *                           Thus acknowledgments MUST be immediately transmitted in reply to all valid
 *                           synchronization segments received.
 *
 *                               - (D) (1) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence
 *                           Number' states that for the "SYN-RECEIVED STATE, ESTABLISHED STATE, FIN-WAIT-1
 *                           STATE, FIN-WAIT-2 STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK STATE, TIME-
 *                           WAIT STATE ... if an incoming segment is not acceptable" :
 *
 *                               - (a) "An acknowledgment should be sent in reply" :
 *
 *                               - (1) <SEQ=SND.NXT> <ACK=RCV.NXT> <CTL=ACK>
 *
 *                               - (b) (1) "(unless the RST bit is set)".
 *
 *                               - (2) However, RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 requires
 *                           transmitting a TCP acknowledgment upon receipt of certain TCP
 *                           segments regardless of whether "the RST bit" is set (see Notes
 *                           #4a1D2b1c & #4a1D2b3).
 *
 *                           See also Notes #4a1D2b & #4a1D3b.
 *
 *                               - (2) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check RST Bit'
 *                           states that "if the RST bit is set ... enter the CLOSED state".
 *
 *                           Note this check is placed following the sequence check to prevent a segment
 *                           from an old connection ... from causing an abort of the current connection".
 *
 *                               - (b) (1) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 2.2 amends the "handling
 *                           of a segment with the RST bit when in a synchronized state" to "provide some
 *                           protection against ... blind reset attack[s] using the RST bit" :
 *
 *                               - (a) "If the RST bit is set and the sequence number is outside the
 *                           expected window, silently drop the segment."
 *
 *                               - (b) "If the RST bit is exactly the next expected sequence number [sic],
 *                           reset the connection"; it is assumed that this should read "if the
 *                           RST bit is set and the sequence number is exactly the next expected
 *                           sequence number, reset the connection."
 *
 *                               - (c) "If the RST bit is set and the sequence number does not exactly
 *                           match the next expected sequence value, yet is within the
 *                           acceptable window (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) send
 *                           an acknowledgment."
 *
 *                               - (2) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that this
 *                           amendment applies only to the "handling of a ... RST when in a synchronized
 *                           state", it is assumed that this should also apply to the SYN-RECEIVED state.
 *
 *                               - (3) In addition, RFC Draft-IETF-TCPm-TCPSecure #00 does NOT provide a
 *                           precedence priority for handling TCP segments received with BOTH the RST
 *                           & SYN bits set.
 *
 *                           Therefore, since it does NOT seem reasonable to reset a TCP connection
 *                           due to a TCP segment that also attempted to synchronize the  TCP connection,
 *                           it is assumed that the amended handling of the SYN bit should take precedence
 *                           over the amended handling of the RST bit.
 *
 *                           See also Note #4a1D3b.
 *
 *                               - (3) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN
 *                           Bit' states that for "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT
 *                           STATE-1, FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK
 *                           STATE, TIME-WAIT STATE ... [to next] check the SYN bit ... [and] if
 *                           the SYN is in the window it is an error, send a reset ... [and] enter
 *                           the CLOSED state ...
 *
 *                           [But] if the SYN is not in the window this step would not have been
 *                           reached and an ack would have been sent".
 *
 *                               - (b) (1) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the
 *                           "handling of a segment with the SYN bit set in the synchronized state
 *                           ... [by] handling ... the SYN bit" as follows :
 *
 *                               - (a) "If the SYN bit is set and the sequence number is outside the
 *                           expected window, send an ACK back to the peer."
 *
 *                               - (b) "If the SYN bit is set and the sequence number is an exact match to
 *                           the next expected sequence (RCV.NXT == SEG.SEQ) then send an ACK
 *                           segment ... but ... subtract one from value being acknowledged."
 *
 *                               - (c) "If the SYN bit is set and the sequence number is acceptable, i.e.:
 *                           (RCV.NXT <= SEG.SEQ < RCV.NXT+RCV.WND) then send an ACK segment."
 *
 *                               - (2) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that
 *                           this amendment applies only to the "handling of a ... SYN ... in a
 *                           synchronized state", it is assumed that this should also apply to the
 *                           SYN-RECEIVED state.
 *
 *                               - (4) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
 *                           states that if in the "ESTABLISHED STATE" or any state with similar "processing
 *                           as for the ESTABLISHED STATE", that "if the ACK acks something not yet sent
 *                           (SEG.ACK > SND.NXT) then send an ACK".
 *
 *                               - (2) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Process Segment Text',
 *                           states that in the "ESTABLISHED STATE, FIN-WAIT-1 STATE, FIN-WAIT-2 STATE ... when
 *                           ... TCP takes responsibility for ... data ... it must also acknowledge ... the data" :
 *
 *                               - (A) "Send an acknowledgment of the form" :
 *
 *                               - (1) <SEQ=SND.NXT> <ACK=RCV.NXT> <CTL=ACK>
 *
 *                               - (B) "This acknowledgment should be piggybacked on a segment being transmitted if
 *                           possible without incurring undue delay."
 *
 *                           See also Note #6.
 *
 *                               - (3) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check FIN Bit' states
 *                           that "if the FIN bit is set, ... send an acknowledgment for the FIN".
 *
 *                               - (4) RFC #813, Section 5 states that "the receiver of data will refrain from sending an
 *                           acknowledgment under certain circumstances ... The most obvious event on which to
 *                           depend is the arrival of another segment.  So, if a segment arrives, postpone sending
 *                           an acknowledgment if ... the following conditions hold" :
 *
 *                               - (A) "The push bit is not set in the segment, since it is a reasonable assumption
 *                           that there is more data coming in a subsequent segment."
 *
 *                               - (1) However, if the PUSH bit is set in any received segment, an acknowledgment
 *                           should be immediately transmitted.
 *
 *                           See also Notes #4b1, #5b2, & #6.
 *
 *                               - (5) (A) RFC #2581, Section 3.2 states that "a TCP receiver SHOULD send an immediate ACK" :
 *
 *                               - (1) "When an out-of-order segment arrives.  The purpose of this ACK is to
 *                           inform the sender that a segment was received out-of-order and which
 *                           sequence number is expected."
 *
 *                               - (2) "In addition, ... when the incoming segment fills in all or part of a
 *                           gap in the sequence space.  This will generate more timely information
 *                           for a sender recovering from a ... retransmission timeout ... [or] a
 *                           fast retransmit."
 *
 *                               - (B) RFC #1122, Section 4.2.2.21 reiterates that "a TCP MAY send an ACK segment
 *                           acknowledging RCV.NXT when a valid segment arrives that is in the window
 *                           but not at the left window edge ... One reason for ACKing out-of-order
 *                           segments [is] to support ... 'fast retransmit'".
 *
 *                               - (b) TCP connection acknowledgments are transmitted for certain TCP connection events :
 *
 *                               - (1) RFC #813, Section 5 states that "the receiver of data will refrain from sending an
 *                           acknowledgment under certain circumstances ... Postpone sending an acknowledgment
 *                           if ... the following conditions hold" :
 *
 *                               - (B) "There is no revised window information to be sent back."
 *
 *                               - (1) However, if any local receive window size is available to update to the
 *                           remote host, an acknowledgment should be immediately transmitted.
 *
 *                           See also Note #4a4 & 'NetTCP_RxConnWinSizeHandler()  Note #4'.
 *
 * @note     (5) (a) Although NO RFC specifies whether an acknowledgment should or should NOT
 *                           be transmitted in response to a received acknowledgment-only segment, it
 *                           seems reasonable & is assumed that NO TCP connection acknowledgment should
 *                           be transmitted in response to any acknowledgment-only segment(s) received.
 *
 *                               - (1) A received TCP segment is considered an acknowledgment-only segment if
 *                           the segment was received with zero segment length, i.e. NO received TCP
 *                           sequences :
 *
 *                               - (A) NO synchronization or close controls)
 *                               - (B) NO TCP data
 *
 *                               - (b) (1) However, since acknowledgments are transmitted in response to various
 *                           invalid segments received, some acknowledgments MUST be transmitted
 *                           even for certain invalid acknowledgment-only segments.
 *
 *                           See also Note #4a1.
 *
 *                               - (2) Also, acknowledgments SHOULD be transmitted for received segments with
 *                           the PUSH bit set, even for segments with NO received TCP data.
 *
 *                           See also Note #4a4.
 *
 *                               - (3) (A) Also, RFC #1122, Section 4.2.2.17 states that the "probing of zero
 *                           (offered) windows MUST be supported.  A TCP MAY keep its offered
 *                           receive window closed indefinitely.  As long as the receiving TCP
 *                           continues to send acknowledgments in response to the probe segments".
 *
 *                               - (B) In order to always acknowledge a remote host's probing of the local
 *                           TCP connection's receive window size :
 *
 *                               - (1) Since probe segments :
 *
 *                               - (a) may or may NOT contain data, ...
 *                               - (b) sequence values may or may NOT be within the TCP connection's
 *                           current receive window;  ...
 *
 *                           See also Note #4a1D1a1 & 'NetTCP_RxPktConnIsValidSeq()  Note #1d3'.
 *
 *                               - (2) ... acknowledgments SHOULD be transmitted in reply to ALL valid
 *                           & SOME invalid received segments from the remote host whenever
 *                           the TCP connection's local receive window is zero-sized.
 *
 * @note     (6) (a) The following sections state that "a TCP SHOULD implement a delayed ACK" :
 *
 *                               - (A) RFC # 813, Section 5
 *                               - (B) RFC #1122, Section 4.2.3.2
 *                               - (C) RFC #2581, Section 4.2
 *
 *                               - (1) (A) (1) RFC #1122, Section 4.2.3.2 states that "in a stream of full-sized segments
 *                           there SHOULD be an ACK for at least every second segment".
 *
 *                               - (2) RFC #2581, Section 4.2 reiterates that "an ACK SHOULD be generated for at
 *                           least every second full-sized segment".
 *
 *                               - (B) However, RFC #2581, Section 4.2 states that "an implementation is deemed to
 *                           comply with this requirement ... by acknowledging at least every second segment,
 *                           regardless of size".
 *
 *                               - (2) (A) RFC #813, Section 5 states that "the receiver of data will refrain from
 *                           sending an acknowledgement under certain circumstances, in which case it
 *                           must set a timer which will cause the acknowledgement to be sent later".
 *
 *                               - (B) (1) (a) RFC #1122, Section 4.2.3.2 states that "an ACK should not
 *                           be excessively delayed; in particular, the delay MUST be
 *                           less than 0.5 seconds".
 *
 *                               - (b) RFC #2581, Section 4.2 reiterates that "an ACK ... MUST
 *                           be generated within 500 ms of the arrival of the first
 *                           unacknowledged packet".
 *
 *                               - (2) However, Stevens, TCP/IP Illustrated, Volume 1, 8th Printing,
 *                           Section 19.3, Page 265 states that "most implementations use
 *                           a 200-ms delay".
 *
 *                               - (b) However, if NO network timer is available to delay the acknowledgment, the TCP
 *                           connection acknowledgment SHOULD be immediately transmitted.
 *
 * @note     (7) (a) (1) RFC #1122, Section 4.2.2.14 states that "a careless implementation can send
 *                           two or more acknowledgment segments per data segment received".
 *
 *                               - (2) RFC #1122, Section 4.2.2.20 states that "in general, the processing of
 *                           received segments MUST be implemented to aggregate ACK segments whenever
 *                           possible.  For example, if the TCP is processing a series of queued
 *                           segments, it MUST process them all before sending any ACK segments".
 *
 *                               - (3) Thus no more than one acknowledgment SHOULD be transmitted in response
 *                           to any received segment.
 *
 *                               - (b) RFC #1122, Section 4.2.2.14 also states that "when the application program
 *                           subsequently consumes the data and increases the available receive buffer
 *                           space again, the receiver may send a second acknowledgment segment to update
 *                           the window at the sender".
 *
 *                           However, the application layer receives data from a TCP connection's application
 *                           receive queue asynchronously & irrespective of distinct or specific TCP packets
 *                           (see 'NetTCP_RxAppData()  Note #4a').  Thus any acknowledgment transmissions
 *                           triggered during asynchronous application receives CANNOT be associated with, &
 *                           thereby limited by, any specific received segments.
 *
 * @note     (8) (a) (1) (A) RFC #793, Sections 3.7 & 2.6 state that "TCP uses retransmission ... to
 *                           ensure delivery of every segment".
 *
 *                               - (B) However, RFC #1122, Section 4.2.2.17 'DISCUSSION' states that "it is
 *                           extremely important to remember that ACK (acknowledgment) segments that
 *                           contain no data are not reliably transmitted by TCP".
 *
 *                               - (2) Therefore, it is assumed that TCP acknowledgment-ONLY segments should NOT be
 *                           queued for retransmission but SHOULD be silently discarded.
 *
 *                               - (b) (1) The network buffer's reference counter is NOT incremented since the TCP layer
 *                           does NOT maintain a reference to any transmitted TCP acknowledgment segments.
 *
 *                               - (2) Therefore, the network buffer MUST be freed by lower layer(s).
 *
 *                           See also 'NetTCP_TxConnReset()  Note #7',
 *                           & 'NetTCP_TxConnProbe()  Note #3'.
 *
 * @note     (9) (a) RFC #1122, Section 4.2.4.2 states that "the [IP] TOS will be specified independently
 *                           in each direction on the connection, so that the receiver application will specify
 *                           the TOS used for ACK segments." #### NET-807
 *
 *                               - (b) (1) IP  transmit options currently NOT implemented     See 'net_tcp.c  Note #1d'
 *                               - (2) TCP transmit options currently NOT implemented     See 'net_tcp.c  Note #1c'
 *
 *                           See also 'NetTCP_TxPktHandler()  Note #2'.
 *
 *                           10) On ANY error(s), network resources MUST be appropriately freed :
 *
 *                               - (a) For any network resources NOT linked to the TCP connection, each network resource
 *                           MUST be freed by appropriate function(s).
 *******************************************************************************************************/
static NET_TCP_ACK_STATUS NetTCP_TxConnAck(NET_TCP_CONN       *p_conn,
                                           NET_BUF_HDR        *p_buf_hdr,
                                           NET_TCP_ACK_CODE   tx_ack_code,
                                           NET_TCP_CLOSE_CODE close_code,
                                           RTOS_ERR           *p_err)
{
#ifdef  NET_IPv4_MODULE_EN
  NET_IPv4_ADDR  src_addrv4;
  NET_IPv4_ADDR  dest_addrv4;
  NET_IPv4_TOS   TOS;
  NET_IPv4_TTL   TTL;
  NET_IPv4_FLAGS flags_ipv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
  NET_IPv6_ADDR          src_addrv6;
  NET_IPv6_ADDR          dest_addrv6;
  NET_IPv6_TRAFFIC_CLASS traffic_class;
  NET_IPv6_FLOW_LABEL    flow_label;
  NET_IPv6_HOP_LIM       hop_lim;
  NET_IPv4_FLAGS         flags_ipv6;
#endif
  CPU_BOOLEAN        tx_ack;
  CPU_BOOLEAN        tmr_free;
  CPU_BOOLEAN        push_avail;
  CPU_INT32U         timeout_ms;
  NET_BUF_SIZE       data_len;
  NET_BUF_SIZE       data_ix;
  NET_BUF_SIZE       data_ix_offset;
  NET_CONN_ID        conn_id;
  NET_IF_NBR         if_nbr;
  NET_BUF            *p_seg_ack;
  NET_BUF_HDR        *p_seg_ack_hdr;
  NET_TCP_PORT_NBR   src_port;
  NET_TCP_PORT_NBR   dest_port;
  NET_TCP_SEQ_NBR    seq_nbr;
  NET_TCP_SEQ_NBR    ack_nbr;
  NET_TCP_SEQ_NBR    ack_nbr_delta;
  NET_TCP_WIN_SIZE   win_size;
  NET_TCP_FLAGS      flags_tcp;
  NET_PROTOCOL_TYPE  proto_type = NET_PROTOCOL_TYPE_NONE;
  NET_CONN           *p_conn_conn;
  CPU_BOOLEAN        is_ipv6;
  NET_TCP_ACK_STATUS ack_status = NET_TCP_ACK_STATUS_INVALID;

  PP_UNUSED_PARAM(close_code);

  //                                                               ------------- VALIDATE TCP CONN TX ACK -------------
  tx_ack = DEF_NO;
  tmr_free = DEF_YES;
  ack_nbr_delta = 0u;
  is_ipv6 = DEF_NO;

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_CLOSED:                             // See Note #4a1A.
    case NET_TCP_CONN_STATE_LISTEN:                             // See Note #4a1B.
      break;

    case NET_TCP_CONN_STATE_SYNC_TXD:                           // See Note #4a1C.
      if (p_buf_hdr != DEF_NULL) {
        tx_ack = DEF_YES;
        if (p_buf_hdr->TCP_SegAckTxd != DEF_NO) {               // If prev'ly tx'd TCP conn ack for rx'd seg, ..
          ack_status = NET_TCP_ACK_STATUS_PREV_TXD;             // .. do NOT re-tx TCP conn ack (see Note #7a3).
          goto exit;
        }
      } else {
        tx_ack = DEF_YES;
      }
      break;

    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      if (p_buf_hdr != DEF_NULL) {
        if (p_buf_hdr->TCP_SegAckTxd != DEF_NO) {               // If prev'ly tx'd TCP conn ack for rx'd seg, ..
          ack_status = NET_TCP_ACK_STATUS_PREV_TXD;             // .. do NOT re-tx TCP conn ack (see Note #7a3).
          goto exit;
        }
      }

      switch (tx_ack_code) {
        case NET_TCP_CONN_TX_ACK_NONE:
          ack_status = NET_TCP_ACK_STATUS_NONE;
          goto exit;

        case NET_TCP_CONN_TX_ACK:
        case NET_TCP_CONN_TX_ACK_IMMED:
          if (p_buf_hdr != DEF_NULL) {
            push_avail = DEF_BIT_IS_SET(p_buf_hdr->TCP_HdrLen_Flags, NET_TCP_HDR_FLAG_PUSH);
            if (push_avail == DEF_YES) {                        // If rx'd seg push'd & en'd, ..
              if (p_conn->TxAckImmedRxdPushEn != DEF_DISABLED) {
                tx_ack = DEF_YES;                               // .. tx TCP conn ack (see Note #4a4A1).
                break;
              }
            }

            if (p_buf_hdr->TCP_SegLen < 1) {                    // If ack-ONLY seg       (see Note #5a1);   ..
              if (p_conn->RxWinSizeActual > 0) {                // .. & local rx win > 0,                   ..
                ack_status = NET_TCP_ACK_STATUS_INVALID;
                goto exit;                                      // .. do NOT tx ack      (see Note #5a);    ..
              } else {                                          // .. & local rx win = 0 (see Note #5b3B2), ..
                tx_ack = DEF_YES;                               // .. tx TCP conn ack.
                break;
              }
            }
          }

          if (tx_ack_code == NET_TCP_CONN_TX_ACK_IMMED) {             // If immed ack req'd, ...
            tx_ack = DEF_YES;                                   // ... tx TCP conn ack.
            break;
          }

          if (p_conn->TxAckDlyTimeout_ms == 0) {                // If ack dly timeout zero, ...
            tx_ack = DEF_YES;                                   // ... tx TCP conn ack.
            break;
          }

          p_conn->TxAckDlyCnt++;                                // If ack dly cnt >= th, ...
          if (p_conn->TxAckDlyCnt >= NET_TCP_ACK_DLY_CNT_TH) {
            tx_ack = DEF_YES;                                   // ... tx TCP conn ack (see Note #6a1B).
            break;
          }

          if (p_conn->TxAckDlyTmr != DEF_NULL) {                // If ack dly tmr prev'ly started, ...
            ack_status = NET_TCP_ACK_STATUS_DLYD;               // ... continue ack dly (see Note #6a2A).
            goto exit;
          }

          timeout_ms = p_conn->TxAckDlyTimeout_ms;
          p_conn->TxAckDlyTmr = NetTmr_Get(NetTCP_TxConnAckDlyTimeout,
                                           p_conn,
                                           timeout_ms,
                                           NET_TMR_OPT_NONE,
                                           p_err);
          if (RTOS_ERR_CODE_GET(*p_err) == RTOS_ERR_NONE) {             // If ack dly tmr avail, ...
            ack_status = NET_TCP_ACK_STATUS_DLYD;               // ... start ack dly (see Note #6a2A).
            goto exit;
          } else {                                              // Else tx TCP conn ack (see Note #6b).
            tx_ack = DEF_YES;
          }
          break;

        case NET_TCP_CONN_TX_ACK_FAULT:                         // See Note #4a1D.
          if (p_buf_hdr != DEF_NULL) {
            if (p_buf_hdr->TCP_SegSync == DEF_YES) {               // If sync rx'd (see Note #4a1D3b1), ...
              tx_ack = DEF_YES;                                 // ... tx TCP conn ack; ignore possible reset.
                                                                // If rx'd sync equal to next rx seq nbr, ...
              if (p_buf_hdr->TCP_SeqNbr == p_conn->RxSeqNbrNext) {
                ack_nbr_delta = 1u;                             // ... sub 1 from ack (see Note #4a1D3b1B).
              }
            } else {
              tx_ack = DEF_YES;
            }
          } else {
            tx_ack = DEF_YES;
          }
          break;

        case NET_TCP_CONN_TX_ACK_OTW:                           // See Note #4a1D.
          if (p_buf_hdr != DEF_NULL) {
            if (p_buf_hdr->TCP_SegSync == DEF_YES) {               // If sync rx'd (see Note #4a1D3b1), ...
              tx_ack = DEF_YES;                                 // ... tx TCP conn ack; ignore possible reset.
                                                                // If rx'd sync equal to next rx seq nbr, ...
              if (p_buf_hdr->TCP_SeqNbr == p_conn->RxSeqNbrNext) {
                ack_nbr_delta = 1u;                             // ... sub 1 from ack (see Note #4a1D3b1B).
              }
            } else {
              tx_ack = DEF_YES;
            }
          } else {
            tx_ack = DEF_YES;
          }
          break;

        case NET_TCP_CONN_TX_ACK_TIMEOUT:
          tx_ack = DEF_YES;
          tmr_free = DEF_NO;
          break;

        default:
          break;
      }
      break;

    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE, NET_TCP_ACK_STATUS_INVALID);
  }

  if (tx_ack != DEF_YES) {                                      // If NOT valid, abort tx TCP conn ack.
    ack_status = NET_TCP_ACK_STATUS_INVALID;
    goto exit;
  }

  NetTCP_TxConnAckDlyReset(p_conn, tmr_free);                   // Reset ack dly ctrls.

  if (p_buf_hdr != DEF_NULL) {
    p_buf_hdr->TCP_SegAckTxd = DEF_YES;                         // Set ack tx'd for rx'd seg (see Note #7a).
  }

  //                                                               ------------- PREPARE TCP CONN ACK SEG -------------
  //                                                               If valid, prepare & tx TCP conn ack.
  //                                                               Get buf.
  conn_id = p_conn->ID_Conn;
  if_nbr = NetConn_IF_NbrGet(conn_id);

  data_len = NET_TCP_DATA_LEN_TX_ACK;
#if 0
  data_ix = NET_BUF_DATA_IX_TX;
#else
  if (p_buf_hdr == DEF_NULL) {
    p_conn_conn = &NetConn_Tbl[p_conn->ID_Conn];

    switch (p_conn_conn->Family) {
      case NET_CONN_FAMILY_IP_V4_SOCK:
        proto_type = NET_PROTOCOL_TYPE_TCP_V4;
        is_ipv6 = DEF_NO;
        break;

      case NET_CONN_FAMILY_IP_V6_SOCK:
        proto_type = NET_PROTOCOL_TYPE_TCP_V6;
        is_ipv6 = DEF_YES;
        break;

      default:
        RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_ASSERT_CRITICAL_FAIL, NET_TCP_ACK_STATUS_INVALID);
    }
  } else {
    if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
      proto_type = NET_PROTOCOL_TYPE_TCP_V4;
      is_ipv6 = DEF_NO;
    } else {
      proto_type = NET_PROTOCOL_TYPE_TCP_V6;
      is_ipv6 = DEF_YES;
    }
  }

  data_ix = 0u;

  NetTCP_GetTxDataIx(if_nbr,
                     proto_type,
                     0u,
                     data_len,
                     p_conn,
                     &data_ix);
#endif
  p_seg_ack = NetBuf_Get(if_nbr,
                         NET_TRANSACTION_TX,
                         data_len,
                         data_ix,
                         &data_ix_offset,
                         NET_BUF_FLAG_NONE,
                         p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit;
  }

  data_ix += data_ix_offset;

  //                                                               ----------------- PREPARE TCP HDR ------------------
  //                                                               Prepare seg addrs.
  if (p_buf_hdr != DEF_NULL) {                                  // If TCP pkt rx'd, cfg TCP tx                ...
                                                                // ...  src  addr from rx'd TCP pkt dest addr ...
    if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
      src_addrv4 = p_buf_hdr->IP_AddrDest;
      dest_addrv4 = p_buf_hdr->IP_AddrSrc;
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
      src_addrv6 = p_buf_hdr->IPv6_AddrDest;
      dest_addrv6 = p_buf_hdr->IPv6_AddrSrc;
#endif
    }

    src_port = p_buf_hdr->TransportPortDest;
    //                                                             .. & dest addr from rx'd TCP pkt src  addr.
    dest_port = p_buf_hdr->TransportPortSrc;
  } else {                                                      // Else cfg TCP tx pkt addrs from TCP conn addrs.
    if (is_ipv6 == DEF_NO) {
#ifdef  NET_IPv4_MODULE_EN
      NetTCP_TxConnPrepareSegAddrs(p_conn,
                                   (CPU_INT08U *)&src_addrv4,
                                   (CPU_INT08U *)&src_port,
                                   sizeof(src_addrv4),
                                   sizeof(src_port),
                                   (CPU_INT08U *)&dest_addrv4,
                                   (CPU_INT08U *)&dest_port,
                                   sizeof(dest_addrv4),
                                   sizeof(dest_port),
                                   p_err);
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
      NetTCP_TxConnPrepareSegAddrs(p_conn,
                                   (CPU_INT08U *)&src_addrv6,
                                   (CPU_INT08U *)&src_port,
                                   sizeof(src_addrv6),
                                   sizeof(src_port),
                                   (CPU_INT08U *)&dest_addrv6,
                                   (CPU_INT08U *)&dest_port,
                                   sizeof(dest_addrv6),
                                   sizeof(dest_port),
                                   p_err);
#endif
    }

    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {           // See Note #10a.
      goto exit_discard;
    }
  }

  //                                                               Prepare TCP seq nbrs (see Note #1b2B).
  seq_nbr = p_conn->TxSeqNbrNext;
  ack_nbr = p_conn->RxSeqNbrNext - ack_nbr_delta;

  //                                                               Prepare TCP tx flags (see Note #1b2C).
  flags_tcp = NET_TCP_FLAG_NONE
              | NET_TCP_FLAG_TX_ACK;

  //                                                               Prepare TCP win size.
  win_size = p_conn->RxWinSizeActual;

  //                                                               Prepare IP params (see Note #9).
  if (is_ipv6 == DEF_NO) {
#ifdef  NET_IPv4_MODULE_EN
    NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL);
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6);
#endif
  }

  //                                                               Init buf ctrls.
  p_seg_ack_hdr = &p_seg_ack->Hdr;
  p_seg_ack_hdr->DataIx = data_ix;
  p_seg_ack_hdr->DataLen = data_len;
  p_seg_ack_hdr->TotLen = p_seg_ack_hdr->DataLen;

  p_seg_ack_hdr->TCP_SegSync = DEF_NO;
  p_seg_ack_hdr->TCP_SegClose = DEF_NO;
  p_seg_ack_hdr->TCP_SegAck = DEF_YES;
  p_seg_ack_hdr->TCP_SegReset = DEF_NO;

  p_seg_ack_hdr->TCP_Flags = (NET_TCP_FLAGS)flags_tcp;

  //                                                               --------------- TX TCP CONN ACK SEG ----------------
  if (is_ipv6 == DEF_NO) {
#ifdef  NET_IPv4_MODULE_EN
    p_seg_ack_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V4;
    p_seg_ack_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V4;

    NetTCP_TxPktHandlerIPv4(p_seg_ack,
                            src_addrv4,
                            src_port,
                            dest_addrv4,
                            dest_port,
                            seq_nbr,
                            ack_nbr,
                            win_size,
                            TOS,
                            TTL,
                            flags_tcp,
                            flags_ipv4,
                            DEF_NULL,                           // See Note #9b2.
                            DEF_NULL,                           // See Note #9b1.
                            p_err);                             // Ignore transitory tx err(s).
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit_discard;
    }
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    DEF_BIT_SET(p_seg_ack_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);

    p_seg_ack_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V6;
    p_seg_ack_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V6;

    NetTCP_TxPktHandlerIPv6(p_seg_ack,
                            (NET_IPv6_ADDR *)&src_addrv6,
                            src_port,
                            (NET_IPv6_ADDR *)&dest_addrv6,
                            dest_port,
                            seq_nbr,
                            ack_nbr,
                            win_size,
                            traffic_class,
                            flow_label,
                            hop_lim,
                            flags_tcp,
                            DEF_NULL,
                            p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit_discard;
    }

#endif
  }

  NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnAckCtr);

  ack_status = NET_TCP_ACK_STATUS_VALID;

  goto exit;

exit_discard:
  NetTCP_TxPktDiscard(p_seg_ack);

exit:
  return (ack_status);
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnAckDlyReset()
 *
 * @brief    Reset TCP connection's delayed acknowledgement controls.
 *
 * @param    p_conn      Pointer to TCP connection to reset delayed acknowledgement controls.
 *
 * @param    tmr_free    Indicate whether to free network timer :
 *                       DEF_YES                Free network timer for delayed acknowledgement.
 *                       DEF_NO          Do NOT free network timer for delayed acknowledgement
 *                       [Freed by  NetTmr_Handler()
 *                       via NetTCP_TxConnAckDlyTimeout()].
 *
 * @note     (1) A TCP connection's delayed acknowledgement controls SHOULD be reset whenever :
 *
 *                           - (a) TCP data segment(s) are    transmitted
 *                           - (b) TCP data segment(s) are re-transmitted
 *
 *                       ... since any transmitted or re-transmitted data segment(s) always transmit an
 *                       accompanying acknowledgement.
 *******************************************************************************************************/
static void NetTCP_TxConnAckDlyReset(NET_TCP_CONN *p_conn,
                                     CPU_BOOLEAN  tmr_free)
{
  p_conn->TxAckDlyCnt = 0u;                                     // Reset ack dly cnts ...
  if (p_conn->TxAckDlyTmr != DEF_NULL) {                        // ... & free/clr ack dly tmr.
    if (tmr_free == DEF_YES) {
      NetTmr_Free(p_conn->TxAckDlyTmr);
    }
    p_conn->TxAckDlyTmr = DEF_NULL;
  }
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnAckDlyTimeout()
 *
 * @brief    (1) Handle TCP connection's delayed acknowledgment transmit for the following connected
 *               states :
 *
 *           - (a) SYN-RECEIVED
 *           - (b) ESTABLISHED
 *           - (c) FIN-WAIT-1
 *           - (d) FIN-WAIT-2
 *           - (e) CLOSING
 *           - (f) TIME-WAIT
 *           - (g) CLOSE-WAIT
 *           - (h) LAST-ACK
 *
 *
 * Argument(s) : p_conn_timeout       Pointer to TCP connection to transmit delayed acknowledgment (see Note #2b).
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
 *                   type functions -- even though network timer API functions cast callback functions
 *                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
 *
 *                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
 *                           to an object ... may be converted to a pointer to a different object ...
 *                           [but] if the resulting pointer is not correctly aligned ... the behavior
 *                           is undefined".
 *
 *                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
 *                           pointer arguments, network timer callback functions MUST avoid incorrect
 *                           pointer conversion behavior between 'void' pointer parameters & non-'void'
 *                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
 *
 *                               - (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
 *                           to or from a pointer to any ... object ... A pointer to any ... object ...
 *                           may be converted to a pointer to void and back again; the result shall
 *                           compare equal to the original pointer".
 *
 *                               - (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
 *                           network object pointer objects, network timer callback functions MUST :
 *
 *                               - (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
 *                               - (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
 *                               - (A) in this case, a 'NET_TCP_CONN' pointer.
 *
 *                           See also 'net_tmr.c  NetTmr_Get()  Note #3'.
 *
 * @note     (3) This function is a network timer callback function :
 *
 *                               - (a) (1) For the following connection timer(s) ... :
 *
 *                               - (A) TCP connection transmit acknowledgment delay timer ('TxAckDlyTmr')
 *
 *                               - (2) (A) Clear the timer pointer ... :
 *                               - (1) Cleared prior to next handler function(s); ...
 *                               - (2) Cleared prior to invalid state fault exit.
 *
 *                               - (B) but do NOT re-free the timer.
 *
 *                               - (b) Do NOT set the following close timer flag(s) :
 *
 *                               - (1) NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY
 *******************************************************************************************************/
static void NetTCP_TxConnAckDlyTimeout(void *p_conn_timeout)
{
  NET_TCP_CONN       *p_conn;
  NET_TCP_CLOSE_CODE close_code;
  RTOS_ERR           local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  p_conn = (NET_TCP_CONN *)p_conn_timeout;                      // See Note #2b2A.

  close_code = NET_TCP_CONN_CLOSE_ALL;
  //                                                               See Note #3b1.
  DEF_BIT_CLR(close_code, (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY);
  //                                                               ---------- HANDLE TCP CONN TX ACK TIMEOUT ----------
  p_conn->TxAckDlyTmr = DEF_NULL;                               // Clr tx ack dly tmr (see Note #3a2A1).

  (void)NetTCP_TxConnAck(p_conn,
                         DEF_NULL,
                         NET_TCP_CONN_TX_ACK_TIMEOUT,
                         close_code,
                         &local_err);                           // Ignore transitory tx err(s).
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnReset()
 *
 * @brief    (1) Prepare & transmit a TCP connection reset :
 *
 *           - (a) Validate received TCP packet  for TCP reset                     See Note #5
 *           - (b) Validate TCP connection state for TCP reset                     See Note #4
 *           - (c) Prepare  TCP reset segment :
 *               - (1) Get  buffer
 *               - (2) Prepare TCP segment :
 *                   - (A) TCP segment addresses
 *                   - (B) TCP segment sequence numbers                            See Note #6
 *                   - (C) TCP segment transmit flags :
 *                       - (1) RESET
 *                       - (2) ACK                                                 See Note #6a2A
 *                   - (D) TCP segment window size
 *                   - (E) TCP segment packet buffer controls
 *           - (d) Transmit TCP connection reset
 *
 * @param    p_conn          Pointer to a TCP connection.
 *
 * @param    p_buf_hdr       Pointer to network buffer header that received TCP packet, if available.
 *
 * @param    tx_reset_code   Indicate whether & how to transmit a TCP reset segment :
 *                           NET_TCP_CONN_TX_RESET           Transmit a TCP reset segment, if permitted
 *                           (see Notes #4 & #5).
 *                           NET_TCP_CONN_TX_RESET_FAULT     Transmit a TCP reset segment immediately for
 *                           a closing TCP connection fault.
 *
 * @param    close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
 *                           NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
 *                           NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
 *                           NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
 *                           NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
 *                           NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
 *                           NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
 *                           NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
 *                           See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this functio.
 *
 * @note     (2) The following TCP header fields MUST be decoded &/or converted from network-order to host-
 *                           order BEFORE any TCP Reset Segments are transmitted (see 'NetTCP_RxPktValidate()  Note #3') :
 *
 *                               - (a) Sequence        Number
 *                               - (b) Acknowledgement Number
 *                               - (c) Segment Length
 *
 * @note     (3) See the following RFC's for TCP reset generation summary :
 *
 *                               - (a) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation'
 *                               - (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES'
 *                               - (c) RFC Draft-IETF-TCPm-TCPSecure #00, Section 3
 *
 * @note     (4) TCP connection resets are transmitted :
 *
 *                               - (a) When certain invalid segments are received :
 *
 *                               - (A) Some TCP transmit reset validation logic implemented in previous functions;
 *                           include duplicate validation logic in NetTCP_TxConnReset() only if debug/
 *                           validation code is enabled.
 *
 *                               - (1) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : CLOSED [State]'
 *                           states that if the current TCP connection "state is CLOSED", then ...
 *
 *                               - (1) "An incoming segment     containing a RST is discarded".
 *                               - (2) "An incoming segment NOT containing a RST causes a RST to be sent".
 *
 *                               - (B) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation : 1'
 *                           reiterates that "if [a] connection does not exist (CLOSED) then a reset is
 *                           sent in response to any incoming segment except another reset".
 *
 *                               - (2) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State] :
 *                           Check for ACK' states that "any acknowledgment is bad if it arrives on a
 *                           connection still in the LISTEN state.  An acceptable reset segment should
 *                           be formed for any arriving ACK-bearing segment".
 *
 *                               - (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN [State] :
 *                           Check for SYN' also states that "if the security/compartment on the incoming
 *                           segment does not exactly match the security/compartment in the TCB ... [or]
 *                           if the SEG.PRC is ... not allowed [then] send a reset".
 *
 *                           However, these checks for invalid connection permissions are NOT necessary
 *                           since TCP security & precedence NOT supported (see 'net_tcp.c  Note #1a').
 *
 *                               - (3) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                           Check ACK Bit' states that "if the state is SYN-SENT" & "the ACK bit is set" &
 *                           the incoming segment's "SEG.ACK =< ISS, or SEG.ACK > SND.NXT, send a reset".
 *
 *                               - (4) (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check Sequence
 *                           Number' states that for the "SYN-RECEIVED STATE, ESTABLISHED STATE, FIN-
 *                           WAIT-1 STATE, FIN-WAIT-2 STATE, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK
 *                           STATE, TIME-WAIT STATE", to "first check [the] sequence number ... [and if
 *                           it] is not acceptable, an acknowledgment should be sent in reply ... unless
 *                           the RST bit is set".
 *
 *                               - (B) (1) (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check SYN
 *                           Bit' states that for "SYN-RECEIVED [STATE], ESTABLISHED STATE, FIN-WAIT
 *                           STATE-1, FIN-WAIT STATE-2, CLOSE-WAIT STATE, CLOSING STATE, LAST-ACK
 *                           STATE, TIME-WAIT STATE ... [to next] check the SYN bit ... [and] if
 *                           the SYN is in the window it is an error, send a reset, any outstanding
 *                           RECEIVEs and SEND[s] should receive 'reset' responses, all segment
 *                           queues should be flushed, the user should also receive an unsolicited
 *                           general 'connection reset' signal[, and] enter the CLOSED state".
 *
 *                               - (b) But "if the SYN is not in the window this step would not have been
 *                           reached and an ack would have been sent" (see Note #4a4A).
 *
 *                               - (2) (a) HOWEVER, RFC Draft-IETF-TCPm-TCPSecure #00, Section 3.2 amends the
 *                           "handling of a segment with the SYN bit set in the synchronized state
 *                           ... [by] handling ... the SYN bit" as follows :
 *
 *                               - (a) "If the SYN bit is set and the sequence number is outside the
 *                           expected window, send an ACK back to the peer."
 *
 *                               - (b) "If the SYN bit is set and the sequence number is an exact
 *                           match to the next expected sequence (RCV.NXT == SEG.SEQ)
 *                           then send an ACK segment ... but ... subtract one from
 *                           value being acknowledged."
 *
 *                               - (c) "If the SYN bit is set and the sequence number is acceptable,
 *                           i.e.: (RCV.NXT <= SEG.SEQ <= RCV.NXT+RCV.WND) then send an
 *                           ACK segment."
 *
 *                               - (b) Although RFC Draft-IETF-TCPm-TCPSecure #00 explicitly states that
 *                           this amendment applies only to the "handling of a ... SYN ... in a
 *                           synchronized state", it is assumed that this should also apply to the
 *                           SYN-RECEIVED state.
 *
 *                               - (C) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field'
 *                           states to next "check the ACK Field" :
 *
 *                               - (1) If in the "SYN-RECEIVED STATE ... [and] if the segment acknowledgment
 *                           is not acceptable, form a reset segment".
 *
 *                               - (2) If in the "ESTABLISHED STATE" or any state with similar "processing as
 *                           for the ESTABLISHED STATE", that "if the ACK acks something not yet sent
 *                           (SEG.ACK >  SND.NXT) then send an ACK" but "if the ACK is a duplicate
 *                           (SEG.ACK =< SND.UNA), it can be ignored".
 *
 *                               - (D) RFC #793, Section 3.4 'Establishing a Connection : Reset Generation : 3'
 *                           reiterates that for any TCP "connection ... in a synchronized state
 *                           (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,
 *                           TIME-WAIT), any unacceptable segment (out of window sequence number
 *                           or unacceptible [sic] acknowledgment number) must elicit only an empty
 *                           acknowledgment segment containing the current send-sequence number and
 *                           an acknowledgment indicating the next sequence number expected to be
 *                           received".
 *
 *                               - (b) (1) When TCP connection fault-closes from the following synchronization/connected/
 *                           closing states :
 *
 *                               - (A) SYN-RECEIVED
 *                               - (B) SYN-SENT
 *                               - (C) ESTABLISHED
 *                               - (D) FIN-WAIT-1
 *                               - (E) FIN-WAIT-2
 *                               - (F) CLOSING
 *                               - (G) TIME_WAIT
 *                               - (H) CLOSE-WAIT
 *                               - (I) LAST-ACK
 *
 *                               - (2) Although NO RFC directly states to transmit a TCP reset segment when a TCP
 *                           connection fault-closes, it is inferred & seems reasonable that a TCP reset
 *                           segment SHOULD be transmitted whenever a TCP connection closes abnormally.
 *
 * @note     (5) The following sections reiterate the generalization that "a reset is sent in response
 *                           to any [unacceptable segment] ... EXCEPT* another reset"; also "send a reset (UNLESS*
 *                           the RST bit is set, if so drop the segment)" :                      [*emphasis added]
 *
 *                               - (a) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN   [State] :
 *                           Check for RST'
 *                               - (b) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State] :
 *                           Check ACK Bit'
 *                               - (c) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                           SYN-RECEIVED STATE' (see Note #5A)
 *
 *                               - (A) This confirms that the received segment does NOT contain a TCP reset control
 *                           since it follows RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES :
 *                           Check RST Bit'.
 *
 * @note     (6) (a) (1) The following sections ... :
 *
 *                               - (A) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : CLOSED   [State]'
 *                               - (B) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : LISTEN   [State]'
 *                               - (1) Amended by RFC #1122, Section 4.2.2.20.(b)
 *                               - (C) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : SYN-SENT [State]'
 *                               - (D) RFC #793, Section 3.9 'Event Processing : SEGMENT ARRIVES : Check ACK Field :
 *                           SYN-RECEIVED STATE'
 *
 *                               - (2) ... generalize that "the acknowledgment and sequence field values [for the reset
 *                           segment to transmit] are selected to make the reset sequence acceptable to the
 *                           TCP that sent the offending segment" (see Note #4a) :
 *
 *                               - (A) "If the ACK bit is off, sequence number zero is used,
 *
 *                           <SEQ=0> <ACK=SEG.SEQ + SEG.LEN> <CTL=RST, ACK>"
 *
 *                               - (B) "If the ACK bit is on,
 *
 *                           <SEQ=SEG.ACK> <CTL=RST>"
 *
 *                               - (b) However, NO RFC specifies the sequence & acknowledgement numbers to use when
 *                           transmitting a reset segment for a TCP connection that closes due to any fault
 *                           condition(s) [see Note #4b].
 *
 *                               - (1) #### Therefore, TCP transmit reset segments for fault-closing TCP connections
 *                           should be prepared as follows :
 *
 *                               - (A) With the following TCP sequence numbers :
 *
 *                               - (1) TCP_SeqNbr  =  TxSeqNbrUnAckd
 *
 *                               - (2) TCP_AckNbr  =  RxSeqNbrNext
 *
 *                           where
 *
 *                           TCP_SeqNbr          TCP transmit reset segment sequence        number
 *                           TCP_AckNbr          TCP transmit reset segment acknowledgement number
 *                           TxSeqNbrUnAckd      TCP connection's currently unacknowledged transmit
 *                           sequence number
 *                           RxSeqNbrNext        TCP connection's currently expected next  receive
 *                           sequence number
 *
 *                               - (B) With the following TCP segment header flags set :
 *
 *                               - (1) RESET
 *
 *                               - (2) This TCP transmit reset segment format complies with TCP connection received
 *                           reset segment handling as specified in RFC #793, Section 3.9 'Event Processing :
 *                           SEGMENT ARRIVES'.
 *
 *                           See also 'NetTCP_RxPktConnIsValidReset()  Notes #2a2, 2a3, 2a4A1, & 2a4B1'.
 *
 * @note     (7) (a) (1) RFC #793, Sections 3.7 & 2.6 state that "TCP uses retransmission ... to ensure
 *                           delivery of every segment".
 *
 *                               - (2) However, NO RFC specifies whether TCP connection reset segments should be queued
 *                           for retransmission.  Therefore, it is assumed that ALL TCP connection reset
 *                           segments SHOULD NOT be queued for retransmission but SHOULD be silently discarded.
 *
 *                               - (b) (1) The network buffer's reference counter is NOT incremented since the TCP layer
 *                           does NOT maintain a reference to any transmitted TCP connection reset segments.
 *
 *                               - (2) Therefore, the network buffer MUST be freed by lower layer(s).
 *
 *                           See also 'NetTCP_TxConnAck()    Note #8',
 *                           & 'NetTCP_TxConnProbe()  Note #3'.
 *
 * @note     (8) On ANY error(s) :
 *
 *                               - (a) Network resources MUST be appropriately freed :
 *
 *                               - (1) For any network resources NOT linked to the TCP connection, each network resource
 *                           MUST be freed by appropriate function(s).
 *
 *                               - (b) TCP connection MUST NOT be re-closed.
 *
 *                           See also 'NetTCP_ConnClose()  Note #5'.
 *******************************************************************************************************/
static void NetTCP_TxConnReset(NET_TCP_CONN       *p_conn,
                               NET_BUF_HDR        *p_buf_hdr,
                               NET_TCP_RESET_CODE tx_reset_code,
                               NET_TCP_CLOSE_CODE close_code,
                               RTOS_ERR           *p_err)
{
  CPU_BOOLEAN  tx_reset;
  CPU_BOOLEAN  conn_if_nbr_avail;
  NET_CONN_ID  conn_id;
  NET_CONN     *p_net_conn = DEF_NULL;
  NET_IF_NBR   if_nbr;
  NET_BUF_SIZE data_len;
  NET_BUF_SIZE data_ix;
  NET_BUF_SIZE data_ix_offset;
  NET_BUF      *p_seg_reset;
  NET_BUF_HDR  *p_seg_reset_hdr;
#ifdef  NET_IPv4_MODULE_EN
  NET_IPv4_ADDR src_addrv4;
  NET_IPv4_ADDR dest_addrv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
  NET_IPv6_ADDR src_addrv6;
  NET_IPv6_ADDR dest_addrv6;
#endif
  NET_TCP_PORT_NBR  src_port;
  NET_TCP_PORT_NBR  dest_port;
  NET_TCP_SEQ_NBR   seq_nbr;
  NET_TCP_SEQ_NBR   ack_nbr;
  NET_TCP_WIN_SIZE  win_size;
  NET_TCP_FLAGS     flags_tcp;
  NET_PROTOCOL_TYPE proto_type = NET_PROTOCOL_TYPE_NONE;
  NET_CONN_FAMILY   proto_family = NET_CONN_FAMILY_IP_V4_SOCK;
  RTOS_ERR          local_err;

  PP_UNUSED_PARAM(tx_reset_code);
  PP_UNUSED_PARAM(close_code);

  //                                                               -------------- VALIDATE RX'D TCP PKT ---------------
  if (p_buf_hdr != DEF_NULL) {
    if (p_buf_hdr->TCP_SegReset != DEF_NO) {                    // If TCP reset pkt rx'd, ...
      RTOS_ERR_SET(*p_err, RTOS_ERR_TX);                            // ... do NOT tx TCP conn reset (see Note #5).
      goto exit;
    }
  }

  //                                                               ------------- VALIDATE TCP CONN STATE --------------
  tx_reset = DEF_NO;

  if (p_conn != DEF_NULL) {
    switch (p_conn->ConnState) {
      case NET_TCP_CONN_STATE_CLOSED:                           // See Note #4a1.
      case NET_TCP_CONN_STATE_LISTEN:                           // See Note #4a2.
        tx_reset = DEF_YES;
        conn_if_nbr_avail = DEF_NO;
        break;

      case NET_TCP_CONN_STATE_SYNC_TXD:                         // See Note #4a3.
      case NET_TCP_CONN_STATE_SYNC_RXD:                         // See Note #4a4.
      case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
      case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
      case NET_TCP_CONN_STATE_CONN:                             // See Note #4a4.
      case NET_TCP_CONN_STATE_FIN_WAIT_1:
      case NET_TCP_CONN_STATE_FIN_WAIT_2:
      case NET_TCP_CONN_STATE_CLOSING:
      case NET_TCP_CONN_STATE_TIME_WAIT:
      case NET_TCP_CONN_STATE_CLOSE_WAIT:
      case NET_TCP_CONN_STATE_LAST_ACK:
      case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
        tx_reset = DEF_YES;
        conn_if_nbr_avail = DEF_YES;
        break;

      case NET_TCP_CONN_STATE_FREE:
        RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
        goto exit;

      case NET_TCP_CONN_STATE_NONE:
      default:
        RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
    }
  } else {                                                      // If NO demux'd TCP conn avail, handle as CLOSED.
    if (p_buf_hdr != DEF_NULL) {                                // If rx'd pkt avail, ...
      tx_reset = DEF_YES;                                       // ... tx reset.
    }
    conn_if_nbr_avail = DEF_NO;
  }

  if (tx_reset != DEF_YES) {                                    // If NOT valid, abort tx TCP conn reset.
    RTOS_ERR_SET(*p_err, RTOS_ERR_TX);
    goto exit;
  }

  //                                                               ------------ PREPARE TCP CONN RESET SEG ------------
  //                                                               If valid, prepare & tx TCP conn reset.
  if ((p_conn != DEF_NULL)                                      // If avail, ...
      && (conn_if_nbr_avail == DEF_YES)) {
    conn_id = p_conn->ID_Conn;
    if_nbr = NetConn_IF_NbrGet(conn_id);                        // ...  get TCP conn's IF nbr.
  } else if (p_buf_hdr != DEF_NULL) {                           // Else get rx'd pkt's IF nbr.
    if_nbr = p_buf_hdr->IF_Nbr;
  } else if (p_conn != DEF_NULL) {
    conn_id = p_conn->ID_Conn;
    if_nbr = NetConn_IF_NbrGet(conn_id);

    if (if_nbr == NET_IF_NBR_NONE) {                                // Set IF nbr to default if conn IF is not defined.
      if_nbr = NetIF_GetDflt();
    }
  } else {
    RTOS_ERR_SET(*p_err, RTOS_ERR_TX);
    goto exit;
  }

  proto_family = NET_SOCK_PROTOCOL_FAMILY_NONE;

  if (p_conn != DEF_NULL) {
    conn_id = p_conn->ID_Conn;
    p_net_conn = &NetConn_Tbl[conn_id];
    proto_family = p_net_conn->Family;
  } else {
    switch (p_buf_hdr->ProtocolHdrTypeNet) {
#ifdef  NET_IPv4_MODULE_EN
      case NET_PROTOCOL_TYPE_IP_V4:
      case NET_PROTOCOL_TYPE_IP_V4_OPT:
        proto_family = NET_SOCK_PROTOCOL_FAMILY_IP_V4;
        break;
#endif
#ifdef  NET_IPv6_MODULE_EN
      case NET_PROTOCOL_TYPE_IP_V6:
      case NET_PROTOCOL_TYPE_IP_V6_EXT_HOP_BY_HOP:
      case NET_PROTOCOL_TYPE_IP_V6_EXT_ROUTING:
      case NET_PROTOCOL_TYPE_IP_V6_EXT_FRAG:
      case NET_PROTOCOL_TYPE_IP_V6_EXT_ESP:
      case NET_PROTOCOL_TYPE_IP_V6_EXT_AUTH:
      case NET_PROTOCOL_TYPE_IP_V6_EXT_NONE:
      case NET_PROTOCOL_TYPE_IP_V6_EXT_DEST:
      case NET_PROTOCOL_TYPE_IP_V6_EXT_MOBILITY:
        proto_family = NET_SOCK_PROTOCOL_FAMILY_IP_V6;
        break;
#endif

      default:
        break;
    }
  }

  //                                                               Get buf.
  data_len = NET_TCP_DATA_LEN_TX_RESET;
  data_ix = 0u;

  switch (proto_family) {
#ifdef  NET_IPv4_MODULE_EN
    case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
      proto_type = NET_PROTOCOL_TYPE_TCP_V4;
      break;
#endif
#ifdef  NET_IPv6_MODULE_EN
    case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
      proto_type = NET_PROTOCOL_TYPE_TCP_V6;
      break;
#endif

    default:
      break;
  }

  NetTCP_GetTxDataIx(if_nbr,
                     proto_type,
                     0u,
                     data_len,
                     p_conn,
                     &data_ix);

  p_seg_reset = NetBuf_Get(if_nbr,
                           NET_TRANSACTION_TX,
                           data_len,
                           data_ix,
                           &data_ix_offset,
                           NET_BUF_FLAG_NONE,
                           p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit;
  }

  data_ix += data_ix_offset;

  //                                                               ----------------- PREPARE TCP HDR ------------------
  //                                                               Prepare seg addrs.
  if (p_buf_hdr != DEF_NULL) {                                  // If TCP pkt rx'd, cfg TCP tx                ...
                                                                // ...  src  addr from rx'd TCP pkt dest addr ...
                                                                // .. & dest addr from rx'd TCP pkt src  addr.
    if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
      src_addrv4 = p_buf_hdr->IP_AddrDest;
      dest_addrv4 = p_buf_hdr->IP_AddrSrc;
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
      src_addrv6 = p_buf_hdr->IPv6_AddrDest;
      dest_addrv6 = p_buf_hdr->IPv6_AddrSrc;
#endif
    }

    src_port = p_buf_hdr->TransportPortDest;
    dest_port = p_buf_hdr->TransportPortSrc;
  } else {                                                      // Else cfg TCP tx pkt addrs from TCP conn addrs.
    switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
      case NET_CONN_FAMILY_IP_V4_SOCK:
        NetTCP_TxConnPrepareSegAddrs(p_conn,
                                     (CPU_INT08U *)&src_addrv4,
                                     (CPU_INT08U *)&src_port,
                                     sizeof(src_addrv4),
                                     sizeof(src_port),
                                     (CPU_INT08U *)&dest_addrv4,
                                     (CPU_INT08U *)&dest_port,
                                     sizeof(dest_addrv4),
                                     sizeof(dest_port),
                                     p_err);
        break;
#endif

#ifdef  NET_IPv6_MODULE_EN
      case NET_CONN_FAMILY_IP_V6_SOCK:
        NetTCP_TxConnPrepareSegAddrs(p_conn,
                                     (CPU_INT08U *)&src_addrv6,
                                     (CPU_INT08U *)&src_port,
                                     sizeof(src_addrv6),
                                     sizeof(src_port),
                                     (CPU_INT08U *)&dest_addrv6,
                                     (CPU_INT08U *)&dest_port,
                                     sizeof(dest_addrv6),
                                     sizeof(dest_port),
                                     p_err);
        break;
#endif
      default:
        RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
    }

    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {           // See Note #8a.
      goto exit_discard;
    }
  }

  //                                                               Prepare TCP tx flags (see Note #1c2C).
  flags_tcp = NET_TCP_FLAG_NONE
              | NET_TCP_FLAG_TX_RESET;

  //                                                               Prepare TCP seq nbrs (see Note #6).
  if (p_buf_hdr != DEF_NULL) {
    if (p_buf_hdr->TCP_SegAck != DEF_NO) {                      // If TCP ack rx'd  (see Note #6a2B), ...
      seq_nbr = p_buf_hdr->TCP_AckNbr;                          // .. tx  seq = ack                   ...
      ack_nbr = NET_TCP_ACK_NBR_NONE;                           // .. &   ack = none.
    } else {                                                    // Otherwise        (see Note #6a2A), ...
      seq_nbr = NET_TCP_SEQ_NBR_NONE;                           // .. tx  seq = 0 (none)              ...
      ack_nbr = p_buf_hdr->TCP_SeqNbr                           // .. &   ack = seg seq               ...
                + p_buf_hdr->TCP_SegLen;                        // ..         + seg len.

      if (p_buf_hdr->TCP_SegSync == DEF_YES) {
        ack_nbr += 1;
      }

      if (p_buf_hdr->TCP_SegClose == DEF_YES) {
        ack_nbr += 1;
      }

      DEF_BIT_SET(flags_tcp, NET_TCP_FLAG_TX_ACK);
    }
  } else {                                                      // Else no seg rx'd (see Note #6b1A), ...
    seq_nbr = p_conn->TxSeqNbrUnAckd;                           // .. tx  seq = tx unack'd            ...
    ack_nbr = p_conn->RxSeqNbrNext;                             // .. &   ack = rx next.
#ifdef  TEST_TCP_3_18
    DEF_BIT_SET(flags_tcp, NET_TCP_FLAG_TX_ACK);
#endif
  }

  //                                                               Prepare TCP win size.
  win_size = NET_TCP_WIN_SIZE_NONE;

  //                                                               Init buf ctrls.
  p_seg_reset_hdr = &p_seg_reset->Hdr;
  p_seg_reset_hdr->DataIx = data_ix;
  p_seg_reset_hdr->DataLen = data_len;
  p_seg_reset_hdr->TotLen = p_seg_reset_hdr->DataLen;

  p_seg_reset_hdr->TCP_SegSync = DEF_NO;
  p_seg_reset_hdr->TCP_SegClose = DEF_NO;
  p_seg_reset_hdr->TCP_SegAck = DEF_BIT_IS_SET(flags_tcp, NET_TCP_FLAG_TX_ACK);
  p_seg_reset_hdr->TCP_SegReset = DEF_YES;

  p_seg_reset_hdr->TCP_Flags = flags_tcp;

  //                                                               -------------- TX TCP CONN RESET SEG ---------------
  switch (proto_family) {
#ifdef  NET_IPv4_MODULE_EN
    case NET_CONN_FAMILY_IP_V4_SOCK:
      p_seg_reset_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V4;
      p_seg_reset_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V4;

      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

      NetTCP_TxPktHandlerIPv4(p_seg_reset,
                              src_addrv4,
                              src_port,
                              dest_addrv4,
                              dest_port,
                              seq_nbr,
                              ack_nbr,
                              win_size,
                              NET_IPv4_TOS_DFLT,
                              NET_IPv4_TTL_DFLT,
                              flags_tcp,
                              NET_IPv4_FLAG_NONE,
                              DEF_NULL,
                              DEF_NULL,
                              &local_err);
      if (RTOS_ERR_CODE_GET(local_err) != RTOS_ERR_NONE) {
        goto exit_discard;
      }
      break;
#endif

#ifdef  NET_IPv6_MODULE_EN
    case NET_CONN_FAMILY_IP_V6_SOCK:
      p_seg_reset_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V6;
      p_seg_reset_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V6;

      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

      NetTCP_TxPktHandlerIPv6(p_seg_reset,
                              (NET_IPv6_ADDR *)&src_addrv6,
                              src_port,
                              (NET_IPv6_ADDR *)&dest_addrv6,
                              dest_port,
                              seq_nbr,
                              ack_nbr,
                              win_size,
                              NET_IPv6_TRAFFIC_CLASS_DFLT,
                              NET_IPv6_FLOW_LABEL_DFLT,
                              NET_IPv6_HOP_LIM_DFLT,
                              flags_tcp,
                              DEF_NULL,
                              &local_err);
      if (RTOS_ERR_CODE_GET(local_err) != RTOS_ERR_NONE) {
        goto exit_discard;
      }
      break;
#endif

    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
  }

  NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnResetCtr);

  goto exit;

exit_discard:
  NetTCP_TxPktDiscard(p_seg_reset);

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnProbe()
 *
 * @brief    (1) Prepare & transmit a TCP connection probe :
 *
 *           - (a) Validate TCP connection state for TCP probe
 *           - (b) Prepare  TCP probe segment :                                See Note #2
 *               - (1) Get  buffer
 *               - (2) Prepare TCP segment :
 *                   - (A) TCP segment  addresses
 *                   - (B) TCP segment  sequence numbers                       See Note #2b1
 *                   - (C) TCP segment  transmit flags :
 *                       - (1) ACK
 *                   - (D) TCP segment  window size
 *                   - (E) IP  datagram parameters
 *                   - (F) TCP segment  packet buffer controls
 *           - (c) Transmit TCP connection probe
 *
 * @param    p_conn                  Pointer to a TCP connection.
 *
 * @param    tx_probe_data_octet     Indicate whether to transmit a single data probe octet (see Note #2b2) :
 *                                   DEF_YES                Transmit data probe octet.
 *                                   DEF_NO          Do NOT transmit data probe octet.
 *
 * @param    close_code              Select which close action(s) to perform; bit-field flags logically OR'd :
 *                                   NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
 *                                   NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
 *                                   NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
 *                                   NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
 *                                   NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
 *                                   NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
 *                                   NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
 *                                   NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
 *                                   NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
 *                                   NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
 *                                   NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
 *                                   See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *
 * @param    p_err                   Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) TCP connection probes are transmitted for certain TCP conditions :
 *
 *                                       - (A) Some TCP transmit probe validation logic implemented in previous functions;
 *                                   include duplicate validation logic in NetTCP_TxConnProbe() only if debug/
 *                                   validation code is enabled.
 *
 *                                       - (a) RFC #1122, Section 4.2.3.6 specifies a "mechanism [that] periodically probes the
 *                                   other end of a connection" for the following TCP connection conditions :
 *
 *                                       - (1) Probing Zero Windows                                RFC #1122, Section 4.2.2.17
 *                                   (see 'NetTCP_TxConnWinSizeZeroWinHandler()  Note #1b')
 *
 *                                       - (2) TCP Keep-Alives                                     RFC #1122, Section 4.2.3.6
 *                                   (see 'NetTCP_TxConnKeepAlive()  Note #2c')
 *
 *                                       - (b) "Send a probe segment ... to elicit a response from the peer TCP" :
 *
 *                                       - (1) (A) (1) "Such a segment generally contains SEG.SEQ = SND.NXT-1" ...
 *
 *                                       - (a) "Note that on a quiet connection SND.NXT = RCV.NXT, so that this SEG.SEQ
 *                                   will be outside the window.  Therefore, the probe causes the receiver
 *                                   to return an acknowledgment segment, confirming that the connection is
 *                                   still live.  If the peer has dropped the connection ... it will respond
 *                                   with a RST instead of an acknowledgment segment."
 *
 *                                       - (b) However, this contradicts Wright/Stevens, TCP/IP Illustrated, Volume 2,
 *                                   3rd Printing, Section 25.6 'Connection Establishment and Keepalive Timers :
 *                                   Send a keepalive probe', Page 830 which states that "the sequence number
 *                                   field of the keepalive packet ... contains [SND.UNA] minus 1, which is
 *                                   the sequence number of a byte of data that the other end has already
 *                                   acknowledged ... Since this sequence number is outside the window, the
 *                                   other end must respond with an ACK, specifying the next sequence number
 *                                   it expects".
 *
 *                                       - (2) (a) Although on an idle TCP connection, the next sequence octet to transmit
 *                                   (SND.NXT) is equal to the last unacknowledged transmit sequence octet
 *                                   (SND.UNA); on a TCP connection whose remote host has zero-window closed
 *                                   its receive window, the next sequence octet to transmit is NOT equal to
 *                                   the last unacknowledged transmit sequence octet.
 *
 *                                       - (b) Therefore, it seems reasonable to transmit probe segments with a sequence
 *                                   number (SEQ.SEQ) that is one less than the last unacknowledged transmit
 *                                   sequence octet (SND.UNA).
 *
 *                                       - (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
 *                                   'Connection Establishment and Keepalive Timers : Send a keepalive probe',
 *                                   Page 830 states that "the acknowledgment  field of the keepalive packet ...
 *                                   contains [RCV.NXT], the next sequence number expected on the connection".
 *
 *                                       - (2) "and may or may not contain one garbage octet of data."
 *
 *                                       - (A) "An implementation SHOULD send a [probe] segment with no data."
 *
 *                                       - (B) (1) "Unfortunately, some misbehaved TCP implementations fail to respond to
 *                                   a segment with SEG.SEQ = SND.NXT-1 unless the segment contains data."
 *
 *                                       - (2) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.3 'Other
 *                                   End Crashes', Page 335 reiterates that "some older implementations based
 *                                   on 4.2BSD do not respond to these ... probes unless the segment contains
 *                                   data".
 *
 *                                       - (C) Therefore, RFC #1122, Section 4.2.3.6 states that a TCP "implementation ...
 *                                   MAY be configurable to send a [probe] segment containing one garbage octet,
 *                                   for compatibility with erroneous TCP implementations".
 *
 *                                   See also 'NetTCP_TxConnKeepAlive()  Note #2d2'.
 *
 * @note     (3) (a) (1) (A) RFC #793, Sections 3.7 & 2.6 state that "TCP uses retransmission ... to ensure
 *                                   delivery of every segment".
 *
 *                                       - (B) (1) However, RFC #1122, Section 4.2.2.17 'DISCUSSION' states that "it is
 *                                   extremely important to remember that ACK (acknowledgment) segments that
 *                                   contain no data are not reliably transmitted by TCP".
 *
 *                                       - (2) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
 *                                   'Connection Establishment and Keepalive Timers : Drop connection when no
 *                                   response', Page 830 reiterates that "one reason TCP must send multiple
 *                                   keepalive probes before considering the connection dead is that the
 *                                   ACKs sent in response do not contain data and therefore are not reliably
 *                                   transmitted by TCP.  An ACK that is a response to a keepalive probe can
 *                                   get lost".
 *
 *                                       - (2) Therefore, it is assumed that TCP acknowledgement/probe segments should NOT be
 *                                   queued for retransmission but SHOULD be silently discarded.
 *
 *                                       - (b) (1) The network buffer's reference counter is NOT incremented since the TCP layer
 *                                   does NOT maintain a reference to any transmitted TCP probe segments.
 *
 *                                       - (2) Therefore, the network buffer MUST be freed by lower layer(s).
 *
 *                                   See also 'NetTCP_TxConnAck()    Note #8',
 *                                   & 'NetTCP_TxConnReset()  Note #7'.
 *
 * @note     (4) On ANY error(s), network resources MUST be appropriately freed :
 *
 *                                       - (a) For any network resources NOT linked to the TCP connection, each network resource
 *                                   MUST be freed by appropriate function(s).
 *
 * @note     (5) (a) IP  transmit options currently NOT implemented     See 'net_tcp.c  Note #1d'
 *                                       - (b) TCP transmit options currently NOT implemented     See 'net_tcp.c  Note #1c'
 *******************************************************************************************************/
static void NetTCP_TxConnProbe(NET_TCP_CONN       *p_conn,
                               CPU_BOOLEAN        tx_probe_data_octet,
                               NET_TCP_CLOSE_CODE close_code,
                               RTOS_ERR           *p_err)
{
#ifdef  NET_IPv4_MODULE_EN
  NET_IPv4_ADDR  src_addrv4;
  NET_IPv4_ADDR  dest_addrv4;
  NET_IPv4_TOS   TOS;
  NET_IPv4_TTL   TTL;
  NET_IPv4_FLAGS flags_ipv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
  NET_IPv6_ADDR          src_addrv6;
  NET_IPv6_ADDR          dest_addrv6;
  NET_IPv6_TRAFFIC_CLASS traffic_class;
  NET_IPv6_FLOW_LABEL    flow_label;
  NET_IPv6_HOP_LIM       hop_lim;
  NET_IPv6_FLAGS         flags_ipv6;
#endif
  NET_BUF_SIZE      data_len;
  NET_BUF_SIZE      data_ix;
  NET_BUF_SIZE      data_ix_offset;
  NET_CONN_ID       conn_id;
  NET_CONN          *p_net_conn;
  NET_IF_NBR        if_nbr;
  NET_BUF           *p_seg_probe;
  NET_BUF_HDR       *p_seg_probe_hdr;
  NET_TCP_PORT_NBR  src_port;
  NET_TCP_PORT_NBR  dest_port;
  NET_TCP_SEQ_NBR   seq_nbr;
  NET_TCP_SEQ_NBR   ack_nbr;
  NET_TCP_WIN_SIZE  win_size;
  NET_TCP_FLAGS     flags_tcp;
  CPU_INT08U        probe_data[NET_TCP_DATA_LEN_TX_PROBE_DATA];
  NET_PROTOCOL_TYPE proto_type = NET_PROTOCOL_TYPE_NONE;

  PP_UNUSED_PARAM(close_code);

  //                                                               ------------ PREPARE TCP CONN PROBE SEG ------------
  //                                                               If valid, prepare & tx TCP conn probe.
  //                                                               Get buf.
  conn_id = p_conn->ID_Conn;
  if_nbr = NetConn_IF_NbrGet(conn_id);

  data_len = (tx_probe_data_octet == DEF_YES)                   // Cfg data len for probe data (see Note #2b2C).
             ?  NET_TCP_DATA_LEN_TX_PROBE_DATA
             :  NET_TCP_DATA_LEN_TX_PROBE_NO_DATA;

  p_net_conn = &NetConn_Tbl[conn_id];

  switch (p_net_conn->Family) {
    case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
      proto_type = NET_PROTOCOL_TYPE_TCP_V4;
      break;

    case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
      proto_type = NET_PROTOCOL_TYPE_TCP_V6;
      break;
  }

  data_ix = 0u;

  NetTCP_GetTxDataIx(if_nbr,
                     proto_type,
                     0u,
                     data_len,
                     p_conn,
                     &data_ix);

  p_seg_probe = NetBuf_Get(if_nbr,
                           NET_TRANSACTION_TX,
                           data_len,
                           data_ix,
                           &data_ix_offset,
                           NET_BUF_FLAG_NONE,
                           p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit;
  }

  data_ix += data_ix_offset;

  if (tx_probe_data_octet == DEF_YES) {                         // If tx probe data req'd,          ...
    probe_data[0] = NET_TCP_TX_PROBE_DATA;                      // ... prepare data (see Note #2b2) ...
    NetBuf_DataWr(p_seg_probe,                                  // ... & wr    data into TCP tx buf.
                  data_ix,
                  data_len,
                  &probe_data[0]);
  }

  //                                                               ----------------- PREPARE TCP HDR ------------------
  //                                                               Prepare seg addrs.
  p_seg_probe_hdr = &p_seg_probe->Hdr;

  if (p_net_conn->Family == NET_SOCK_PROTOCOL_FAMILY_IP_V6) {
    DEF_BIT_SET(p_seg_probe_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);
  }

  if (DEF_BIT_IS_CLR(p_seg_probe_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
    NetTCP_TxConnPrepareSegAddrs(p_conn,
                                 (CPU_INT08U *)&src_addrv4,
                                 (CPU_INT08U *)&src_port,
                                 sizeof(src_addrv4),
                                 sizeof(src_port),
                                 (CPU_INT08U *)&dest_addrv4,
                                 (CPU_INT08U *)&dest_port,
                                 sizeof(dest_addrv4),
                                 sizeof(dest_port),
                                 p_err);
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    NetTCP_TxConnPrepareSegAddrs(p_conn,
                                 (CPU_INT08U *)&src_addrv6,
                                 (CPU_INT08U *)&src_port,
                                 sizeof(src_addrv6),
                                 sizeof(src_port),
                                 (CPU_INT08U *)&dest_addrv6,
                                 (CPU_INT08U *)&dest_port,
                                 sizeof(dest_addrv6),
                                 sizeof(dest_port),
                                 p_err);
#endif
  }

  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {             // See Note #4a.
    goto exit_discard;
  }

  //                                                               Prepare TCP seq nbrs.
  seq_nbr = p_conn->TxSeqNbrUnAckd;
  ack_nbr = p_conn->RxSeqNbrNext;                               // Cfg ACK w/ next    rx seq nbr (see Note #2b1B).

  //                                                               Prepare TCP tx flags (see Note #1b2C).
  flags_tcp = NET_TCP_FLAG_NONE
              | NET_TCP_FLAG_TX_ACK;

  //                                                               Prepare TCP win size.
  win_size = p_conn->RxWinSizeActual;

  //                                                               Prepare IP params.
  if (DEF_BIT_IS_CLR(p_seg_probe_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
    NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL);
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6);
#endif
  }

  //                                                               Init buf ctrls.
  p_seg_probe_hdr = &p_seg_probe->Hdr;
  p_seg_probe_hdr->DataIx = (CPU_INT16U)data_ix;
  p_seg_probe_hdr->DataLen = (NET_BUF_SIZE)data_len;
  p_seg_probe_hdr->TotLen = (NET_BUF_SIZE)p_seg_probe_hdr->DataLen;

  p_seg_probe_hdr->TCP_SegSync = (CPU_BOOLEAN)DEF_NO;
  p_seg_probe_hdr->TCP_SegClose = (CPU_BOOLEAN)DEF_NO;
  p_seg_probe_hdr->TCP_SegAck = (CPU_BOOLEAN)DEF_YES;
  p_seg_probe_hdr->TCP_SegReset = (CPU_BOOLEAN)DEF_NO;

  p_seg_probe_hdr->TCP_Flags = (NET_TCP_FLAGS)flags_tcp;

  //                                                               -------------- TX TCP CONN PROBE SEG ---------------
  if (DEF_BIT_IS_CLR(p_seg_probe_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
    p_seg_probe_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V4;
    p_seg_probe_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V4;

    NetTCP_TxPktHandlerIPv4(p_seg_probe,
                            src_addrv4,
                            src_port,
                            dest_addrv4,
                            dest_port,
                            seq_nbr,
                            ack_nbr,
                            win_size,
                            TOS,
                            TTL,
                            flags_tcp,
                            flags_ipv4,
                            DEF_NULL,
                            DEF_NULL,                           // See Note #5.
                            p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit_discard;
    }
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    p_seg_probe_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V6;
    p_seg_probe_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V6;

    NetTCP_TxPktHandlerIPv6(p_seg_probe,
                            &src_addrv6,
                            src_port,
                            &dest_addrv6,
                            dest_port,
                            seq_nbr,
                            ack_nbr,
                            win_size,
                            NET_IPv6_TRAFFIC_CLASS_DFLT,
                            NET_IPv6_FLOW_LABEL_DFLT,
                            NET_IPv6_HOP_LIM_DFLT,
                            flags_tcp,
                            DEF_NULL,
                            p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit_discard;
    }
#endif
  }

  NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnProbeCtr);

  goto exit;

exit_discard:
  NetTCP_TxPktDiscard(p_seg_probe);

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnKeepAlive()
 *
 * @brief    (1) Prepare & transmit a TCP connection keep-alive :
 *
 *           - (a) Validate transmit keep-alive threshold                      See Note #2c3
 *           - (b) Prepare  TCP keep-alive probe :
 *               - (1) Garbage dummy data                                      See Note #2d2
 *           - (c) Transmit TCP keep-alive probe
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    close_code  Select which close action(s) to perform; bit-field flags logically OR'd :
 *                       NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
 *                       NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
 *                       NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
 *                       NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
 *                       NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
 *                       NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
 *                       NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
 *                       NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
 *                       NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
 *                       NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
 *                       NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
 *                       See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) RFC #1122, Section 4.2.3.6 states that "TCP implementations ... MAY include 'keep-alives'
 *                       ... although this practice is not universally accepted ... A 'keep-alive' mechanism
 *                       periodically probes the other end of a connection when the connection is otherwise idle,
 *                       even when there is no data to be sent".
 *
 *                           - (a) RFC #1122, Section 4.2.3.6 states that "if keep-alives are included" :
 *
 *                           - (1) "The application MUST be able to turn them on or off for each TCP connection,"
 *                           - (2) "and they MUST default to off."
 *
 *                           - (b) (1) RFC #1122, Section 4.2.3.6 states that "keep-alive packets MUST only be sent when
 *                       no data or acknowledgement packets have been received for the connection within an
 *                       interval" :
 *
 *                           - (A) "This interval MUST be configurable" ...
 *                           - (B) "and MUST default to no less than two hours."
 *
 *                           - (2) (A) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.2, Page 333
 *                       states that :
 *
 *                           - (1) "The keepalive ... 2-hour idle time value" ...
 *                           - (2) "can usually be changed, but ... is [typically] a system-wide value, so
 *                       changing it affects all" TCP connections.
 *
 *                           - (B) However, NO RFC requires that the configurable keep-alive, idle timeout be a
 *                       single, system-wide value.  Therefore, it seems reasonable to permit each TCP
 *                       connection to maintain its    own configurable keep-alive, idle timeout value.
 *
 *                       See also 'NetTCP_ConnCfgIdleTimeoutHandler()  Note #1'.
 *
 *                           - (c) (1) (A) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.2, Pages 332-333
 *                       states that "if there is no activity on a given connection for 2 hours" (see
 *                       Note #2b), TCP "sends a probe segment to the" remote host :
 *
 *                           - (1) (a) If "the [remote] host is still up and running and reachable ... [and]
 *                       responds normally ... [then TCP] knows that the other end is still up" :
 *                           - (b) (1) "TCP will reset the keepalive timer for 2 hours" ...
 *                           - (2) "If there is application traffic across the connection before the
 *                       next 2-hour timer expires, the timer is reset for 2 hours in the
 *                       future, following the exchange of data."
 *
 *                           - (2) (a) If "the [remote] host has crashed [or] is ... unreachable ... [and]
 *                       not responding" ...
 *                           - (b) (1) Then "the [TCP] sends a total of 10 ... probes," ...
 *                           - (2) "75 seconds apart,"                              ...
 *                           - (c) (1) "and if it doesn't receive a response, [then TCP] considers the
 *                       [remote] host as down"          ...
 *                           - (2) "and terminates the connection" ...
 *                           - (3) The "error ... returned to the ... application by ... TCP ... is
 *                       ... 'connection timed out'".
 *
 *                           - (3) (a) If "the [remote] host has crashed and rebooted"     ...
 *                           - (b) (1) Then its "response will be a reset,"            ...
 *                           - (2) "causing the [TCP] to terminate the connection" ...
 *                           - (3) The "error ... returned to the ... application by ... TCP ... is
 *                       ... 'connection reset by peer'".
 *
 *                           - (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
 *                       'Connection Establishment and Keepalive Timers', Page 828 also states that :
 *
 *                           - (1) (a) "When a segment is received on a connection," ...
 *                           - (b)  TCP "resets the keepalive timer for that connection to 2 hours".
 *                           - (a) (a) (1) "If the keepalive timer expires (2 hours after the last segment
 *                       was received on the connection)," ...
 *                           - (2) "and if the socket option is set," ...
 *                           - (b) "a keepalive probe is sent to the other end."
 *
 *                           - (C) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
 *                       'Connection Establishment and Keepalive Timers : Keepalive timer expires
 *                       after 2 hours of idle time', Page 829 adds that :
 *
 *                           - (1) "Probes are sent only if the connection is in the" ...
 *                           - (a) "ESTABLISHED or" ...
 *                           - (b) "CLOSE_WAIT states."
 *                           - (2) "Keepalive probes are not sent ... once the process calls close()
 *                       ... even if the connection is idle for 2 hours."
 *
 *                           - (2) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
 *                       'Connection Establishment and Keepalive Timers : Drop connection when no
 *                       response', Page 830 states that :
 *
 *                           - (A) (1) "If the total idle time for the connection is greater than or equal
 *                       to 2 hours" ...
 *                           - (2) (a) "plus ... [the] limit of nine keepalive probes," ...
 *                           - (b) "75 seconds apart,"                              ...
 *                           - (B) (1) "with no response" ...
 *                           - (2)  then the TCP "connection is dropped".
 *
 *                           - (3) (A) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
 *                       'Connection Establishment and Keepalive Timers : Send a keepalive probe',
 *                       Page 830 states that "after 2 hours of idle time ... [a TCP] connection ...
 *                       sends ... nine keepalive probes".
 *
 *                       See also Note #2c2A2a.
 *
 *                           - (B) However, this contradicts the TCP keep-alive example in Figure 23.1 of
 *                       Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.3 'Other
 *                       End Crashes', Pages 334-335 which shows "that the [remote host] ... send[s]
 *                       10 keepalive probes ... before declaring the connection dead".
 *
 *                       See also Note #2c1A2b1.
 *
 *                           - (d) RFC #1122, Section 4.2.3.6 states that "to confirm that an idle connection is still
 *                       active ... send a probe segment ... to elicit a response from the peer TCP" :
 *
 *                           - (1) (A) "Such a segment generally contains SEG.SEQ = SND.NXT-1" ...
 *
 *                           - (1) "Note that on a quiet connection SND.NXT = RCV.NXT, so that this SEG.SEQ
 *                       will be outside the window.  Therefore, the probe causes the receiver
 *                       to return an acknowledgment segment, confirming that the connection is
 *                       still live.  If the peer has dropped the connection ... it will respond
 *                       with a RST instead of an acknowledgment segment."
 *
 *                           - (2) However, this contradicts Wright/Stevens, TCP/IP Illustrated, Volume 2,
 *                       3rd Printing, Section 25.6 'Connection Establishment and Keepalive Timers :
 *                       Send a keepalive probe', Page 830 which states that "the sequence number
 *                       field of the keepalive packet ... contains [SND.UNA] minus 1, which is
 *                       the sequence number of a byte of data that the other end has already
 *                       acknowledged ... Since this sequence number is outside the window, the
 *                       other end must respond with an ACK, specifying the next sequence number
 *                       it expects".
 *
 *                           - (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
 *                       'Connection Establishment and Keepalive Timers : Send a keepalive probe',
 *                       Page 830 states that "the acknowledgment field of the keepalive packet ...
 *                       contains [RCV.NXT], the next sequence number expected on the connection".
 *
 *                       See also 'NetTCP_TxConnProbe()  Note #2b1'.
 *
 *                           - (2) "and may or may not contain one garbage octet of data."
 *
 *                           - (A) "An implementation SHOULD send a keep-alive segment with no data".
 *
 *                           - (1) (a) "Unfortunately, some misbehaved TCP implementations fail to respond to
 *                       a segment with SEG.SEQ = SND.NXT-1 unless the segment contains data."
 *
 *                           - (b) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.3 'Other
 *                       End Crashes', Page 335 reiterates that "some older implementations based
 *                       on 4.2BSD donot respond to these keepalive probes unless the segment
 *                       contains data".
 *
 *                           - (2) (a) Therefore, RFC #1122, Section 4.2.3.6 states that a TCP "implementation ...
 *                       MAY be configurable to send a keep-alive segment containing one garbage
 *                       octet, for compatibility with erroneous TCP implementations".
 *
 *                           - (b) (1) (A) "Alternatively, an implementation could determine whether a peer
 *                       responded correctly to keep-alive packets with no garbage data
 *                       octet."
 *
 *                           - (B) Or as Stevens, TCP/IP Illustrated, Volume 1, 8th Printing,
 *                       Section 23.3 'Other End Crashes', Page 335 states, some
 *                       "systems send" :
 *
 *                           - (1) "The 4.3BSD-style segment (no data) for the first half of
 *                       the probe period," ...
 *                           - (2) "and if no response is received, switch to the 4.2BSD-style
 *                       segment for the last half."
 *
 *                           - (2) Therefore, it seems reasonable to implement the combined BSD 4.3/4.2
 *                       solution since it does NOT require any non-standard configuration
 *                       for the garbage data octet & SHOULD be backwards-compatible with
 *                       all other systems.
 *
 *                           - (3) (A) RFC #1122, Section 4.2.3.6 states that "it is extremely important to remember
 *                       that ACK segments that contain no data are not reliably transmitted by TCP.
 *                       Consequently, if a keep-alive mechanism is implemented it MUST NOT interpret
 *                       failure to respond to any specific probe as a dead connection".
 *
 *                           - (B) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
 *                       'Connection Establishment and Keepalive Timers : Drop connection when no
 *                       response', Page 830 reiterates that "one reason TCP must send multiple
 *                       keepalive probes before considering the connection dead is that the
 *                       ACKs sent in response do not contain data and therefore are not reliably
 *                       transmitted by TCP.  An ACK that is a response to a keepalive probe can
 *                       get lost".
 *
 *                       See also 'NetTCP_TxConnProbe()  Note #3a'.
 *******************************************************************************************************/
static void NetTCP_TxConnKeepAlive(NET_TCP_CONN       *p_conn,
                                   NET_TCP_CLOSE_CODE close_code,
                                   RTOS_ERR           *p_err)
{
  CPU_BOOLEAN tx_probe_data_octet;
  NET_PKT_CTR tx_probe_data_th;
  CPU_INT32U  timeout_ms;
  RTOS_ERR    local_err;

  //                                                               -------------- VALIDATE TX KEEP-ALIVE --------------
  p_conn->TxKeepAliveCtr++;
  if (p_conn->TxKeepAliveCtr > p_conn->TxKeepAliveTh) {         // If nbr keep-alives tx'd > th, ...
    NetTCP_ConnClose(p_conn,                                    // ... close TCP conn (see Note #2c2B2).
                     DEF_NULL,
                     p_conn->ConnCloseAppFlag,
                     close_code);
    RTOS_ERR_SET(*p_err, RTOS_ERR_NET_RETRY_MAX);
    goto exit;
  }

  //                                                               ----------- SET TCP CONN KEEP-ALIVE TMR ------------
  //                                                               Set keep-alive tmr (see Notes #2c1A2b2 & #2c2A2b).
  timeout_ms = p_conn->TxKeepAliveRetryTimeout_sec * DEF_TIME_NBR_mS_PER_SEC;

  if (p_conn->TimeoutTmr != DEF_NULL) {
    NetTmr_Set(p_conn->TimeoutTmr,
               NetTCP_ConnIdleTimeout,
               timeout_ms);
  } else {
    p_conn->TimeoutTmr = NetTmr_Get(NetTCP_ConnIdleTimeout,
                                    p_conn,
                                    timeout_ms,
                                    NET_TMR_OPT_NONE,
                                    p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn,
                       DEF_NULL,
                       p_conn->ConnCloseAppFlag,
                       close_code);
      goto exit;
    }
  }

  p_conn->TxSeqNbrUnAckd -= 1;                                  // Decrement the sequence number.

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  //                                                               ------------------ TX KEEP-ALIVE -------------------
  tx_probe_data_th = (p_conn->TxKeepAliveTh + 1u) / 2u;         // Cfg garbage octet (see Note #2d2A2b2).
  tx_probe_data_octet = (p_conn->TxKeepAliveCtr <= tx_probe_data_th) ? DEF_NO : DEF_YES;
  NetTCP_TxConnProbe(p_conn, tx_probe_data_octet, close_code, &local_err);
  PP_UNUSED_PARAM(local_err);                                   // Ignore transitory tx err(s).

  NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnKAliveCtr);

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnKeepAliveReset()
 *
 * @brief    Reset TCP connection's transmit keep-alive controls.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *******************************************************************************************************/
static void NetTCP_TxConnKeepAliveReset(NET_TCP_CONN *p_conn)
{
  p_conn->TxKeepAliveCtr = 0u;
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnTxQ()
 *
 * @brief    (1) Transmit TCP data segment(s) from TCP connection transmit queue :
 *
 *           - (a) Configure TCP connection transmit :
 *
 *               - (1) Configure TCP connection transmit acknowledgement request :     See Note #1d1
 *
 *                   - (A) Do NOT transmit TCP data/acknowledgement if ...
 *                       - (1) NO TCP transmit data available or allowed to transmit
 *                                   AND
 *                       - (2) NO transmit acknowledgement requested
 *
 *                   - (B)        Transmit TCP      acknowledgement if ...
 *                       - (1) NO TCP transmit data available or allowed to transmit
 *                                   BUT
 *                       - (2)    Transmit acknowledgement requested
 *
 *               - (2) Configure TCP connection transmit free timer request            See Note #1d4
 *
 *           - (b) Transmit TCP connection transmit queue data :
 *
 *               - (1) Control TCP connection transmit versus transmit congestion controls :
 *
 *                       - (a) See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2'
 *                                       & 'NetTCP_TxConnWinSizeUpdateAvail()      Note #1'
 *
 *                   - (A) Available Transmit Window                            See Note  #1b1a
 *                   - (B) Transmit Queue Segment                               See Notes #5         & #8
 *                   - (C) Nagle Algorithm                                      See Notes #6, #7b2B, & #8
 *                   - (D) Silly Window Syndrome                                See Notes     #7     & #8
 *
 *               - (2) Update TCP connection transmit queue :
 *                   - (A) Remove TCP transmit segment(s) from
 *                                   TCP connection    transmit queue                     See Note #3
 *                   - (B) Append TCP transmit segment(s) to
 *                                   TCP connection re-transmit queue                     See Note #4
 *                   - (C) Update TCP connection re-transmit queue timer
 *
 *               - (3) Update TCP connection :
 *                   - (A) Update TCP connection sequence number(s)
 *                   - (B) Update TCP connection transmit congestion window
 *
 *               - (4) Prepare  TCP data/acknowledgement segment(s) :
 *                   - (A) TCP segment  addresses
 *                   - (B) TCP segment  sequence numbers
 *                   - (C) TCP segment  transmit flags :
 *                       - (1) ACK
 *                   - (D) TCP segment  window size
 *                   - (E) IP  datagram parameters
 *                   - (F) TCP segment  packet buffer controls
 *
 *               - (5) Transmit TCP data/acknowledgement segment(s)
 *
 *           - (c) Suspend TCP transmit :                                              See Note #10
 *
 *               - (1) Handle any network receive packet(s)                            See Note #10b2A
 *
 *           - (d) Complete TCP connection transmit :
 *
 *               - (1) Transmit TCP connection acknowledgement                         See Note #1a1
 *               - (2) Clear    TCP connection transmit idle timer
 *                           (see 'NetTCP_TxConnTxQ_TimeoutIdleClr()  Note #2b2')
 *               - (3) Reset    TCP connection delayed  acknowledgement controls
 *               - (4) Free     TCP connection transmit queue persist timer            See Note #1a2
 *
 *       - (2) NetTCP_TxConnTxQ() transmits TCP connection data & acknowledgements.  TCP acknowledgements
 *               transmitted independently of TCP controls &/or data MAY be transmitted with NetTCP_TxConnAck().
 *
 *               See also 'NetTCP_TxConnAck()  Note #2'.
 *
 * @param    p_conn          Pointer to a TCP connection.
 *
 * @param    p_buf_hdr       Pointer to network buffer header that received TCP packet.
 *
 * @param    tx_ack_code     Indicate whether & how to transmit a TCP acknowledgement segment :
 *                           NET_TCP_CONN_TX_ACK_NONE            Do NOT transmit a TCP acknowledgement
 *                           segment          if TCP transmit data
 *                           NOT available.
 *                           NET_TCP_CONN_TX_ACK                 Transmit a TCP acknowledgement segment
 *                           even if TCP transmit data NOT available.
 *                           NET_TCP_CONN_TX_ACK_IMMED           Transmit a TCP acknowledgement segment
 *                           immediately even if TCP transmit data
 *                           NOT available.
 *
 * @param    tx_q_timeout    Indicate whether the TCP connection transmit queue timed out :
 *                           DEF_NO                              TCP connection transmit queue did
 *                           NOT time  out.
 *                           DEF_YES                             TCP connection transmit queue
 *                           timed out.
 *
 * @param    close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
 *                           NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
 *                           NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
 *                           NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
 *                           NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
 *                           NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
 *                           NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
 *                           NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
 *                           See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @note     (3) See 'NetTCP_TxConnAppData()  Note #3' for TCP connection Transmit Queue diagram.
 *
 * @note     (4) TCP segments that have been transmitted but NOT yet acknowledged are sequenced into
 *                           the TCP connection's re-transmit queue to await acknowledgement or retransmission.
 *
 *                               - (a) Transmitted TCP segments are inserted into a doubly-linked Re-Transmit Queue,
 *                           ordered consecutively by sequence number(s) [see also Note #4b].
 *
 *                           In the diagram below, ... :
 *
 *                               - (1) (A) TCP connections' 'ReTxQ_Head' points to the head of a TCP connections'
 *                           Re-Transmit Queue;
 *                               - (B) TCP connections' 'ReTxQ_Tail' points to the tail of a TCP connections'
 *                           Re-Transmit Queue.
 *
 *                               - (2) Segment buffers' 'PrevPrimListPtr' & 'NextPrimListPtr'  doubly-link each
 *                           segment to form the Re-Transmit Queue.
 *
 *                               - (b) (1) Transmit segments are transmitted & await acknowledgement in sequence-order.
 *                           Therefore, newly-transmitted segments are sequenced after previously
 *                           transmitted segments starting at the tail of the Re-Transmit Queue.
 *
 *                               - (2) Segments at the head of the Re-Transmit Queue are awaiting acknowledgement
 *                           & removal from the Re-Transmit Queue; & are ready to be re-transmitted until
 *                           acknowledged & removed from the queue.
 *
 *           @verbatim
 *                                |                                               |
 *                                |<----- TCP Connection Re-Transmit Queue ------>|
 *                                |                (see Note #4)                  |
 *
 *                           Segments Awaiting
 *                           Acknowledgement or                        Segments Sequenced
 *                           Re-Transmit                          into Re-Transmit Queue
 *                           start at head                           starting at tail
 *                           (see Note #4b2)                            (see Note #4b1)
 *
 *                                   |             NextPrimListPtr             |
 *                                   |             (see Note #4a2)             |
 *                                   v                    |                    v
 *                                                        |
 *                Head of         -------       -------   v   -------       -------    (see Note #4a1B)
 *              Re-Transmit  ---->|     |------>|     |------>|     |------>|     |
 *                 Queue          |     |       |     |       |     |       |     |         Tail of
 *                                |     |<------|     |<------|     |<------|     |<----  Re-Transmit
 *           (see Note #4a1A)     |     |       |     |   ^   |     |       |     |          Queue
 *                                |     |       |     |   |   |     |       |     |
 *                                -------       -------   |   -------       -------
 *                                                        |
 *                                                 PrevPrimListPtr
 *                                                 (see Note #4a2)
 *           @endverbatim
 *
 * @note     (5) In order to simply TCP transmit buffer management, TCP transmit does NOT transmit
 *                           partial network-buffer segments (i.e. portions of  TCP segments in the same network
 *                           buffer).  This avoids the complexity of queuing & handling partially transmitted
 *                           segments on both the TCP transmit & re-transmit queues.
 *
 *                               - (a) However, in order to avoid transmit window deadlock with a remote host's receive
 *                           window, the TCP connection's connection maximum segment size MUST be configured
 *                           to ensure that full, maximum-segment-sized segments will transmit even for receive
 *                           windows less than the default maximum segment size.
 *
 *                           See also 'NetTCP_ConnCfgMaxSegSize()  Note #2'.
 *
 * @note     (6) (a) (1) RFC #896, Section 'The small-packet problem' states that "there is a special
 *                           problem associated with small packets ... the congestion ... can result in
 *                           lost datagrams and retransmissions, as well as excessive propagation time ...
 *                           In practice, throughput may drop so low that TCP connections are aborted".
 *
 *                               - (2) RFC #896, Section 'The solution to the small-packet problem' states that "the
 *                           solution to the small-packet problem ... is" :
 *
 *                               - (A) "to inhibit the sending of new TCP segments when new outgoing data arrives
 *                           from the user" ...
 *
 *                               - (B) "if any previously transmitted data on the connection remains unacknowledged."
 *
 *                               - (C) "This inhibition is to be unconditional;" :
 *                               - (1) "no timers,"                       ...
 *                               - (2) "tests for size of data received," ...
 *                               - (3) "or other conditions are required."
 *
 *                               - (b) (1) RFC #1122, Section 4.2.3.4 states that "the Nagle algorithm is ... as follows" :
 *
 *                               - (A) "If there is unacknowledged data (i.e., SND.NXT > SND.UNA)," ...
 *                               - (B) "then the sending TCP buffers all user data" ...
 *                               - (1) "(regardless of the PSH bit)," ...
 *                               - (2) "until" :
 *                               - (a) "the outstanding data has been acknowledged" ...
 *                               - (b) "or until the TCP can send a full-sized segment."
 *
 *                               - (2) (A) (1) "A TCP SHOULD implement the Nagle Algorithm ... to coalesce short segments."
 *
 *                               - (2) "However, there MUST be a way for an application to disable the Nagle
 *                           algorithm on an individual connection."
 *
 *                               - (B) Thus it is assumed from these two requirements that the Nagle algorithm
 *                           should be enabled by default.
 *
 *                           See also Note #7b2Ba2A.
 *
 * @note     (7) (a) RFC #813, Section 2 states that "a bad implementation of the window algorithm can
 *                           lead to extremely poor performance ... This particular phenomenon ... has been
 *                           given the name of Silly Window Syndrome, or SWS".
 *
 *                           Section 3 elaborates that "SWS is a degeneration in the throughput which develops
 *                           ... whenever the acknowledgement of a small segment ... cause[s] another segment
 *                           of the same small size to be sent, until ... the network ... becomes clogged with
 *                           many small segments, and an equal number of acknowledgements".
 *
 *                               - (b) (1) RFC #813, Section 4 states that "there is an algorithm that the sender can use
 *                           ... [which] compares the useable window to the offered window, and refrains from
 *                           anything if the ratio of useable to offered is less than a certain fraction ...
 *                           Until the useable window reaches a certain amount, the sender should simply refuse
 *                           to send anything".
 *
 *                               - (2) (A) RFC #1122, Section 4.2.3.4 reiterates that "a TCP MUST include a SWS avoidance
 *                           algorithm in the sender".  However, "the SWS avoidance algorithm ... specified"
 *                           in RFC #1122 "is to be used instead of the sender-side algorithm contained in
 *                           [RFC #813]".
 *
 *                               - (B) (a) RFC #1122, Section 4.2.3.4 states that "the sender's SWS avoidance algorithm
 *                           is ... [to] send data" :
 *
 *                               - (1) "If a maximum-sized segment can be sent, i.e, [sic] if" :
 *
 *                               - (A) "min(D,U) >= Eff.snd.MSS"
 *                               - (1) (a) This threshold subtly assumes that the amount of data queued
 *                           on the TCP connection's transmit queue is queued in maximum-
 *                           sized segments.
 *                               - (b) Although this assumption is typically satisfied since all
 *                           new TCP transmit data is usually aggregated & appended into
 *                           the TCP connection's transmit queue in maximum-sized segments
 *                           (see 'NetTCP_TxConnAppData()  Note #6b1'); to ensure that the
 *                           maximum-sized-segment threshold is satisfied the transmit
 *                           segment's length is also checked.
 *
 *                               - (2) "Or if the data is pushed and all queued data can be sent now, i.e., if" :
 *
 *                               - (A) "[SND.NXT = SND.UNA and]" ...
 *                               - (1) "(the bracketed condition is imposed by the Nagle algorithm)"
 *                               - (a) This condition is required ONLY if the Nagle algorithm
 *                           is enabled (see Note #6b2B).
 *
 *                               - (B) "PUSHED and"             ...
 *                               - (1) See also 'NetTCP_TxConnAppData()  Note #6b3B1b'.
 *
 *                               - (C) "D <= U"
 *                               - (1) (a) This threshold subtly assumes that the amount of data queued
 *                           on the TCP connection's transmit queue is queued in maximum-
 *                           sized segments.
 *                               - (b) To ensure that the next actual transmit segment is compared
 *                           to the available transmit window, the following threshold is
 *                           actually checked :
 *
 *                               - (1) min(D, SEG.LEN) <= U
 *
 *                           See also Note #7b2Ba1A1.
 *
 *                               - (3) "Or if at least a fraction Fs of the maximum window can be sent, i.e., if" :
 *
 *                               - (A) "[SND.NXT = SND.UNA and]" ...
 *                               - (1) This condition is required ONLY if the Nagle algorithm is enabled
 *                           (see Note #6b2B).
 *
 *                               - (B) "min(D,U) >= Fs * Max(SND.WND)"
 *
 *                               - (4) "or if" :
 *
 *                               - (A) "data is PUSHed and" ...
 *                               - (1) Although it is not directly stated, it is inferred that if
 *                           the segment(s)' data is NOT pushed, the segment transmit
 *                           SHOULD be postponed until the previous transmit silly
 *                           window syndrome avoidance conditions have been satisfied
 *                           (see Notes #7b2Ba1, #7b2Ba2, & #7b2Ba3).
 *
 *                               - (2) See also 'NetTCP_TxConnAppData()  Note #6b3B1b'.
 *
 *                               - (B) "the override timeout occurs."
 *                               - (1) Although it is not directly stated, it is inferred that the
 *                           transmit silly window override timer should be set when :
 *
 *                               - (a) The previous transmit silly window syndrome avoidance
 *                           conditions have NOT been satisfied (see Notes #7b2Ba1,
 *                           #7b2Ba2, & #7b2Ba3) ...
 *                               - (b) BUT                                ...
 *                               - (1) the TCP segment data is pushed ...
 *                               - (2) & no current timeout exists.
 *
 *                               - (2) However, if NO network timer is available to delay the TCP
 *                           data segment(s), the TCP data segment(s) SHOULD be immediately
 *                           transmitted.
 *
 *                           See also Note #7b2Bb.
 *
 *                           where
 *                               - (A) D               Amount of data queued in the sending TCP but not
 *                           yet sent
 *
 *                               - (B) U              'Useable window' ... i.e., the offered window less
 *                           the amount of data sent but not acknowledged :
 *
 *                               - (1) U = SND.UNA + SND.WND - SND.NXT
 *
 *                               - (2) The 'useable window' is also constrained by the
 *                           available window & other TCP congestion controls
 *                           (see 'NetTCP_TxConnWinSizeUpdateAvail()  Note #1').
 *
 *                               - (C) Eff.snd.MSS     Effective send MSS for the connection
 *                               - (D) SND.NXT         Next sequence number to transmit
 *                               - (E) SND.UNA         Oldest unacknowledged sequence number
 *                               - (F) Max(SND.WND)    Maximum send window ... seen ... on the connection
 *                               - (G) Fs              Fraction whose recommended value is 1/2
 *
 *                               - (b) (1) Although RFC #813, Section 4 stated "that it is not necessary to set
 *                           a timer to protect against protocol lockup when postponing the send
 *                           operation"; RFC #1122, Section 4.2.3.4 amends that "to avoid a ...
 *                           deadlock, it is necessary to have a timeout to force transmission of
 *                           data, overriding the SWS avoidance algorithm".
 *
 *                               - (2) "The override timeout should be in the range 0.1 - 1.0 seconds."
 *
 *                               - (3) "In practice, this timeout should seldom occur."
 *
 * @note     (8) (a) Although it is not directly stated, it is inferred that the limitations of
 *                           the Nagle & transmit silly window syndrome avoidance algorithms apply only
 *                           to discrete, individually-queued data segments & NOT to any stream of data
 *                           segments.
 *
 *                           Therefore, a data segment -- especially the last queued data segment in the
 *                           TCP connection's transmit queue -- should NOT be constrained by the Nagle &
 *                           transmit silly window syndrome avoidance algorithms if this last queued data
 *                           segment is immediately transmitted after the transmission of the preceding
 *                           queued data segments.
 *
 *                           See also 'NetTCP_TxConnAppData()  Notes #6b1 & #6b3B2'.
 *
 *                               - (b) Also, although NO RFC specifies the Nagle algorithm's or the transmit silly
 *                           window syndrome avoidance algorithm's compliance, effect, or limitation on
 *                           TCP connection closes; it does NOT seem reasonable for the Nagle algorithm
 *                           or the transmit silly window syndrome avoidance algorithm to inhibit or
 *                           delay the transmission of a TCP connection close segment.
 *
 * @note     (9) The following TCP transmit parameters are configured once PRIOR to transmitting
 *                           any TCP segment(s) :
 *
 *                               - (a) IP transmit parameters :
 *                               - (1) TOS
 *                               - (2) TTL
 *                               - (3) Flags
 *
 *                           10) Increment network buffer's reference counter to include the TCP segment now enqueued
 *                           to the TCP connection's re-transmit queue as a new reference to the network buffer.
 *
 *                           11) (a) IP  transmit options currently NOT implemented     See 'net_tcp.c  Note #1d'
 *                               - (b) TCP transmit options currently NOT implemented     See 'net_tcp.c  Note #1c'
 *
 *                           12) To balance network receive versus transmit packet loads for certain network connection
 *                           types (e.g. stream-type connections), network receive & transmit packets SHOULD be
 *                           handled in an APPROXIMATELY balanced ratio.
 *
 *                               - (a) Network task priorities & lock mechanisms partially maintain a balanced ratio
 *                           between network receive versus transmit packet handling.
 *
 *                           However, the handling of network receive & transmit packets :
 *
 *                               - (1) SHOULD be interleaved so that for every few packet(s) received & handled,
 *                           several packet(s) should be transmitted; & vice versa.
 *
 *                               - (2) SHOULD NOT exclusively handle receive nor transmit packets, even for a
 *                           short period of time, but especially for a prolonged period of time.
 *
 *                               - (b) To implement network receive versus transmit load balancing :
 *
 *                               - (2) Certain network connections MUST periodically suspend network transmit(s)
 *                           to handle network interface(s)' receive packet(s) :
 *
 *                               - (A) Suspend network connection transmit(s) if any receive packets are
 *                           available on a network interface.
 *
 *                               - (1) To approximate a balanced ratio of network receive versus transmit
 *                           packets handled; the number of consecutive times that a network
 *                           connection transmit suspends itself to check for & handle any
 *                           network receive packet(s) SHOULD APPROXIMATELY correspond to the
 *                           number of queued receive packet(s) available.
 *
 *                               - (2) To protect TCP connections from transmit corruption while suspended,
 *                           ALL TCP data transmits & TCP transmit queue handling MUST be blocked
 *                           for suspended connections until the connection is no longer suspended.
 *
 *                               - (B) Signal or timeout network connection transmit suspend(s) to restart
 *                           transmit(s).
 *
 *                           See also 'net_if.c  NetIF_RxPktIsAvail()  Notes #1 & #2'
 *                           & 'net_if.c  NetIF_TxSuspend()     Notes #1 & #2'.
 *
 *                           13) On ANY error(s), network resources MUST be appropriately freed :
 *
 *                               - (a) For all network resources that have been linked to the TCP connection, ALL
 *                           network resources are freed by NetTCP_ConnClose().
 *
 *                           14) (a) Since segments enqueued to a TCP connection's transmit queue have already been
 *                           reported as transmitted to the application & since no mechanism exists for a TCP
 *                           connection to re-request previously transmitted data, any TCP connection whose
 *                           transmit queue(s) becomes corrupted MUST be closed to force the application layer
 *                           to abort &/or recover from the corrupted data.
 *
 *                               - (b) For any internal errors where the TCP connection's transmit queue is NOT corrupted,
 *                           the TCP connection is NOT closed.
 *
 *                           See also 'NetTCP_TxConnAppData()  Note #10'
 *                           & 'NetTCP_TxConnReTxQ()    Note #11'.
 *******************************************************************************************************/
static void NetTCP_TxConnTxQ(NET_TCP_CONN       *p_conn,
                             NET_BUF_HDR        *p_buf_hdr,
                             NET_TCP_ACK_CODE   tx_ack_code,
                             CPU_BOOLEAN        tx_q_timeout,
                             NET_TCP_CLOSE_CODE close_code,
                             CPU_BOOLEAN        tx_suspend_en,
                             RTOS_ERR           *p_err)
{
  NET_BUF     *p_seg;
  NET_BUF     *p_seg_next;
  NET_BUF     *p_buf_q_tail;
  NET_BUF_HDR *p_seg_hdr = DEF_NULL;
  NET_BUF_HDR *p_seg_next_hdr;
  NET_BUF_HDR *p_buf_q_tail_hdr;
  NET_CONN_ID conn_id;
  NET_CONN    *p_net_conn;
  NET_IF_NBR  if_nbr;
#ifdef  NET_IPv4_MODULE_EN
  NET_IPv4_ADDR  src_addrv4 = NET_IPv4_ADDR_NONE;
  NET_IPv4_ADDR  dest_addrv4 = NET_IPv4_ADDR_NONE;
  NET_IPv4_TOS   TOS;
  NET_IPv4_TTL   TTL;
  NET_IPv4_FLAGS flags_ipv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
  NET_IPv6_ADDR          src_addrv6;
  NET_IPv6_ADDR          dest_addrv6;
  NET_IPv6_TRAFFIC_CLASS traffic_class;
  NET_IPv6_FLOW_LABEL    flow_label;
  NET_IPv6_HOP_LIM       hop_lim;
  NET_IPv6_FLAGS         flags_ipv6;
#endif
  NET_TCP_PORT_NBR src_port;
  NET_TCP_PORT_NBR dest_port;
  NET_TCP_SEQ_NBR  seq_nbr;
  NET_TCP_SEQ_NBR  ack_nbr;
  NET_TCP_WIN_SIZE win_size;
  NET_TCP_WIN_SIZE tx_data_qd;
  NET_TCP_WIN_SIZE tx_data_min;
  NET_TCP_WIN_SIZE tx_th_q_min;
  NET_TCP_FLAGS    flags_tcp;
  CPU_INT32U       timeout_ms;
  CPU_BOOLEAN      tx_ack;
  CPU_BOOLEAN      tx_seg;
  CPU_BOOLEAN      tx_seg_push;
  CPU_BOOLEAN      tx_seg_close;
  CPU_BOOLEAN      tx_segs_txd;
  CPU_BOOLEAN      tx_segs = DEF_NO;
  CPU_BOOLEAN      tx_done;
  CPU_BOOLEAN      tx_nagle;
  CPU_BOOLEAN      tx_th_seg;
  CPU_BOOLEAN      tx_th_mss;
  CPU_BOOLEAN      tx_th_nagle;
  CPU_BOOLEAN      tx_th_silly_win;
  CPU_BOOLEAN      tx_tmr_free;
  CPU_BOOLEAN      net_rx_avail;
  NET_CTR          net_rx_nbr;
  NET_CTR          tx_seg_nbr;
  RTOS_ERR         local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  //                                                               -------------------- CFG TCP TX --------------------
  switch (tx_ack_code) {                                        // Cfg tx ack req.
    case NET_TCP_CONN_TX_ACK_NONE:
    default:
      tx_ack = DEF_NO;
      break;

    case NET_TCP_CONN_TX_ACK:
    case NET_TCP_CONN_TX_ACK_IMMED:
      tx_ack = DEF_YES;
      break;
  }

  //                                                               Cfg tx tmr free req.
  tx_tmr_free = (p_conn->TxQ_Head == DEF_NULL) ? DEF_YES : DEF_NO;

  switch (p_conn->ConnState) {                                  // Cfg tx Q seg(s).
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CLOSED:
          tx_segs = DEF_YES;
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_CLOSING:
        case NET_TCP_TX_Q_STATE_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
        default:
          RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
      }
      break;

    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_CLOSING:
          tx_segs = DEF_YES;
          break;

        case NET_TCP_TX_Q_STATE_CLOSED:
        case NET_TCP_TX_Q_STATE_SUSPEND:                        // See Note #12b2A2.
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
          tx_segs = DEF_NO;
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        default:
          RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
      }
      break;

    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_NONE:
    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_CLOSED:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  //                                                               ------------ TX DATA FROM TCP CONN TX Q ------------
  conn_id = p_conn->ID_Conn;
  if_nbr = NetConn_IF_NbrGet(conn_id);

  p_net_conn = &NetConn_Tbl[conn_id];
  //                                                               Prepare IP params (see Note #9a).
  switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
    case NET_SOCK_FAMILY_IP_V4:
      NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL);
      break;
#endif

#ifdef  NET_IPv6_MODULE_EN
    case NET_SOCK_FAMILY_IP_V6:
      NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6);
      break;
#endif

    default:
      break;
  }

  p_seg_next = p_conn->TxQ_Head;

  tx_done = (tx_segs == DEF_YES) ? DEF_NO : DEF_YES;
  tx_segs_txd = DEF_NO;
  tx_seg_nbr = 0u;

  while (tx_done == DEF_NO) {                                   // Tx ALL TCP conn tx Q seg(s) ...
                                                                // ... allowed by cong ctrls (see Note #1b1).
    tx_seg = DEF_NO;

    p_seg = p_seg_next;
    if (p_seg != DEF_NULL) {
      p_seg_hdr = &p_seg->Hdr;
      p_seg_next = p_seg_hdr->NextPrimListPtr;
      //                                                           ------------------- CTRL TCP TX --------------------
      //                                                           Validate tx win cong th's :                  ...
      if (p_conn->TxWinSizeAvail >= p_seg_hdr->TCP_SegLenData) {       // ...chk avail tx win >= seg len (see Note #5),
        tx_seg = DEF_YES;
        //                                                         ... chk prev'ly tx'd  seg(s) [see Note #8a]; ...
        //                                                         ... or TCP conn close seg    [see Note #8b]; ...
        tx_seg_close = DEF_BIT_IS_SET(p_seg_hdr->TCP_Flags, NET_TCP_FLAG_TX_CLOSE);
        tx_th_seg = ((tx_segs_txd == DEF_YES)
                     || (tx_seg_close == DEF_YES)) ? DEF_OK : DEF_FAIL;

        if (tx_th_seg != DEF_OK) {
          NET_BUF_SIZE buf_size;

          buf_size = NetBuf_GetMaxSize(if_nbr, NET_TRANSACTION_TX, p_seg, p_seg_hdr->DataIx);
          if (buf_size == p_seg_hdr->DataLen) {                 // If the buffer is full then send it.
            tx_th_mss = DEF_YES;
          } else {
            //                                                     ... chk MSS       th (see Note #7b2Ba1);     ...
            tx_data_qd = p_conn->TxSeqNbrNextQ - p_conn->TxSeqNbrNext;
            tx_data_min = DEF_MIN(tx_data_qd, p_seg_hdr->TCP_SegLenData);
            tx_th_q_min = DEF_MIN(tx_data_min, p_conn->TxWinSizeAvail);

            tx_th_mss = (tx_th_q_min >= p_conn->MaxSegSizeConn) ? DEF_OK : DEF_FAIL;
          }

          if (tx_th_mss != DEF_OK) {
            //                                                     ... chk Nagle     th (see Note #7b2Ba2);     ...
            tx_seg_push = DEF_BIT_IS_SET(p_seg_hdr->TCP_Flags, NET_TCP_FLAG_TX_PUSH);
            tx_nagle = ((p_conn->TxWinSizeNagleEn == DEF_DISABLED)
                        || (p_conn->TxSeqNbrNext == p_conn->TxSeqNbrUnAckd)) ? DEF_YES : DEF_NO;
            tx_th_nagle = ((tx_nagle == DEF_YES)
                           && (tx_seg_push == DEF_YES)
                           && (tx_data_min <= p_conn->TxWinSizeAvail)) ? DEF_OK : DEF_FAIL;

            if (tx_th_nagle != DEF_OK) {
              //                                                   ... chk silly win th (see Note #7b2Ba3);     ...
              tx_th_silly_win = ((tx_nagle == DEF_YES)
                                 && (tx_th_q_min >= p_conn->TxWinSizeMinTh)) ? DEF_OK : DEF_FAIL;

              if (tx_th_silly_win != DEF_OK) {
                //                                                 ... chk push timeout (see Note #7b2Ba4).
                if (tx_seg_push == DEF_YES) {                   // If data seg pushed   (see Note #7b2Ba4A),    ...
                  if (tx_q_timeout == DEF_NO) {                   // ... & no cur timeout (see Note #7b2Ba4B1b2), ...
                                                                  // ... & tx Q tmr NOT yet cfg'd,                ...
                    if (p_conn->TxQ_SillyWinTmr == DEF_NULL) {
                      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

                      timeout_ms = p_conn->TxWinSillyWinTimeout_ms;
                      p_conn->TxQ_SillyWinTmr = NetTmr_Get(NetTCP_TxConnTxQ_TimeoutSillyWin,
                                                           p_conn,
                                                           timeout_ms,
                                                           NET_TMR_OPT_NONE,
                                                           &local_err);
                      //                                           ... & tx Q tmr avail,                        ...
                      if (RTOS_ERR_CODE_GET(local_err) == RTOS_ERR_NONE) {
                        tx_seg = DEF_NO;                        // ... dly  tx seg (see Note #7b2Ba4B1);        ...
                      }                                         // ... else tx seg (see Note #7b2Ba4B2).
                    } else {                                    // Else  tx Q tmr already cfg'd, ...
                      tx_seg = DEF_NO;                          // ... dly  tx seg (see Note #7b2Ba4B1).
                    }
                  }
                } else {                                        // If data seg NOT pushed, ...
                  tx_seg = DEF_NO;                              // ... dly tx seg (see Note #7b2Ba4A1).
                }
              }
            }
          }
        }
      }
    }

    //                                                             ------------------- TX TCP SEGS --------------------
    if (tx_seg == DEF_YES) {                                    // If avail & rdy, tx Q seg(s).
                                                                // UPDATE TCP CONN TX Q's
                                                                // Move seg from tx Q to re-tx Q :

      if (p_seg_next != DEF_NULL) {                             // If tx Q next seg(s) avail, ...
                                                                // ... update TCP conn tx Q.
        p_seg_next_hdr = &p_seg_next->Hdr;
        p_seg_next_hdr->PrevPrimListPtr = DEF_NULL;
        p_conn->TxQ_Head = p_seg_next;
      } else {                                                  // Else clr tx Q.
        p_conn->TxQ_Head = DEF_NULL;
        p_conn->TxQ_Tail = DEF_NULL;

        tx_tmr_free = DEF_YES;
      }

      p_seg_hdr->PrevPrimListPtr = p_conn->ReTxQ_Tail;
      p_seg_hdr->NextPrimListPtr = DEF_NULL;

      if (p_conn->ReTxQ_Tail != DEF_NULL) {                     // If re-tx Q NOT empty, ...
                                                                // ... append seg(s) @ Q tail (see Note #4b1).
        p_buf_q_tail = p_conn->ReTxQ_Tail;
        p_buf_q_tail_hdr = &p_buf_q_tail->Hdr;
        p_buf_q_tail_hdr->NextPrimListPtr = p_seg;

        p_conn->ReTxQ_Tail = p_seg;
      } else {                                                  // Else add seg to empty re-tx Q.
        p_conn->ReTxQ_Head = p_seg;
        p_conn->ReTxQ_Tail = p_seg;
      }

      if (p_conn->ReTxQ_Tmr == DEF_NULL) {                      // If unavail, get & update re-tx Q tmr.
        NetTCP_TxConnReTxQ_TimeoutSet(p_conn, DEF_NO, close_code, p_err);
        if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
          goto exit;
        }
      }

      //                                                           ----------------- UPDATE TCP CONN ------------------
      //                                                           Update TCP conn tx seq nbr(s).
      p_conn->TxSeqNbrNext += p_seg_hdr->TCP_SegLen;

      //                                                           Update TCP conn tx win ctrls.
      NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn,
                                          DEF_NULL,
                                          NET_TCP_CONN_RX_ACK_NONE,
                                          p_seg_hdr->TCP_SegLenData,
                                          NET_TCP_CONN_TX_WIN_DEC,
                                          p_err);
      if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
        goto exit;
      }

      //                                                           ----------- PREPARE TCP TX DATA/ACK SEG ------------
      //                                                           Prepare TCP seg addrs.

      switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
        case NET_SOCK_FAMILY_IP_V4:
          src_addrv4 = p_seg_hdr->IP_AddrSrc;
          dest_addrv4 = p_seg_hdr->IP_AddrDest;
          break;
#endif

#ifdef  NET_IPv6_MODULE_EN
        case NET_SOCK_FAMILY_IP_V6:
          src_addrv6 = p_seg_hdr->IPv6_AddrSrc;
          dest_addrv6 = p_seg_hdr->IPv6_AddrDest;
          DEF_BIT_SET(p_seg_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);
          break;
#endif
        default:
          RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
      }

      src_port = p_seg_hdr->TransportPortSrc;
      dest_port = p_seg_hdr->TransportPortDest;

      //                                                           Prepare TCP seq nbrs.
      seq_nbr = p_seg_hdr->TCP_SeqNbr;
      ack_nbr = p_conn->RxSeqNbrNext;

      //                                                           Prepare TCP tx flags.
      flags_tcp = p_seg_hdr->TCP_Flags;

      //                                                           Prepare TCP win size.
      win_size = p_conn->RxWinSizeActual;

      //                                                           Prepare IP params (see Note #9a).

      switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
        case NET_SOCK_FAMILY_IP_V4:
          NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL);
          break;
#endif

#ifdef  NET_IPv6_MODULE_EN
        case NET_SOCK_FAMILY_IP_V6:
          NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6);
          break;
#endif

        default:
          RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
      }

      //                                                           Update TCP tx buf ctrls.
      p_seg_hdr->TCP_SeqNbrLast = seq_nbr;
      p_seg_hdr->TCP_AckNbrLast = ack_nbr;
      p_seg_hdr->TCP_SegLenLast = p_seg_hdr->TCP_SegLen;
      p_seg_hdr->TCP_WinSizeLast = win_size;

      p_seg_hdr->TCP_SegReTxCtr = 0u;
      p_seg_hdr->RefCtr++;                                      // TCP maintains ref until seg ack'd (see Note #10).

      //                                                           --------------- TX TCP DATA/ACK SEG ----------------
      if (DEF_BIT_IS_CLR(p_seg_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

        NetTCP_TxPktHandlerIPv4(p_seg,
                                src_addrv4,
                                src_port,
                                dest_addrv4,
                                dest_port,
                                seq_nbr,
                                ack_nbr,
                                win_size,
                                TOS,
                                TTL,
                                flags_tcp,
                                flags_ipv4,
                                DEF_NULL,
                                DEF_NULL,                       // See Note #9b.
                                &local_err);                    // Ignore transitory tx err(s).
#endif
      } else {
#ifdef  NET_IPv6_MODULE_EN
        RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

        NetTCP_TxPktHandlerIPv6(p_seg,
                                &src_addrv6,
                                src_port,
                                &dest_addrv6,
                                dest_port,
                                seq_nbr,
                                ack_nbr,
                                win_size,
                                traffic_class,
                                flow_label,
                                hop_lim,
                                flags_tcp,
                                DEF_NULL,                       // See Note #9b.
                                &local_err);
#endif
      }

      switch (RTOS_ERR_CODE_GET(local_err)) {
        case RTOS_ERR_NONE:                                     // If NO tx err(s);         ...
          tx_segs_txd = DEF_YES;                                // ... indicate seg(s) tx'd ...
          tx_seg_nbr++;                                         // ... & inc tx ctrs.
          NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnTxQ_Ctr);
          break;

        case RTOS_ERR_NET_IF_LINK_DOWN:                         // Else indicate tx done.
          p_seg_hdr->RefCtr--;
          tx_done = DEF_YES;
          break;

        default:
          p_seg_hdr->RefCtr--;
          NetTCP_ConnClose(p_conn, p_buf_hdr, p_conn->ConnCloseAppFlag, close_code);
          RTOS_ERR_SET(*p_err, RTOS_ERR_CODE_GET(local_err));
          goto exit;
      }
    } else {                                                    // Else if seg NOT tx'd, ...
      tx_done = DEF_YES;                                        // ... indicate tx done.
    }

    //                                                             ------------------ SUSPEND TCP TX ------------------
    if ((tx_suspend_en == DEF_YES)
        && (tx_done == DEF_NO)                                  // If tx NOT done &                            ..
        && (tx_seg_nbr > 1)) {                                  // .. tx'd > 1 seg,                            ..
      net_rx_nbr = 0u;
      net_rx_avail = NetIF_RxPktIsAvail(if_nbr, net_rx_nbr);
      if (net_rx_avail == DEF_YES) {                            // .. & rx pkt(s) avail;                       ..
        switch (p_conn->TxQ_State) {                            // .. set TCP conn tx Q state to SUSPEND,      ..
          case NET_TCP_TX_Q_STATE_CONN:
          case NET_TCP_TX_Q_STATE_SUSPEND:
            p_conn->TxQ_State = NET_TCP_TX_Q_STATE_SUSPEND;
            break;

          case NET_TCP_TX_Q_STATE_CLOSING:
          case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
            p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSING_SUSPEND;
            break;

          case NET_TCP_TX_Q_STATE_CLOSED:
          case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
            p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSED_SUSPEND;
            break;

          case NET_TCP_TX_Q_STATE_NONE:
          default:
            RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
        }

        Net_GlobalLockRelease();
        do {
          NetIF_TxSuspend(if_nbr);                              // .. & suspend TCP tx       (see Note #12b2A) ..

          net_rx_nbr++;
          net_rx_avail = NetIF_RxPktIsAvail(if_nbr, net_rx_nbr);
        } while (net_rx_avail == DEF_YES);                      // .. while     net rx avail (see Note #12b2A1).

        Net_GlobalLockAcquire((void *)NetTCP_TxConnTxQ);

        switch (p_conn->TxQ_State) {                            // Restore TCP conn tx Q state.
          case NET_TCP_TX_Q_STATE_SUSPEND:
            p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CONN;
            break;

          case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
            p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSING;
            break;

          case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
            p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSED;
            break;

          case NET_TCP_TX_Q_STATE_CLOSED:                       // If prev'ly CLOSED, don't re-close TCP conn.
            RTOS_ERR_SET(*p_err, RTOS_ERR_TX);
            goto exit;

          case NET_TCP_TX_Q_STATE_CLOSING:
            break;

          case NET_TCP_TX_Q_STATE_NONE:
          case NET_TCP_TX_Q_STATE_CONN:
          default:
            RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
        }
      }
    }
  }

  //                                                               ----------------- COMPLETE TCP TX ------------------
  if (tx_segs_txd != DEF_YES) {                                 // If NO   tx Q seg(s) tx'd, ...
    if (tx_ack == DEF_YES) {                                    // ... but tx ack req'd;     ...
                                                                // ... tx TCP conn ack (see Note #1c1).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);
      (void)NetTCP_TxConnAck(p_conn, p_buf_hdr, tx_ack_code, close_code, &local_err);
    }
  } else {                                                      // Else if ANY tx Q seg(s) tx'd;         ..
    NetTCP_TxConnTxQ_TimeoutIdleClr(p_conn);                    // .. clr tx Q idle tmr (see Note #1c2), ..
    NetTCP_TxConnAckDlyReset(p_conn, DEF_YES);                  // .. reset ack dly ctrls,               ..
    tx_tmr_free = DEF_YES;                                      // .. free tx Q tmr.
  }

  if (tx_tmr_free == DEF_YES) {                                 // If free tx Q tmr req'd, ..
    if (p_conn->TxQ_SillyWinTmr != DEF_NULL) {                  // .. &    tx Q tmr avail, ..
      if (tx_q_timeout == DEF_NO) {                             // .. & NOT timed out,     ..
                                                                // .. free tx Q tmr.
        NetTmr_Free(p_conn->TxQ_SillyWinTmr);
      }
      p_conn->TxQ_SillyWinTmr = DEF_NULL;
    }
  }

  RTOS_ERR_SET(*p_err, RTOS_ERR_CODE_GET(local_err));

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnTxQ_TimeoutIdle()
 *
 * @brief    (1) (a) Handle TCP connection's transmit queue idle timeout ... :
 *
 *               - (1) Clear TCP connection's transmit idle timer                      See Notes #4a1A & #4a2
 *               - (2) Reset TCP connection's transmit congestion window controls      See Note  #2a
 *               - (3) Reset TCP connection's transmit round-trip time   controls      See Note  #2b
 *
 *           - (b) ... for the following states :
 *
 *               - (1) ESTABLISHED
 *               - (2) FIN-WAIT-1
 *               - (3) CLOSING
 *               - (4) CLOSE-WAIT
 *               - (5) LAST-ACK
 *
 *
 * Argument(s) : p_conn_timeout       Pointer to TCP connection (see Note #3b).
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) (a) RFC #2581, Section 4.1 states that "after TCP has been idle for a relatively long period
 *                       of time ... use slow start to restart transmission" :
 *
 *                       (1) (A) "When TCP has not received a segment for more than one retransmission timeout," ...
 *                           (B) "cwnd is reduced to the value of the restart window."
 *
 *                       (2) However, RFC #2581, Section 4.1 re-states that "using the last time a segment was
 *                           received to determine whether or not to decrease cwnd fails to deflate cwnd in the
 *                           common case of persistent ... connections ... The reception of [segments] makes the
 *                           test for an idle connection fail, and allows the TCP to begin transmission with a
 *                           possibly inappropriately large cwnd."
 *
 *                               - (A) "Therefore, ... if the TCP has not sent data ... in an interval exceeding the
 *                           retransmission timeout" ...
 *
 *                               - (B) "a TCP SHOULD set cwnd to no more than RW before beginning transmission."
 *
 *                           See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Note #2e1'.
 *
 *                               - (b) Similarly, although NO RFC specifies that a TCP connection's RTT average & deviation
 *                           should be reset following a TCP transmit idle timeout; it seems reasonable to reset a
 *                           TCP connection's RTT average & deviation controls whenever a TCP connection's transmit
 *                           is idle for a period exceeding the re-transmit timeout.
 *
 *                           See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a4A2'.
 *
 * @note     (3) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
 *                           type functions -- even though network timer API functions cast callback functions
 *                           to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
 *
 *                               - (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
 *                           to an object ... may be converted to a pointer to a different object ...
 *                           [but] if the resulting pointer is not correctly aligned ... the behavior
 *                           is undefined".
 *
 *                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
 *                           pointer arguments, network timer callback functions MUST avoid incorrect
 *                           pointer conversion behavior between 'void' pointer parameters & non-'void'
 *                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
 *
 *                               - (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
 *                           to or from a pointer to any ... object ... A pointer to any ... object ...
 *                           may be converted to a pointer to void and back again; the result shall
 *                           compare equal to the original pointer".
 *
 *                               - (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
 *                           network object pointer objects, network timer callback functions MUST :
 *
 *                               - (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
 *                               - (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
 *                               - (A) in this case, a 'NET_TCP_CONN' pointer.
 *
 *                           See also 'net_tmr.c  NetTmr_Get()  Note #3'.
 *
 * @note     (4) This function is a network timer callback function :
 *
 *                               - (a) (1) For the following connection timer(s) ... :
 *
 *                               - (A) TCP connection transmit queue idle timer ('TxQ_IdleTmr')
 *
 *                               - (2) (A) Clear the timer pointer ... :
 *                               - (1) Cleared prior to next handler function(s); ...
 *                               - (2) Cleared prior to invalid state fault exit.
 *
 *                               - (B) but do NOT re-free the timer.
 *
 *                               - (b) Do NOT set the following close timer flag(s) :
 *
 *                               - (1) NET_TCP_CONN_CLOSE_TMR_TX_IDLE
 *
 * @note     (5) Certain network connections MUST periodically suspend network transmit(s) to handle
 *                           network receive packet(s).  To protect TCP connections from transmit corruption while
 *                           suspended, ALL TCP data transmits & TCP transmit queue handling MUST be blocked for
 *                           suspended connections until the connection is no longer suspended.
 *
 *                           However, handling the TCP connection's transmit queue idle timeout is permitted since
 *                           NO new TCP data is prepared from the TCP connection's transmit queue (see Note #1a).
 *******************************************************************************************************/
static void NetTCP_TxConnTxQ_TimeoutIdle(void *p_conn_timeout)
{
  NET_TCP_CLOSE_CODE close_code;
  NET_TCP_CONN       *p_conn;
  RTOS_ERR           local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  p_conn = (NET_TCP_CONN *)p_conn_timeout;                      // See Note #3b2A.

  close_code = NET_TCP_CONN_CLOSE_ALL;
  //                                                               See Note #4b1.
  DEF_BIT_CLR(close_code, (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_TMR_TX_IDLE);

  p_conn->TxQ_IdleTmr = DEF_NULL;                               // Clr tx Q idle tmr  (see Note #4a2A1).

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      p_conn->TxQ_IdleTmr = DEF_NULL;                           // See Note #4a2A2.
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      goto exit;

    case NET_TCP_CONN_STATE_CONN:                               // See Note #1.
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_SUSPEND:                        // See Note #5.
        case NET_TCP_TX_Q_STATE_CLOSING:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CLOSED:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        default:
          p_conn->TxQ_IdleTmr = DEF_NULL;                       // See Note #4a2A2.
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, close_code);
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  //                                                               -------- HANDLE TCP CONN TX Q IDLE TIMEOUT ---------
  //                                                               Reset tx win ctrls (see Note #2a2B).
  NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn,
                                      DEF_NULL,
                                      NET_TCP_CONN_RX_ACK_NONE,
                                      0u,
                                      NET_TCP_CONN_TX_WIN_RESET,
                                      &local_err);

  //                                                               Reset RTT ctrls (see Note #2b).
  NetTCP_TxConnRTT_RTO_Calc(p_conn, NET_TCP_CONN_TX_RTT_RESET, NET_TCP_TX_RTT_NONE, NET_TCP_TX_RTT_NONE);

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnTxQ_TimeoutIdleSet()
 *
 * @brief    (1) Start TCP connection's transmit queue idle timeout for the following states :
 *
 *           - (a) SYN-RECEIVED
 *           - (b) SYN-SENT
 *           - (c) ESTABLISHED
 *           - (d) FIN-WAIT-1
 *           - (e) CLOSING
 *           - (f) CLOSE-WAIT
 *           - (g) LAST-ACK
 *
 *
 * Argument(s) : p_conn       Pointer to a TCP connection.
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) (a) RFC #2581, Section 4.1 states that "after TCP has been idle for a relatively long period
 *                       of time ... use slow start to restart transmission" :
 *
 *                       (1) "If the TCP has not sent data in an interval exceeding the retransmission timeout" ...
 *                       (2) "cwnd is reduced to ... no more than ... the value of the restart window."
 *
 *                       See also 'NetTCP_TxConnTxQ_TimeoutIdle()  Note #2a'.
 *
 *                   (b) However, if NO network timer is available to time the transmit queue idle interval, the
 *                       TCP connection SHOULD be immediately slow started.
 *******************************************************************************************************/
static void NetTCP_TxConnTxQ_TimeoutIdleSet(NET_TCP_CONN *p_conn)
{
  CPU_INT32U timeout_ms;
  RTOS_ERR   local_err;

  //                                                               ---------------- VALIDATE TCP CONN -----------------
  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      return;

    case NET_TCP_CONN_STATE_SYNC_RXD:                           // See Note #1a.
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:                           // See Note #1b.
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CLOSED:
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSING:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        default:
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_CONN:                               // See Note #1c.
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSING:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CLOSED:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        default:
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  //                                                               ----------- START TCP CONN TX Q IDLE TMR -----------
  timeout_ms = p_conn->TxRTT_RTO_ms;                            // Tx Q idle timeout = RTO (see Note #2a1).
  if (p_conn->TxQ_IdleTmr == DEF_NULL) {                        // If       tx Q idle tmr NOT avail, ...
                                                                // ...  get tx Q idle tmr.
    RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

    p_conn->TxQ_IdleTmr = NetTmr_Get(NetTCP_TxConnTxQ_TimeoutIdle,
                                     p_conn,
                                     timeout_ms,
                                     NET_TMR_OPT_NONE,
                                     &local_err);
    if (RTOS_ERR_CODE_GET(local_err) != RTOS_ERR_NONE) {            // If any err(s), ...
                                                                    // ... reset tx win ctrls (see Note #2b).
      RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

      NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn,
                                          DEF_NULL,
                                          NET_TCP_CONN_RX_ACK_NONE,
                                          0u,
                                          NET_TCP_CONN_TX_WIN_RESET,
                                          &local_err);
    }
  } else {                                                      // Else set tx Q idle tmr.
    NetTmr_Set(p_conn->TxQ_IdleTmr,
               NetTCP_TxConnTxQ_TimeoutIdle,
               timeout_ms);
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnTxQ_TimeoutIdleClr()
 *
 * @brief    (1) Clear TCP connection's transmit queue idle timer for the following states :
 *
 *           - (a) ESTABLISHED
 *           - (b) FIN-WAIT-1
 *           - (c) CLOSING
 *           - (d) CLOSE-WAIT
 *           - (e) LAST-ACK
 *
 *
 * Argument(s) : p_conn      Pointer to a TCP connection.
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) (a) RFC #2581, Section 4.1 states that "after TCP has been idle for a relatively long period
 *                       of time ... use slow start to restart transmission" :
 *
 *                       (1) "If the TCP has not sent data in an interval exceeding the retransmission timeout" ...
 *                       (2) "cwnd is reduced to ... no more than ... the value of the restart window."
 *
 *                       See also 'NetTCP_TxConnTxQ_TimeoutIdle()  Note #2a'.
 *
 *                   (b) (1) However, if the TCP connection's re-transmit queue is NOT empty, then TCP data has
 *                           has been transmitted & is awaiting acknowledgement.
 *
 *                       (2) Therefore, NO transmit queue idle timeout is currently needed.
 *******************************************************************************************************/
static void NetTCP_TxConnTxQ_TimeoutIdleClr(NET_TCP_CONN *p_conn)
{
  CPU_BOOLEAN tmr_free;

  //                                                               ---------------- VALIDATE TCP CONN -----------------
  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      goto exit;

    case NET_TCP_CONN_STATE_CONN:                               // See Note #1.
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSING:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CLOSED:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        default:
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  //                                                               ------------ CLR TCP CONN TX Q IDLE TMR ------------
  tmr_free = (p_conn->ReTxQ_Head != DEF_NULL) ? DEF_YES : DEF_NO;

  if (tmr_free == DEF_YES) {                                    // If re-tx Q NOT empty   (see Note #2b1), ...
    if (p_conn->TxQ_IdleTmr != DEF_NULL) {
      NetTmr_Free(p_conn->TxQ_IdleTmr);                         // ... free tx Q idle tmr (see Note #2b2).
      p_conn->TxQ_IdleTmr = DEF_NULL;
    }
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                   NetTCP_TxConnTxQ_TimeoutSillyWin()
 *
 * @brief    (1) (a) Handle TCP connection's transmit queue silly window timeout ... :
 *
 *               - (1) Clear    TCP connection's transmit silly window persist timer   See Notes #4a1A & #4a2
 *               - (2) Transmit TCP connection's transmit data                         See Note  #2
 *
 *           - (b) ... for the following states :
 *
 *               - (1) ESTABLISHED
 *               - (2) FIN-WAIT-1
 *               - (3) CLOSING
 *               - (4) CLOSE-WAIT
 *               - (5) LAST-ACK
 *
 *
 * Argument(s) : p_conn_timeout       Pointer to TCP connection (see Note #3b).
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) RFC #1122, Section 4.2.3.4 states that on "timeout ... force transmission of data,
 *                   overriding the SWS avoidance algorithm".
 *
 *                   See also 'NetTCP_TxConnTxQ()  Note #7b2Bb'.
 *
 *               (3) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
 *                   type functions -- even though network timer API functions cast callback functions
 *                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
 *
 *                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
 *                           to an object ... may be converted to a pointer to a different object ...
 *                           [but] if the resulting pointer is not correctly aligned ... the behavior
 *                           is undefined".
 *
 *                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
 *                           pointer arguments, network timer callback functions MUST avoid incorrect
 *                           pointer conversion behavior between 'void' pointer parameters & non-'void'
 *                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
 *
 *                               - (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
 *                           to or from a pointer to any ... object ... A pointer to any ... object ...
 *                           may be converted to a pointer to void and back again; the result shall
 *                           compare equal to the original pointer".
 *
 *                               - (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
 *                           network object pointer objects, network timer callback functions MUST :
 *
 *                               - (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
 *                               - (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
 *                               - (A) in this case, a 'NET_TCP_CONN' pointer.
 *
 *                           See also 'net_tmr.c  NetTmr_Get()  Note #3'.
 *
 * @note     (4) This function is a network timer callback function :
 *
 *                               - (a) (1) For the following connection timer(s) ... :
 *
 *                               - (A) TCP connection transmit silly window persist timer ('TxQ_SillyWinTmr')
 *
 *                               - (2) (A) Clear the timer pointer ... :
 *                               - (1) Cleared prior to next handler function(s); ...
 *                               - (2) Cleared prior to invalid state fault exit.
 *
 *                               - (B) but do NOT re-free the timer.
 *
 *                               - (b) Do NOT set the following close timer flag(s) :
 *
 *                               - (1) NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN
 *
 * @note     (5) Certain network connections MUST periodically suspend network transmit(s) to handle
 *                           network receive packet(s).  To protect TCP connections from transmit corruption while
 *                           suspended, ALL TCP data transmits & TCP transmit queue handling MUST be blocked for
 *                           suspended connections until the connection is no longer suspended.
 *
 *                               - (a) The transmit queue silly window timeout is reconfigured with one timer tick to
 *                           ensure that a non-zero delay is implemented.
 *
 *                               - (b) If NO timer is available, a TCP connection will NOT be able to re-schedule the
 *                           transmission of its TCP transmit queue data.  Thus the TCP transmit queue data
 *                           will be delayed until triggered by any received acknowledgement packets or by
 *                           additional data transmits from the applications layer.
 *
 *                           See also 'NetTCP_TxConnTxQ()                    Note #12b2A2',
 *                           'NetTCP_TxConnTxQ_TimeoutIdle()        Note #5',
 *                           'NetTCP_TxConnReTxQ_Timeout()          Note #5',
 *                           & 'NetTCP_TxConnWinSizeZeroWinTimeout()  Note #5'.
 *******************************************************************************************************/
static void NetTCP_TxConnTxQ_TimeoutSillyWin(void *p_conn_timeout)
{
  NET_TCP_CONN       *p_conn;
  NET_TCP_CLOSE_CODE close_code;
  CPU_INT32U         timeout_ms;
  RTOS_ERR           local_err;

  p_conn = (NET_TCP_CONN *)p_conn_timeout;                      // See Note #3b2A.

  close_code = NET_TCP_CONN_CLOSE_ALL;
  //                                                               See Note #4b1.
  DEF_BIT_CLR(close_code, (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN);

  p_conn->TxQ_SillyWinTmr = DEF_NULL;                           // Clr tx Q silly win tmr (see Note #4a2A1).

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      p_conn->TxQ_SillyWinTmr = DEF_NULL;                       // See Note #4a2A2.
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      goto exit;

    case NET_TCP_CONN_STATE_CONN:                               // See Note #1.
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_CLOSING:
          break;

        case NET_TCP_TX_Q_STATE_SUSPEND:                        // See Note #5.
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
          RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

          timeout_ms = 0u;                                      // See Note #5a.
          p_conn->TxQ_SillyWinTmr = NetTmr_Get(NetTCP_TxConnTxQ_TimeoutSillyWin,
                                               p_conn,
                                               timeout_ms,
                                               NET_TMR_OPT_NONE,
                                               &local_err);
          PP_UNUSED_PARAM(local_err);                           // Ignore transitory rsrc err(s) [see Note #5b].
          goto exit;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CLOSED:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        default:
          p_conn->TxQ_SillyWinTmr = DEF_NULL;                   // See Note #4a2A2.
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, close_code);
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  //                                                               ------ HANDLE TCP CONN TX Q SILL WIN TIMEOUT -------
  NetTCP_TxConnTxQ(p_conn,                                      // Tx Q data          (see Note #2).
                   DEF_NULL,
                   NET_TCP_CONN_TX_ACK_NONE,
                   DEF_YES,
                   close_code,
                   DEF_NO,
                   &local_err);                                 // Ignore ALL tx err(s), transitory or fatal.

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnReTxQ()
 *
 * @brief    (1) Re-transmit  TCP data segment(s) from TCP connection re-transmit queue :
 *
 *           - (a) Validate TCP connection re-transmit :
 *               - (1) Validate re-transmit segment available
 *               - (2) Validate re-transmit segment threshold                          See Note #3
 *
 *           - (b) Update TCP connection :
 *               - (1) Update     TCP connection's re-transmit queue timeout :
 *                   - (A) Update TCP connection's re-transmit queue timer             See Note #2b
 *                   - (B) Reset  TCP connection's    transmit round-trip time         See Note #2b2A2
 *                               controls
 *               - (2) Update     TCP connection's    transmit congestion controls :
 *                   - (A) Update TCP connection's transmit congestion window          See Note #5
 *                   - (B) Reset  TCP connection's delayed acknowledgement controls    See Note #6
 *
 *           - (c) Prepare TCP segment re-transmit :
 *               - (1) Prepare unchanged TCP segment for re-transmit                   See Note #7
 *
 *               - (2) Prepare updated   TCP segment for re-transmit :
 *                   - (A) TCP segment   sequence numbers
 *                   - (B) TCP segment   window size
 *                   - (C) TCP segment   addresses
 *                   - (D) TCP segment   transmit flags
 *                   - (E) IP  datagram  parameters
 *                   - (F) Update TCP    segment's last transmit values :
 *                       - (1) Sequence        Number
 *                       - (2) Acknowledgement Number
 *                       - (3) Segment Length
 *                       - (4) Window  Size
 *                   - (G) Unlink TCP segment packet buffer from any other network layer(s)
 *                   - (H) Update TCP segment packet buffer controls
 *
 *           - (d) Re-transmit TCP segment                                             See Note #2a
 *
 * @param    p_conn              Pointer to a TCP connection.
 *
 * @param    re_tx_q_timeout     Indicate whether the TCP connection re-transmit queue timed out :
 *                               DEF_NO                      TCP connection re-transmit queue did
 *                               NOT time  out.
 *                               DEF_YES                     TCP connection re-transmit queue
 *                               timed out.
 *
 * @param    close_code          Select which close action(s) to perform; bit-field flags logically OR'd :
 *                               NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
 *                               NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
 *                               NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
 *                               NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
 *                               NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
 *                               NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
 *                               NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
 *                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *
 * @param    p_err               Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : RETRANSMISSION TIMEOUT'
 *                               states that "for any state if the retransmission timeout expires on a segment in
 *                               the retransmission queue" :
 *
 *                                   - (A) RFC #1122, Section 4.2.3.1 reiterates that "retransmission of SYN segments
 *                               SHOULD use the same algorithm as data segments".
 *
 *                                   - (a) "Send the segment at the front of the retransmission queue."
 *
 *                                   - (A) RFC #2988, Section 5.4 reiterates that "when the retransmission timer
 *                               expires ... retransmit the earliest segment that has not been acknowledged
 *                               by the TCP receiver".
 *
 *                                   - (1) RFC #1122, Section 4.2.2.16 states that "a TCP receiver SHOULD NOT shrink the
 *                               window ... However, a sending TCP MUST be robust against window shrinking ...
 *                               If this happens, the sender SHOULD NOT send new data, but SHOULD retransmit
 *                               normally the old unacknowledged data between SND.UNA and SND.UNA+SND.WND.  The
 *                               sender MAY also retransmit old data beyond SND.UNA+SND.WND, but SHOULD NOT time
 *                               out the connection if data beyond the right window edge is not acknowledged".
 *
 *                               Therefore, ALL data segments previously transmitted & awaiting acknowledgement
 *                               in a TCP connections' re-transmit queue may be re-transmitted regardless of the
 *                               TCP connection's current transmit congestion control window size or the remote
 *                               host's receive window size.
 *
 *                                   - (2) (A) RFC #2581, Section 3.2 states that "the fast retransmit algorithm uses the
 *                               arrival of 3 duplicate ACKs ... as an indication that a segment has been
 *                               lost ... [and] performs a retransmission of what appears to be the missing
 *                               segment".
 *
 *                                   - (B) RFC #1122, Section 4.2.2.21 reiterates that "'fast retransmit' ... uses the
 *                               redundant ACK's to deduce that a segment has been lost ... If more than a
 *                               threshold number of such ACK's is received, then the segment containing the
 *                               octets starting at SEG.ACK is assumed to have been lost and is retransmitted".
 *
 *                                   - (b) "Reinitialize the retransmission timer."
 *
 *                                   - (1) RFC #2988, Section 5 states that "an implementation MUST manage the retransmission
 *                               timer(s) in such a way that a segment is never retransmitted too early, i.e. less
 *                               than one RTO after the previous transmission of that segment".
 *
 *                                   - (A) "The following is the RECOMMENDED algorithm for managing the retransmission
 *                               timer" :
 *
 *                                   - (1) "Every time a packet containing data is sent (including a retransmission),
 *                               if the timer is not running, start it running so that it will expire after
 *                               RTO seconds (for the current value of RTO)."
 *
 *                               Therefore, the TCP connection re-transmit queue timer is reset whenever a
 *                               segment is re-transmitted.
 *
 *                                   - (2) "When all outstanding data has been acknowledged, turn off the retransmission
 *                               timer."
 *
 *                                   - (3) "When an ACK is received that acknowledges new data, restart the retransmission
 *                               timer so that it will expire after RTO seconds (for the current value of RTO)."
 *
 *                                   - (B) "When the retransmission timer expires, do the following" :
 *
 *                                   - (5) "The host MUST set RTO <- RTO * 2 ('back off the timer')."
 *
 *                               See also Note #2b2A1.
 *
 *                                   - (6) "Start the retransmission timer, such that it expires after RTO seconds
 *                               (for the value of RTO after the doubling operation)."
 *
 *                                   - (2) (A) (1) RFC #1122, Section 4.2.3.1 reiterates that an "implementation MUST also
 *                               include 'exponential backoff' for successive RTO values for the same
 *                               segment".
 *
 *                                   - (a) RFC #2988, Section 5.5 states that "when the retransmission timer
 *                               expires ... the host MUST set RTO <- RTO * 2 ('back off the timer')".
 *
 *                               Thus the TCP retransmission timer exponential back-off scalar
 *                               value is 2.
 *
 *                                   - (b) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2,
 *                               Page 299 reiterates that "this doubling is called an 'exponential
 *                               backoff'".
 *
 *                               See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2b2'.
 *
 *                                   - (2) RFC #2988, Section 5 adds "that a TCP implementation MAY clear SRTT [TCP
 *                               smoothed round-trip time] and RTTVAR [TCP round-trip time variance] after
 *                               backing off the timer multiple times as it is likely that the current SRTT
 *                               and RTTVAR are bogus in this situation.  Once SRTT and RTTVAR are cleared
 *                               they should be initialized with the next RTT sample taken".
 *
 *                               See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a4A1'.
 *
 *                                   - (B) (1) (a) RFC #2581, Section 3.2 states that "after receiving 3 duplicate ACKs
 *                               ... the fast retransmit algorithm ... performs a retransmission of
 *                               what appears to be the missing segment, without waiting for the
 *                               retransmission timer to expire".
 *
 *                                   - (b) RFC #1122, Section 4.2.2.21 reiterates that with "'fast retransmit' ...
 *                               the [lost] segment ... is retransmitted, without awaiting a timeout".
 *
 *                                   - (2) If a segment is re-transmitted due to the TCP fast re-transmit algorithm
 *                               & NOT due to the TCP connection's re-transmit queue timer expiring, the
 *                               TCP connection's re-transmit queue timer is :
 *
 *                                   - (a) NOT backed-off because the re-transmit queue        See Note #2b2B1
 *                               timer did NOT expire
 *                                   - (b) Restarted with its current RTO value                See Note #2b1A1
 *
 *                                   - (C) A TCP connection's RTO timeout controls do NOT need to be explicitly reset
 *                               since RFC #2988, Section 5 states that "once a new RTT measurement is obtained
 *                               (which can only happen when new data has been sent and acknowledged), the
 *                               computations ... of RTO ... are performed ... which may result in 'collapsing'
 *                               RTO back down after it has been subject to exponential backoff".
 *
 *                               See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a4B'.
 *
 * @note     (3) RFC #1122, Section 4.2.3.5 states that "excessive retransmission of the same segment
 *                               by TCP indicates some failure of the remote host or the Internet path ... The following
 *                               procedure MUST be used to handle excessive retransmissions of data segments" :
 *
 *                                   - (c) "When the number of transmissions of the same segment reaches a threshold ...
 *                               close the connection."
 *
 *                               See also 'NetTCP_RxPktConnHandlerReTxQ()  Note #7'.
 *
 * @note     (4) RFC #2988, Section 3 states that "TCP MUST use Karn's algorithm ... for taking RTT samples.
 *                               That is, RTT samples MUST NOT be made using segments that were retransmitted (and thus for
 *                               which it is ambiguous whether the reply was for the first instance of the packet or a later
 *                               instance)".
 *
 *                                   - (a) To ensure implementation of Karn's algorithm, while ANY re-transmitted segment(s)
 *                               remain unacknowledged in a TCP connection's re-transmit queue :
 *
 *                                   - (1) (A) NO RTT calculations are performed; ...                      See Note #4
 *
 *                                   - (B) The TCP connection's re-transmit timeout :
 *                                   - (1) MAY be backed-off ...                                   See Note  #2b1B5
 *                               OR
 *                                   - (2) MAY be latched at a previously backed-off value;        See Notes #2b2B2 & #2b2C
 *                               BUT
 *                                   - (3) MUST NOT be updated by RTT calculations.                See Note  #4a1A
 *
 *                                   - (2) Each time a TCP connection re-transmits a segment, the TCP connection advances
 *                               its un-re-transmitted sequence number to the TCP connection's next sequence
 *                               number to transmit.  This ensures that NO RTT or RTO calculations are performed
 *                               until ALL re-transmitted data is acknowledged & removed from the TCP connection's
 *                               re-transmit queue.
 *
 * @note     (5) RFC #2581, Section 3.1 states that "when a TCP sender detects segment loss using the
 *                               retransmission timer, the value of ssthresh [TCP transmit congestion control slow start
 *                               threshold] ... [and] cwnd [TCP transmit congestion control window] MUST be set".
 *
 *                               See also 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Notes #2c2A5a & #2c2A5b'.
 *
 * @note     (6) A TCP connection's delayed acknowledgement controls :
 *
 *                                   - (a) SHOULD be reset whenever a TCP connection re-transmits data segment(s) since
 *                               any re-transmit always transmits an accompanying acknowledgement;
 *                                   - (b) MAY    be reset whenever a TCP connection re-transmits a connection request
 *                               segment since NO delayed acknowledgement controls should be active.
 *
 *                               See also 'NetTCP_TxConnAckDlyReset()  Note #1'.
 *
 * @note     (7) RFC #1122, Section 4.2.2.15 states that "if a retransmitted packet is identical to the
 *                               original packet (which implies not only that the data boundaries have not changed, but
 *                               also that the window and acknowledgment fields of the header have not changed), then
 *                               the same IP Identification field MAY be used".
 *
 *                               In other words, if the following TCP segment header values are unchanged since the
 *                               last transmission of the TCP segment, then the TCP segment may be transmitted without
 *                               re-calculation of the TCP header :
 *
 *                                   - (a) Sequence        Number
 *                                   - (b) Acknowledgement Number
 *                                   - (c) Segment Length
 *                                   - (d) Window  Size
 *
 * @note     (8) (a) Some network interfaces require a minimum packet size & may also require that
 *                               packets smaller than the minimum packet size be appended with trailing pad
 *                               octets.  Therefore, all network transmit packets MUST be prepared to satisfy
 *                               a possible network interface minimum packet size requirement.
 *
 *                                   - (b) To ensure that TCP re-transmit segments will be properly prepared to satisfy
 *                               a network interface minimum packet size requirement, the following equations
 *                               are used to validate a TCP re-transmit segment size :
 *
 *                                   - (A) (1) TCP Re-transmit Segment Size  =  Segment's Re-transmit Protocol Header Sizes +
 *                               Segment's Remaining   Segment  Data   Size
 *
 *                                   - (2)                               =  Segment's Previous    Protocol Header Sizes +
 *                               Segment's Remaining   Segment  Data   Size
 *
 *                                   - (3)                               = (Segment's Previous    Total    Packet Size  -
 *                               Segment's Previous             Data   Size) +
 *                               Segment's Remaining   Segment  Data   Size
 *
 *                                   - (B) (1) TCP Re-transmit Minimum Segment Size         =  Network Interface Minimum Packet Size
 *
 *                                   - (2) [(Segment's          Total   Packet Size  -
 *                               Segment's                  Data   Size) +
 *                               Segment's Minimum  Segment Data   Size ]   =  Network Interface Minimum Packet Size
 *
 *                                   - (3)   Segment's Minimum  Segment Data   Size     =  Network Interface Minimum Packet Size  -
 *                               (Segment's         Total   Packet Size  -
 *                               Segment's                 Data   Size)
 *
 *                                   - (1) Equation #8bA2 subtly assumes that the TCP re-transmit segment's network
 *                               protocol header sizes equal the segment's previously transmitted network
 *                               protocol header sizes.  In other words, it is assumed that a TCP transmit
 *                               segment's network protocol header sizes will remain constant for the
 *                               segment's initial transmission & any subsequent retransmissions.
 *
 *                               This assumption is true if & only if the TCP segment is re-transmitted
 *                               with no changes in any of the segment's network protocol header sizes,
 *                               which typically vary only for changes in the network protocol header
 *                               types or in the number of network protocol header options.
 *
 *                               However, since TCP segments that have already been transmitted can
 *                               NOT modify their segment data (see 'NetTCP_TxConnAppData()  Note #10a'),
 *                               it seems reasonable that TCP segments that have already been transmitted
 *                               will NOT likely modify their network protocol header types & SHOULD NOT
 *                               modify their network protocol header options.
 *
 *                               Therefore, it seems reasonable that TCP segments that have already
 *                               been transmitted will NOT likely vary their network protocol header sizes.
 *                               Thus TCP segments may validate their re-transmit segment size versus any
 *                               possible network interface minimum packet size requirement based on their
 *                               previously transmitted network protocol header & packet sizes.
 *
 *                                   - (2) (A) Equation #8bB calculates a TCP re-transmit segment's minimum data size
 *                               as required by a possible network interface minimum packet size.  If
 *                               the TCP re-transmit segment's data size is smaller than the network
 *                               interface minimum packet size, the network buffer MUST be checked for
 *                               sufficient & available trailing octets, as required by the network
 *                               interface layer to append pad octets.
 *
 *                                   - (B) (1) (a) (1) If the TCP re-transmit segment's minimum data size is smaller
 *                               than the required network interface minimum packet size ...
 *                               AND
 *                                   - (2) there is insufficient network buffer octets available for
 *                               the network interface layer to append pad octets, ...
 *
 *                                   - (b) then the TCP segment's remaining data octets MUST be moved to
 *                               the network buffer's transmit index to provide sufficient
 *                               network buffer data octets for the network interface layer to
 *                               append pad octets.
 *
 *                                   - (2) A network interface that appends cleared trailing pad octets MAY be
 *                               optimized to skip clearing the trailing pad octets if the network
 *                               buffer's memory clear flag is set.  Since a partially-acknowledged
 *                               TCP segment's network buffer contains previously acknowledged data
 *                               octets, the network buffer's memory clear flag MUST be cleared to
 *                               ensure that the network interface layer clears the trailing pad
 *                               octets.
 *
 * @note     (9) If a packet buffer's unlink function is available, it is assumed that the function ...
 *
 *                                   - (a) Correctly unlinks the packet buffer from any other network protocol layers
 *                               AND
 *                                   - (b) Correctly updates the network buffer's reference counter to decrement the
 *                               number of network protocol layers that no longer maintain a reference to
 *                               the packet buffer.
 *                               AND
 *                                   - (c) Clears both the unlink function & object pointers.
 *
 *                               10) Increment network buffer's reference counter to include the TCP segment STILL enqueued
 *                               to the TCP connection's re-transmit queue as a reference to the network buffer.
 *
 *                               11) (a) Since segments enqueued to a TCP connection's transmit queue have already been
 *                               reported as transmitted to the application & since no mechanism exists for a TCP
 *                               connection to re-request previously transmitted data, any TCP connection whose
 *                               transmit queue(s) becomes corrupted MUST be closed to force the application layer
 *                               to abort &/or recover from the corrupted data.
 *
 *                                   - (b) For any internal errors where the TCP connection's transmit queue is NOT corrupted,
 *                               the TCP connection is NOT closed.
 *
 *                               See also 'NetTCP_TxConnAppData()  Note #10'
 *                               & 'NetTCP_TxConnTxQ()      Note #14'.
 *******************************************************************************************************/
static void NetTCP_TxConnReTxQ(NET_TCP_CONN       *p_conn,
                               CPU_BOOLEAN        re_tx_q_timeout,
                               NET_TCP_CLOSE_CODE close_code,
                               RTOS_ERR           *p_err)
{
#ifdef  NET_IPv4_MODULE_EN
  NET_IPv4_ADDR  src_addrv4 = NET_IPv4_ADDR_NONE;
  NET_IPv4_ADDR  dest_addrv4 = NET_IPv4_ADDR_NONE;
  NET_IPv4_TOS   TOS;
  NET_IPv4_TTL   TTL;
  NET_IPv4_FLAGS flags_ipv4;
#endif
#ifdef  NET_IPv6_MODULE_EN
  NET_IPv6_ADDR          src_addrv6;
  NET_IPv6_ADDR          dest_addrv6;
  NET_IPv6_TRAFFIC_CLASS traffic_class;
  NET_IPv6_FLOW_LABEL    flow_label;
  NET_IPv6_HOP_LIM       hop_lim;
  NET_IPv6_FLAGS         flags_ipv6;
#endif
  NET_BUF           *p_seg;
  NET_BUF_HDR       *p_seg_hdr;
  NET_BUF_FNCT      unlink_fnct;
  NET_CONN_ID       conn_id;
  NET_CONN          *p_net_conn;
  NET_IF_NBR        if_nbr;
  NET_TCP_PORT_NBR  src_port;
  NET_TCP_PORT_NBR  dest_port;
  NET_TCP_SEQ_NBR   seq_nbr;
  NET_TCP_SEQ_NBR   ack_nbr;
  NET_TCP_SEG_SIZE  seg_len;
  NET_TCP_WIN_SIZE  win_size;
  NET_BUF_SIZE      min_pkt_size;
  NET_BUF_SIZE      seg_len_tot;
  NET_BUF_SIZE      seg_len_hdr;
  NET_BUF_SIZE      seg_len_data_min;
  NET_BUF_SIZE      buf_size_max;
  NET_BUF_SIZE      data_ix_cur;
  NET_BUF_SIZE      data_ix_re_tx;
  NET_BUF_SIZE      data_len_cur;
  NET_TCP_FLAGS     flags_tcp;
  CPU_INT08U        *pdata_re_tx;
  CPU_BOOLEAN       seg_chngd;
  CPU_BOOLEAN       seg_updated;
  CPU_BOOLEAN       seg_data_moved;
  CPU_BOOLEAN       tx_lock;
  NET_PROTOCOL_TYPE proto_type = NET_PROTOCOL_TYPE_NONE;
  RTOS_ERR          local_err;

  //                                                               ----------------- VALIDATE RE-TX Q -----------------
  if (p_conn->ReTxQ_Head == DEF_NULL) {
    goto exit;
  }

  p_seg = p_conn->ReTxQ_Head;                                   // Re-tx seg @ head of re-tx Q (see Note #2a).
  p_seg_hdr = &p_seg->Hdr;

  p_seg_hdr->TCP_SegReTxCtr++;
  if (p_seg_hdr->TCP_SegReTxCtr > p_conn->TxSegReTxTh) {        // If nbr re-tx's > th, close TCP conn (see Note #3).
    NetTCP_ConnClose(p_conn,
                     DEF_NULL,
                     p_conn->ConnCloseAppFlag,
                     close_code);
    RTOS_ERR_SET(*p_err, RTOS_ERR_NET_RETRY_MAX);
    goto exit;
  }

  //                                                               ----------------- UPDATE TCP CONN ------------------
  if (re_tx_q_timeout != DEF_NO) {                              // If           re-tx Q timeout,                  ...
                                                                // ... back-off re-tx Q timeout (see Note #2b1B5) ...
    NetTCP_TxConnRTT_RTO_Calc(p_conn, NET_TCP_CONN_TX_RTO_BACKOFF, NET_TCP_TX_RTT_NONE, NET_TCP_TX_RTT_NONE);
#if 0                                                           // Implemented with backoff     (see Note #2b2A2).
                                                                // ... & reset RTT ctrls        (see Note #2b2A2).
    NetTCP_TxConnRTT_RTO_Calc(p_conn, NET_TCP_CONN_TX_RTT_RESET, NET_TCP_TX_RTT_NONE, NET_TCP_TX_RTT_NONE);
#endif
  }
  //                                                               Update re-tx Q tmr (see Note #2b1A1).
  NetTCP_TxConnReTxQ_TimeoutSet(p_conn, re_tx_q_timeout, close_code, p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit;
  }
  //                                                               Adv   un-re-tx'd seq(s) to ...
  p_conn->TxSeqNbrUnReTxd = p_conn->TxSeqNbrNext;               // ... not-yet-tx'd seq(s) [see Note #4a2].

  if (re_tx_q_timeout != DEF_NO) {                              // If re-tx Q timeout, ...
                                                                // ... update tx cong win  (see Note #5).
    RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

    NetTCP_TxConnWinSizeHandlerCongCtrl(p_conn,
                                        DEF_NULL,
                                        NET_TCP_CONN_RX_ACK_NONE,
                                        0u,
                                        NET_TCP_CONN_TX_WIN_TIMEOUT,
                                        &local_err);
    PP_UNUSED_PARAM(local_err);                                 // Ignore err(s).
  }

  NetTCP_TxConnAckDlyReset(p_conn, DEF_YES);                    // Reset ack dly ctrls (see Note #6).

  //                                                               ------------- CHK RE-TX SEG'S TX LOCK --------------
  tx_lock = DEF_BIT_IS_SET(p_seg_hdr->Flags, NET_BUF_FLAG_TX_LOCK);
  if (tx_lock == DEF_YES) {                                     // If buf tx locked, CANNOT cur'ly re-tx seg.
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ReTxBufLock_Ctr);
    goto exit;
  }

  //                                                               -------------- PREPARE TCP RE-TX SEG ---------------
  //                                                               Prepare TCP seq nbrs.
  seq_nbr = p_seg_hdr->TCP_SeqNbr;
  ack_nbr = p_conn->RxSeqNbrNext;

  seg_len = p_seg_hdr->TCP_SegLen;
  //                                                               Prepare TCP win size.
  win_size = p_conn->RxWinSizeActual;

  //                                                               Chk for re-tx seg update (see Note #7).
  seg_updated = ((p_seg_hdr->TCP_SeqNbrLast != seq_nbr)
                 || (p_seg_hdr->TCP_AckNbrLast != ack_nbr)
                 || (p_seg_hdr->TCP_SegLenLast != seg_len)
                 || (p_seg_hdr->TCP_WinSizeLast != win_size)) ? DEF_YES : DEF_NO;

  seg_data_moved = DEF_NO;
  seg_len_tot = (NET_BUF_SIZE)p_seg_hdr->TotLen                 // Seg cur tot len = prev'ly tx'd/ack'd pkt tot  len
                - (NET_BUF_SIZE)p_seg_hdr->DataLen              // ...               prev'ly tx'd/ack'd pkt data len +
                + (NET_BUF_SIZE)p_seg_hdr->TCP_SegLenData;      // ...               rem'ing            seg data len
                                                                // ... (see Note #8bA).

  conn_id = p_conn->ID_Conn;
  if_nbr = NetConn_IF_NbrGet(conn_id);

  min_pkt_size = NetIF_GetPktSizeMin(if_nbr);

  if (seg_len_tot < min_pkt_size) {                             // If TCP re-tx seg tot len                         ...
                                                                // ...    < min IF pkt size (see Note #8b2B1a2),    ...
                                                                // ... calc min IF seg data len (see Note #8bB);    ...
    seg_len_hdr = p_seg_hdr->TotLen - p_seg_hdr->DataLen;
    seg_len_data_min = min_pkt_size     - seg_len_hdr;

    buf_size_max = NetBuf_GetMaxSize(if_nbr,
                                     NET_TRANSACTION_TX,
                                     p_seg,
                                     p_seg_hdr->DataIx);

    if (seg_len_data_min > buf_size_max) {                      // ... & if min IF seg data len                     ...
                                                                // ...    > max buf size       (see Note #8b2B1a2), ...
      data_ix_cur = (NET_BUF_SIZE) p_seg_hdr->DataIx;

#if 0
      data_ix_re_tx = (NET_BUF_SIZE) NET_BUF_DATA_IX_TX;
#else
      p_net_conn = &NetConn_Tbl[conn_id];

      switch (p_net_conn->Family) {
        case NET_SOCK_PROTOCOL_FAMILY_IP_V4:
          proto_type = NET_PROTOCOL_TYPE_TCP_V4;
          break;

        case NET_SOCK_PROTOCOL_FAMILY_IP_V6:
          proto_type = NET_PROTOCOL_TYPE_TCP_V6;
          break;
      }

      data_ix_re_tx = 0u;

      NetTCP_GetTxDataIx(if_nbr,
                         proto_type,
                         0u,
                         p_seg_hdr->DataLen,
                         p_conn,
                         &data_ix_re_tx);
#endif
      data_len_cur = (NET_BUF_SIZE) p_seg_hdr->TCP_SegLenData;
      pdata_re_tx = (CPU_INT08U *)&p_seg->DataPtr[data_ix_re_tx];

      NetBuf_DataRd(p_seg,                                      // ... rd rem'ing TCP seg data                      ...
                    data_ix_cur,
                    data_len_cur,
                    pdata_re_tx);                               // ... & move to base re-tx ix (see Note #8b2B1b).
                                                                // MUST clr buf mem clr flag (see Note #8b2B2).
      DEF_BIT_CLR(p_seg_hdr->Flags, (NET_BUF_FLAGS)NET_BUF_FLAG_CLR_MEM);

      seg_data_moved = DEF_YES;
    }
  }

  seg_chngd = ((seg_updated != DEF_NO)
               || (seg_data_moved != DEF_NO)) ? DEF_YES : DEF_NO;

  if (seg_chngd != DEF_NO) {                                    // If chng'd, prepare seg for re-tx (see Note #1c2).
                                                                // Prepare TCP seg addrs.
    if (DEF_BIT_IS_CLR(p_seg_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
      src_addrv4 = p_seg_hdr->IP_AddrSrc;
      dest_addrv4 = p_seg_hdr->IP_AddrDest;
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
      src_addrv6 = p_seg_hdr->IPv6_AddrSrc;
      dest_addrv6 = p_seg_hdr->IPv6_AddrDest;
#endif
    }

    src_port = (NET_TCP_PORT_NBR)p_seg_hdr->TransportPortSrc;
    dest_port = (NET_TCP_PORT_NBR)p_seg_hdr->TransportPortDest;

    //                                                             Prepare TCP tx flags.
    flags_tcp = p_seg_hdr->TCP_Flags;

    //                                                             Prepare IP params.
    if (DEF_BIT_IS_CLR(p_seg_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
      NetConn_IPv4TxParamsGet(conn_id, &flags_ipv4, &TOS, &TTL);
#endif
    } else {
#ifdef  NET_IPv6_MODULE_EN
      NetConn_IPv6TxParamsGet(conn_id, &traffic_class, &flow_label, &hop_lim, &flags_ipv6);
#endif
    }

    //                                                             Update re-tx seg's last tx ctrls (see Note #1c2F).
    p_seg_hdr->TCP_SeqNbrLast = seq_nbr;
    p_seg_hdr->TCP_AckNbrLast = ack_nbr;
    p_seg_hdr->TCP_SegLenLast = seg_len;
    p_seg_hdr->TCP_WinSizeLast = win_size;

    //                                                             Reset protocol & tot len for re-tx.
    p_seg_hdr->TotLen = p_seg_hdr->DataLen;
  }

  unlink_fnct = p_seg_hdr->UnlinkFnctPtr;
  if (unlink_fnct != DEF_NULL) {                                // If unlink fnct avail, ..
    unlink_fnct(p_seg);                                         // .. unlink seg from other layer(s) [see Note #9].
  }

  if (p_seg_hdr->RefCtr <= 1) {
    p_seg_hdr->RefCtr++;                                        // TCP STILL maintains ref to seg    (see Note #10).
  }

  //                                                               ---------------- RE-TX TCP CONN SEG ----------------

  if (DEF_BIT_IS_CLR(p_seg_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
    p_seg_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V4;
    p_seg_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V4;

    if (seg_chngd == DEF_NO) {                                  // If unchng'd,                               ...
      NetIPv4_ReTx(p_seg, p_err);                               // ...      re-tx unchng'd seg (see Note #7); ...
    } else {                                                    // ... else re-tx updated  seg.
      NetTCP_TxPktHandlerIPv4(p_seg,
                              src_addrv4,
                              src_port,
                              dest_addrv4,
                              dest_port,
                              seq_nbr,
                              ack_nbr,
                              win_size,
                              TOS,
                              TTL,
                              flags_tcp,
                              flags_ipv4,
                              DEF_NULL,
                              DEF_NULL,
                              p_err);
    }
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    p_seg_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V6;
    p_seg_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V6;
    if (seg_chngd == DEF_NO) {                                  // If unchng'd,                               ...
      NetIPv6_ReTx(p_seg, p_err);                               // ...      re-tx unchng'd seg (see Note #7); ...
    } else {                                                    // ... else re-tx updated  seg.
      NetTCP_TxPktHandlerIPv6(p_seg,
                              &src_addrv6,
                              src_port,
                              &dest_addrv6,
                              dest_port,
                              seq_nbr,
                              ack_nbr,
                              win_size,
                              traffic_class,
                              flow_label,
                              hop_lim,
                              flags_tcp,
                              DEF_NULL,
                              p_err);
    }
#endif
  }

  switch (RTOS_ERR_CODE_GET(*p_err)) {
    case RTOS_ERR_NONE:
      break;

    case RTOS_ERR_NET_IF_LINK_DOWN:                             // Ignore transitory tx err(s).
      p_seg_hdr->RefCtr--;
      goto exit;

    default:                                                    // See Note #11a.
      p_seg_hdr->RefCtr--;
      NetTCP_ConnClose(p_conn,
                       DEF_NULL,
                       p_conn->ConnCloseAppFlag,
                       close_code);
      goto exit;
  }

  NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegConnReTxQ_Ctr);

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnReTxQ_Timeout()
 *
 * @brief    (1) (a) Handle TCP connection re-transmit queue timeout ... :
 *
 *               - (1) Clear  TCP connection's re-transmit timer                   See Notes #4a1A & #4a2
 *               - (2) Handle TCP connection   re-transmit                         See Note  #2
 *
 *           - (b) (1) ... unconditionally for the following synchronization states :
 *
 *                   - (A) SYN-RECEIVED
 *                   - (B) SYN-SENT
 *
 *               - (2) ... but for the following connected states only when the TCP connection
 *                           transmit queue is NOT closed  :
 *
 *                   - (A) ESTABLISHED
 *                   - (B) FIN-WAIT-1
 *                   - (C) CLOSING
 *                   - (D) CLOSE-WAIT
 *                   - (E) LAST-ACK
 *
 *
 * Argument(s) : p_conn_timeout       Pointer to TCP connection to perform re-transmit (see Note #3b).
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : RETRANSMISSION TIMEOUT'
 *                   states that "if the retransmission timeout expires ... send the segment at the
 *                   front of the retransmission queue ... [and] reinitialize the retransmission timer".
 *
 *                   See also 'NetTCP_TxConnReTxQ()  Note #2'.
 *
 *               (3) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
 *                   type functions -- even though network timer API functions cast callback functions
 *                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
 *
 *                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
 *                           to an object ... may be converted to a pointer to a different object ...
 *                           [but] if the resulting pointer is not correctly aligned ... the behavior
 *                           is undefined".
 *
 *                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
 *                           pointer arguments, network timer callback functions MUST avoid incorrect
 *                           pointer conversion behavior between 'void' pointer parameters & non-'void'
 *                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
 *
 *                               - (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
 *                           to or from a pointer to any ... object ... A pointer to any ... object ...
 *                           may be converted to a pointer to void and back again; the result shall
 *                           compare equal to the original pointer".
 *
 *                               - (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
 *                           network object pointer objects, network timer callback functions MUST :
 *
 *                               - (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
 *                               - (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
 *                               - (A) in this case, a 'NET_TCP_CONN' pointer.
 *
 *                           See also 'net_tmr.c  NetTmr_Get()  Note #3'.
 *
 * @note     (4) This function is a network timer callback function :
 *
 *                               - (a) (1) For the following connection timer(s) ... :
 *
 *                               - (A) TCP connection re-transmit queue timer ('ReTxQ_Tmr')
 *
 *                               - (2) (A) Clear the timer pointer ... :
 *                               - (1) Cleared prior to next handler function(s); ...
 *                               - (2) Cleared prior to invalid state fault exit.
 *
 *                               - (B) but do NOT re-free the timer.
 *
 *                               - (b) Do NOT set the following close timer flag(s) :
 *
 *                               - (1) NET_TCP_CONN_CLOSE_TMR_RE_TX
 *
 * @note     (5) Certain network connections MUST periodically suspend network transmit(s) to handle
 *                           network receive packet(s).  To protect TCP connections from transmit corruption while
 *                           suspended, ALL TCP data transmits & TCP transmit queue handling MUST be blocked for
 *                           suspended connections until the connection is no longer suspended.
 *
 *                           However, handling the TCP connection's re-transmit timeout is permitted since NO new
 *                           TCP data is prepared from the TCP connection's transmit queue (see Note #1a).
 *
 *                           See also 'NetTCP_TxConnTxQ()                    Note #12b2A2',
 *                           'NetTCP_TxConnTxQ_TimeoutIdle()        Note #5',
 *                           'NetTCP_TxConnTxQ_TimeoutSillyWin()    Note #5',
 *                           & 'NetTCP_TxConnWinSizeZeroWinTimeout()  Note #5'.
 *******************************************************************************************************/
static void NetTCP_TxConnReTxQ_Timeout(void *p_conn_timeout)
{
  NET_TCP_CONN       *p_conn;
  NET_TCP_CLOSE_CODE close_code;
  RTOS_ERR           local_err;

  p_conn = (NET_TCP_CONN *)p_conn_timeout;                      // See Note #3b2A.

  close_code = NET_TCP_CONN_CLOSE_ALL;
  //                                                               See Note #4b1.
  DEF_BIT_CLR(close_code, (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_TMR_RE_TX);

  p_conn->ReTxQ_Tmr = DEF_NULL;                                 // Clr    re-tx Q tmr (see Note #4a2A1).

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      goto exit;

    case NET_TCP_CONN_STATE_SYNC_RXD:                           // See Note #1b1.
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CLOSED:
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSING:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        default:
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_CONN:                               // See Note #1b2.
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      switch (p_conn->TxQ_State) {
        case NET_TCP_TX_Q_STATE_CONN:
        case NET_TCP_TX_Q_STATE_SUSPEND:                        // See Note #5.
        case NET_TCP_TX_Q_STATE_CLOSING:
        case NET_TCP_TX_Q_STATE_CLOSING_SUSPEND:
          break;

        case NET_TCP_TX_Q_STATE_NONE:
        case NET_TCP_TX_Q_STATE_CLOSED:
        case NET_TCP_TX_Q_STATE_CLOSED_SUSPEND:
        default:
          goto exit;
      }
      break;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, close_code);
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
      goto exit;
  }

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  //                                                               --------- HANDLE TCP CONN RE-TX Q TIMEOUT ----------
  NetTCP_TxConnReTxQ(p_conn, DEF_YES, close_code, &local_err);  // Handle re-tx Q     (see Note #2).
  PP_UNUSED_PARAM(local_err);                                   // Ignore ALL re-tx err(s), transitory or fatal.

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnReTxQ_TimeoutSet()
 *
 * @brief    (1) (a) Set TCP connection's re-transmit queue timer for the following synchronization/
 *                   connected states :
 *
 *               - (1) CLOSED
 *               - (2) LISTEN
 *               - (3) SYN-RECEIVED
 *               - (4) SYN-SENT
 *               - (5) ESTABLISHED
 *               - (6) FIN-WAIT-1
 *               - (7) CLOSING
 *               - (8) CLOSE-WAIT
 *               - (9) LAST-ACK
 *
 *                   - (A) (1) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : RETRANSMISSION
 *                           TIMEOUT' reiterates that "for any state if the retransmission timeout expires
 *                           on a segment in the retransmission queue ... reinitialize the retransmission
 *                           timer".
 *
 *           - (b) However, since a TCP connection's transmit & re-transmit queue SHOULD be closed for
 *                   the following states, it does NOT seem reasonable to set or reset a TCP connection's
 *                   re-transmit queue timer for these states :
 *
 *               - (1) FIN-WAIT-2
 *               - (2) TIME-WAIT
 *
 * @param    p_conn              Pointer to a TCP connection.
 *
 * @param    re_tx_q_timeout     Indicate whether the TCP connection re-transmit queue timed out :
 *                               DEF_NO                      TCP connection re-transmit queue did
 *                               NOT time  out.
 *                               DEF_YES                     TCP connection re-transmit queue
 *                               timed out.
 *
 * @param    close_code          Select which close action(s) to perform; bit-field flags logically OR'd :
 *                               NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
 *                               NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
 *                               NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
 *                               NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
 *                               NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
 *                               NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
 *                               NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
 *                               NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
 *                               See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *
 * @param    p_err               Pointer to variable that will receive the return error code from this function.
 *******************************************************************************************************/
static void NetTCP_TxConnReTxQ_TimeoutSet(NET_TCP_CONN       *p_conn,
                                          CPU_BOOLEAN        re_tx_q_timeout,
                                          NET_TCP_CLOSE_CODE close_code,
                                          RTOS_ERR           *p_err)
{
  CPU_INT32U timeout_ms;

  //                                                               ------------- VALIDATE TCP CONN STATE --------------
  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_FIN_WAIT_2:                         // See Note #1b.
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_STATE);
      goto exit;

    case NET_TCP_CONN_STATE_CLOSED:                             // See Note #1a.
    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
      break;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_INVALID_STATE,; );
  }

  //                                                               ------------- SET TCP CONN RE-TX Q TMR -------------
  timeout_ms = p_conn->TxRTT_RTO_ms;

  if ((p_conn->ReTxQ_Tmr != DEF_NULL)                           // If re-tx Q tmr avail  ..
      && (re_tx_q_timeout == DEF_NO)) {                         // .. but NOT timed out, ..
    NetTmr_Set(p_conn->ReTxQ_Tmr,                               // .. reset re-tx Q tmr.
               NetTCP_TxConnReTxQ_Timeout,
               timeout_ms);
  } else {                                                      // Else get re-tx Q tmr.
    p_conn->ReTxQ_Tmr = NetTmr_Get(NetTCP_TxConnReTxQ_Timeout,
                                   p_conn,
                                   timeout_ms,
                                   NET_TMR_OPT_NONE,
                                   p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn,
                       DEF_NULL,
                       p_conn->ConnCloseAppFlag,
                       close_code);
      goto exit;
    }
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnPrepareSegAddrs()
 *
 * @brief    Prepare TCP transmit segment addresses from TCP connection addresses.
 *
 * @param    p_conn          Pointer to a TCP connection.
 *
 * @param    p_src_addr      Pointer to  variable buffer that will receive the return source      address
 *
 * @param    ---------      (see Note #1), if NO error(s).
 *
 * @param    p_src_port      Pointer to  variable buffer that will receive the return source      port number
 *
 * @param    ---------      (see Note #1), if NO error(s).
 *
 * @param    src_addr_len    Size of the variable buffer that will receive the return source      address.
 *
 * @param    src_port_len    Size of the variable buffer that will receive the return source      port number.
 *
 * @param    p_dest_addr     Pointer to  variable buffer that will receive the return destination address
 *
 * @param    ----------     (see Note #1), if NO error(s).
 *
 * @param    p_dest_port     Pointer to  variable buffer that will receive the return destination port number
 *
 * @param    ----------     (see Note #1), if NO error(s).
 *
 * @param    dest_addr_len   Size of the variable buffer that will receive the return destination address.
 *
 * @param    dest_port_len   Size of the variable buffer that will receive the return destination port number.
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @note     (1) Variable buffers to receive the returned port & address values may start on any CPU address,
 *                           word-aligned or not.
 *
 *                           See also 'net_util.h  NETWORK DATA VALUE MACRO'S  Note #2b'.
 *
 * @note     (2) The 'NET_CONN_CFG_FAMILY' pre-processor 'else'-conditional code will never be compiled/linked
 *                           since 'net_conn.h' ensures that the family type configuration constant (NET_CONN_CFG_FAMILY)
 *                           is configured with an appropriate family type value (see 'net_conn.h  CONFIGURATION ERRORS').
 *                           The 'else'-conditional code is included for completeness & as an extra precaution in case
 *                           'net_conn.h' is incorrectly modified.
 *******************************************************************************************************/
static void NetTCP_TxConnPrepareSegAddrs(NET_TCP_CONN *p_conn,
                                         CPU_INT08U   *p_src_addr,
                                         CPU_INT08U   *p_src_port,
                                         CPU_INT16U   src_addr_len,
                                         CPU_INT16U   src_port_len,
                                         CPU_INT08U   *p_dest_addr,
                                         CPU_INT08U   *p_dest_port,
                                         CPU_INT16U   dest_addr_len,
                                         CPU_INT16U   dest_port_len,
                                         RTOS_ERR     *p_err)
{
  NET_CONN_ID       conn_id;
  NET_CONN          *p_net_conn;
  NET_CONN_ADDR_LEN addr_len;
  CPU_INT08U        addr_local[NET_CONN_ADDR_LEN_MAX];
  CPU_INT08U        addr_remote[NET_CONN_ADDR_LEN_MAX];

  conn_id = p_conn->ID_Conn;
  p_net_conn = &NetConn_Tbl[conn_id];

  //                                                               ---------------- VALIDATE ADDR LENS ----------------
  if (p_net_conn->Family == NET_CONN_FAMILY_IP_V4_SOCK) {
#ifdef  NET_IPv4_MODULE_EN
    RTOS_ASSERT_DBG_ERR_SET((src_addr_len == NET_CONN_ADDR_IP_V4_LEN_ADDR), *p_err, RTOS_ERR_INVALID_ARG,; );
    RTOS_ASSERT_DBG_ERR_SET((src_port_len == NET_CONN_ADDR_IP_LEN_PORT), *p_err, RTOS_ERR_INVALID_ARG,; );
    RTOS_ASSERT_DBG_ERR_SET((dest_addr_len == NET_CONN_ADDR_IP_V4_LEN_ADDR), *p_err, RTOS_ERR_INVALID_ARG,; );
    RTOS_ASSERT_DBG_ERR_SET((dest_port_len == NET_CONN_ADDR_IP_LEN_PORT), *p_err, RTOS_ERR_INVALID_ARG,; );
#else
    RTOS_DBG_FAIL_EXEC_ERR(*p_err, RTOS_ERR_NOT_AVAIL,; );
#endif
  } else if (p_net_conn->Family == NET_CONN_FAMILY_IP_V6_SOCK) {
#ifdef  NET_IPv6_MODULE_EN
    RTOS_ASSERT_DBG_ERR_SET((src_addr_len == NET_CONN_ADDR_IP_V6_LEN_ADDR), *p_err, RTOS_ERR_INVALID_ARG,; );
    RTOS_ASSERT_DBG_ERR_SET((src_port_len == NET_CONN_ADDR_IP_LEN_PORT), *p_err, RTOS_ERR_INVALID_ARG,; );
    RTOS_ASSERT_DBG_ERR_SET((dest_addr_len == NET_CONN_ADDR_IP_V6_LEN_ADDR), *p_err, RTOS_ERR_INVALID_ARG,; );
    RTOS_ASSERT_DBG_ERR_SET((dest_port_len == NET_CONN_ADDR_IP_LEN_PORT), *p_err, RTOS_ERR_INVALID_ARG,; );
#else
    RTOS_DBG_FAIL_EXEC_ERR(*p_err, RTOS_ERR_NOT_AVAIL,; );
#endif
  } else {
    //                                                             See Note #2.
    NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
    RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_ASSERT_CRITICAL_FAIL,; )
  }

  //                                                               ------------------ PREPARE ADDRS -------------------
  conn_id = p_conn->ID_Conn;

  addr_len = sizeof(addr_local);
  NetConn_AddrLocalGet(conn_id,                                 // Get local/src addr.
                       &addr_local[0],
                       &addr_len,
                       p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit;
  }

  addr_len = sizeof(addr_remote);
  NetConn_AddrRemoteGet(conn_id,                                // Get remote/dest addr.
                        &addr_remote[0],
                        &addr_len,
                        p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit;
  }

  //                                                               Prepare src/dest addrs (see Note #1).
  switch (p_net_conn->Family) {
#ifdef  NET_IPv4_MODULE_EN
    case NET_CONN_FAMILY_IP_V4_SOCK:
      //                                                           Cfg local  addr as pkt src  addr.
      NET_UTIL_VAL_COPY_GET_NET_16(p_src_port, &addr_local[NET_CONN_ADDR_IP_IX_PORT]);
      NET_UTIL_VAL_COPY_GET_NET_32(p_src_addr, &addr_local[NET_CONN_ADDR_IP_V4_IX_ADDR]);
      //                                                           Cfg remote addr as pkt dest addr.
      NET_UTIL_VAL_COPY_GET_NET_16(p_dest_port, &addr_remote[NET_CONN_ADDR_IP_IX_PORT]);
      NET_UTIL_VAL_COPY_GET_NET_32(p_dest_addr, &addr_remote[NET_CONN_ADDR_IP_V4_IX_ADDR]);
      break;
#endif
#ifdef  NET_IPv6_MODULE_EN
    case NET_CONN_FAMILY_IP_V6_SOCK:
      NET_UTIL_VAL_COPY_GET_NET_16(p_src_port, &addr_local[NET_CONN_ADDR_IP_IX_PORT]);
      Mem_Copy(p_src_addr, &addr_local[NET_CONN_ADDR_IP_V6_IX_ADDR], src_addr_len);
      //                                                           Cfg remote addr as pkt dest addr.
      NET_UTIL_VAL_COPY_GET_NET_16(p_dest_port, &addr_remote[NET_CONN_ADDR_IP_IX_PORT]);
      Mem_Copy(p_dest_addr, &addr_remote[NET_CONN_ADDR_IP_V6_IX_ADDR], dest_addr_len);
      break;
#endif
    default:
      //                                                           See Note #2.
      NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, NET_TCP_CONN_CLOSE_ALL);
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_ASSERT_CRITICAL_FAIL,; )
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnRTT_Init()
 *
 * @brief    Initialize TCP connection's transmit round-trip time (RTT) controls.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) (A) RFC #1122, Section 4.2.3.1 states that "the following values SHOULD be
 *                   used to initialize the estimation parameters for a new connection" :
 *
 *                       - (a) RTT = 0 seconds
 *
 *                   where
 *                   RTT                 Round-Trip Time
 *
 *                       - (1) Furthermore, RFC #1122, Section 4.2.3.1.(b) states that "the
 *                   smoothed variance is to be initialized to the value that will
 *                   result in" these values.
 *
 *                       - (B) However, since RFC #2988, Section 2.2 amends the RFC #1122, Section
 *                   4.2.3.1 RTT initialization; the smoothed RTT average & deviation do
 *                   NOT truly require explicit initialization.  Nonetheless, these RTT
 *                   values are initialized to conform with RFC #1122, Section 4.2.3.1.
 *******************************************************************************************************/
static void NetTCP_TxConnRTT_Init(NET_TCP_CONN *p_conn)
{
  //                                                               Init RTT     (see Note #1).
  p_conn->TxRTT_Avg_ms_scaled = NET_TCP_TX_RTT_AVG_INIT_MS_SCALED;   // Init RTT avg (see Note #1Aa).
  p_conn->TxRTT_Dev_ms_scaled = NET_TCP_TX_RTT_DEV_INIT_MS_SCALED;   // Init RTT dev (see Note #1A1).

#if 0
  NetTCP_TxConnRTT_CalcUpdate(p_conn);
#endif
}

/****************************************************************************************************//**
 *                                           NetTCP_TxConnRTT_Reset()
 *
 * @brief    Reset TCP connection's transmit round-trip time (RTT) controls.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) (a) RFC #2988, Section 5 states "that a TCP implementation MAY clear SRTT and
 *                   RTTVAR after backing off the timer multiple times as it is likely that the
 *                   current SRTT and RTTVAR are bogus in this situation.  Once SRTT and RTTVAR
 *                   are cleared they should be initialized with the next RTT sample taken".
 *
 *                       - (b) RFC #2581, Section 4.1 states that "after TCP has been idle for ... an
 *                   interval exceeding the retransmission timeout ... use slow start to
 *                   restart transmission".
 *
 *                   Similarly, although NO RFC specifies that a TCP connection's RTT average &
 *                   deviation should be reset following a TCP transmit idle timeout; it seems
 *                   reasonable to reset a TCP connection's RTT average & deviation controls
 *                   whenever a TCP connection's transmit is idle for a period exceeding the
 *                   re-transmit timeout.
 *
 *                   See also 'NetTCP_TxConnRTT_RTO_Calc()  Note #2a4A'.
 *******************************************************************************************************/
static void NetTCP_TxConnRTT_Reset(NET_TCP_CONN *p_conn)
{
  NetTCP_TxConnRTT_Init(p_conn);

  p_conn->TxRTT_RTO_State = NET_TCP_TX_RTT_RTO_STATE_RESET;
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnRTT_CalcUpdate()
 *
 * @brief    Update TCP connection's transmit round-trip time (RTT) control calculations.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) A TCP connection's transmit round-trip time controls should NOT be updated until
 *                   after the following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's transmit round-trip time average   (in scaled milliseconds)
 *                   ['TxRTT_Avg_ms_scaled']
 *
 *                       - (b) TCP connection's transmit round-trip time deviation (in scaled milliseconds)
 *                   ['TxRTT_Dev_ms_scaled']
 *******************************************************************************************************/
#if 0
static void NetTCP_TxConnRTT_CalcUpdate(NET_TCP_CONN *p_conn)
{
  p_conn->TxRTT_Avg_ms = (NET_TCP_TIMEOUT_MS)(p_conn->TxRTT_Avg_ms_scaled / NET_TCP_TX_RTT_SCALE);
  p_conn->TxRTT_Dev_ms = (NET_TCP_TIMEOUT_MS)(p_conn->TxRTT_Dev_ms_scaled / NET_TCP_TX_RTT_SCALE);
}
#endif

/****************************************************************************************************//**
 *                                           NetTCP_TxConnRTO_Init()
 *
 * @brief    (1) Initialize TCP connection's re-transmit timeout (RTO) controls :
 *
 *           - (a) Initialize RTO                                      See Note #2
 *           - (b) Configure  RTO maximum timeout                      See Note #3
 *
 *
 * Argument(s) : p_conn       Pointer to a TCP connection.
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) RFC #1122, Section 4.2.3.1 states that "the following values SHOULD be
 *                   used to initialize the estimation parameters for a new connection" :
 *
 *                       - (b) RTO = 3 seconds
 *
 *                   where
 *                   RTO                 Retransmission Timeout
 *
 *                       - (A) RFC #2988, Section 2.1 reiterates that "until a round-trip time (RTT)
 *                   measurement has been made ... the sender SHOULD set RTO <- 3 seconds".
 *
 * @note     (3) A TCP connection's re-transmit timeout controls should NOT be updated until
 *                   after the following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's maximum re-transmit timeout (in seconds)  ['TxRTT_RTO_Max_sec']
 *                   [see 'NetTCP_TxConnRTO_CfgMaxTimeout()  Note #2a']
 *******************************************************************************************************/
static void NetTCP_TxConnRTO_Init(NET_TCP_CONN *p_conn)
{
  p_conn->TxRTT_RTO_ms_scaled = NET_TCP_TX_RTT_RTO_INIT_MS_SCALED;   // Init RTO (see Note #2).

  NetTCP_TxConnRTO_CalcUpdate_ms_scaled(p_conn);

  NetTCP_TxConnRTO_CfgMaxTimeout(p_conn);                       // Cfg RTO max timeout (see Note #3).
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnRTO_CfgMaxTimeout()
 *
 * @brief    Configure TCP connection's maximum re-transmit timeout (RTO).
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) (a) RFC #2988, Section 2.4 states that "a maximum value MAY be placed on RTO provided
 *                   it is at least 60 seconds".
 *
 *                       - (b) RFC #1122, Section 4.2.3.1 states that "the recommended ... RTO ... upper bound
 *                   should be 2*MSL".
 *
 *                       - (c) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2, Page 299 states
 *                   that "the timeout value ... [has] an upper limit of 64 seconds".
 *
 * @note     (2) A TCP connection's maximum re-transmit timeouts (in scaled milliseconds or milliseconds)
 *                   should NOT be updated until after the following TCP connection control(s) have been
 *                   configured :
 *
 *                       - (a) TCP connection's maximum re-transmit timeout (in seconds)  ['TxRTT_RTO_Max_sec']
 *                   [see 'NetTCP_ConnClr()  Note #12'
 *                   & 'NetTCP_ConnCfgReTxMaxTimeout()  Note #3']
 *******************************************************************************************************/
static void NetTCP_TxConnRTO_CfgMaxTimeout(NET_TCP_CONN *p_conn)
{
  p_conn->TxRTT_RTO_Max_ms_scaled = (NET_TCP_TX_RTT_MS_SCALED)p_conn->TxRTT_RTO_Max_sec * NET_TCP_TX_RTT_MS_SCALE;
  p_conn->TxRTT_RTO_Max_ms = (NET_TCP_TIMEOUT_MS)p_conn->TxRTT_RTO_Max_sec * DEF_TIME_NBR_mS_PER_SEC;
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnRTO_CalcUpdate()
 *
 * @brief    Update TCP connection's re-transmit timeout (RTO) control calculations (see Note #1a).
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) A TCP connection's re-transmit timeout controls should NOT be updated until
 *                   after the following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's re-transmit timeout (in milliseconds)
 *                   ['TxRTT_RTO_ms']
 *******************************************************************************************************/
#if 0
static void NetTCP_TxConnRTO_CalcUpdate(NET_TCP_CONN *p_conn)
{
  p_conn->TxRTT_RTO_sec = (NET_TCP_TIMEOUT_SEC)(p_conn->TxRTT_RTO_ms / DEF_TIME_NBR_mS_PER_SEC);
}
#endif

/****************************************************************************************************//**
 *                                       NetTCP_TxConnRTO_CalcUpdate_ms()
 *
 * @brief    Update TCP connection's re-transmit timeout (RTO) control calculations for updated
 *               millisecond RTO ('TxRTT_RTO_ms') [see Note #1a].
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) A TCP connection's re-transmit timeout controls should NOT be updated until
 *                   after the following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's re-transmit timeout (in milliseconds)
 *                   ['TxRTT_RTO_ms']
 *******************************************************************************************************/
static void NetTCP_TxConnRTO_CalcUpdate_ms(NET_TCP_CONN *p_conn)
{
  p_conn->TxRTT_RTO_ms_scaled = (NET_TCP_TX_RTT_MS_SCALED)(p_conn->TxRTT_RTO_ms * NET_TCP_TX_RTT_SCALE);
#if 0
  NetTCP_TxConnRTO_CalcUpdate(p_conn);
#endif
}

/****************************************************************************************************//**
 *                                   NetTCP_TxConnRTO_CalcUpdate_ms_scaled()
 *
 * @brief    Update TCP connection's re-transmit timeout (RTO) control calculations for updated scaled
 *               millisecond RTO ('TxRTT_RTO_ms_scaled') [see Note #1a].
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) A TCP connection's re-transmit timeout controls should NOT be updated until
 *                   after the following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's re-transmit timeout (in scaled milliseconds)
 *                   ['TxRTT_RTO_ms_scaled']
 *******************************************************************************************************/
static void NetTCP_TxConnRTO_CalcUpdate_ms_scaled(NET_TCP_CONN *p_conn)
{
  p_conn->TxRTT_RTO_ms = (NET_TCP_TIMEOUT_MS)(p_conn->TxRTT_RTO_ms_scaled / NET_TCP_TX_RTT_SCALE);
#if 0
  NetTCP_TxConnRTO_CalcUpdate(p_conn);
#endif
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnRTO_CalcBackOff()
 *
 * @brief    Calculate next backed-off re-transmit timeout (RTO) value.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @param    rto_ms  Current re-transmit timeout value (in milliseconds).
 *
 * @return   Backed-off re-transmit timeout value (in milliseconds).
 *
 * @note     (1) (a) RFC #1122, Section 4.2.3.1 states that an "implementation MUST also include
 *                   'exponential backoff' for successive RTO values for the same segment".
 *
 *               - (1) RFC #2988, Section 5.5 states that "when the retransmission timer expires
 *                       ... the host MUST set RTO <- RTO * 2 ('back off the timer')".
 *
 *                       Thus the TCP retransmission timer exponential back-off scalar value is 2.
 *
 *               - (2) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2, Page 299
 *                       reiterates that "this doubling is called an 'exponential backoff'".
 *
 *           - (b) (1) RFC #2988, Section 2.4 adds that "a maximum value MAY be placed on RTO
 *                       provided it is at least 60 seconds".
 *
 *               - (2) RFC #1122, Section 4.2.3.1 states that "the recommended ... RTO ... upper
 *                       bound should be 2*MSL".
 *
 *               - (3) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2, Page 299
 *                       states that "the timeout value is doubled for each retransmission, with an
 *                       upper limit of 64 seconds".
 *
 *                   See also 'NetTCP_TxConnRTO_CfgMaxTimeout()  Note #1'.
 *
 * @note     (2) RFC #1122, Section 4.2.2.17 states that "zero-window probe[s] ... SHOULD increase
 *               exponentially the interval between successive probes ... Exponential backoff is
 *               recommended ... similar to ... the retransmission algorithm, and it may be possible
 *               to combine the two procedures in the implementation".
 *
 *               See also 'NetTCP_TxConnWinSizeZeroWinHandler()  Note #1b2'.
 *******************************************************************************************************/
static NET_TCP_TIMEOUT_MS NetTCP_TxConnRTO_CalcBackOff(NET_TCP_CONN       *p_conn,
                                                       NET_TCP_TIMEOUT_MS rto_ms)
{
  NET_TCP_TIMEOUT_MS rto_ms_backoff_calcd;
  NET_TCP_TIMEOUT_MS rto_ms_backoff;

  //                                                               Calc  backed-off RTO timeout val (see Note #1a).
  rto_ms_backoff_calcd = (rto_ms < p_conn->TxRTT_RTO_Max_ms)
                         ? (rto_ms * NET_TCP_TX_RTO_TIMEOUT_BACKOFF_SCALAR)
                         :  p_conn->TxRTT_RTO_Max_ms;
  //                                                               Limit backed-off RTO timeout val (see Note #1b).
  rto_ms_backoff = DEF_MIN(rto_ms_backoff_calcd, p_conn->TxRTT_RTO_Max_ms);

  return (rto_ms_backoff);
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnRTT_RTO_Init()
 *
 * @brief    Initialize TCP connection's transmit round-trip time (RTT) & re-transmit timeout (RTO) values.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) A TCP connection's re-transmit timeout controls should NOT be updated until
 *                   after the following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's maximum re-transmit timeout (in seconds)  ['TxRTT_RTO_Max_sec']
 *                   [see 'NetTCP_TxConnRTO_Init()  Note #3']
 *******************************************************************************************************/
static void NetTCP_TxConnRTT_RTO_Init(NET_TCP_CONN *p_conn)
{
  NetTCP_TxConnRTT_Init(p_conn);
  NetTCP_TxConnRTO_Init(p_conn);

  p_conn->TxRTT_RTO_State = NET_TCP_TX_RTT_RTO_STATE_INIT;
}

/****************************************************************************************************//**
 *                                       NetTCP_TxConnRTT_RTO_Calc()
 *
 * @brief    (1) Calculate TCP connection's transmit round-trip time (RTT) & re-transmit timeout (RTO) values :
 *
 *           - (a) Perform requested RTT/RTO calculation operation(s)
 *           - (b) Prepare & perform RTT     calculations
 *           - (c) Prepare & perform RTO     calculations
 *
 * @param    p_conn          Pointer to a TCP connection.
 *
 * @param    calc_code       Indicate which TCP connection transmit round-trip time (RTT) & re-transmit
 *                           timeout (RTO) calculations to perform (see Note #1a) :
 *                           NET_TCP_CONN_TX_RTT_RTO_INIT    Initialize TCP connection's RTT & RTO controls
 *                           (see 'NetTCP_TxConnRTT_Init()  Note #1'
 *                           & 'NetTCP_TxConnRTO_Init()  Note #2').
 *                           NET_TCP_CONN_TX_RTT_RESET       Reset      TCP connection's RTT       controls.
 *                           NET_TCP_CONN_TX_RTT_RTO_CALC    Calculate  TCP connection's RTT & RTO controls.
 *                           NET_TCP_CONN_TX_RTO_BACKOFF     Back-off   TCP connection's       RTO controls.
 *
 * @param    rtt_ts_txd_ms   Round-trip timestamp when TCP segment/packet  transmitted (in milliseconds).
 *
 * @param    rtt_ts_rxd_ms   Round-trip timestamp when TCP acknowledgement received    (in milliseconds).
 *
 * @note     (2) (a) (1) RFC #2988, Section 2 states that "the rules governing the computation of SRTT
 *                           (smoothed round-trip time), RTTVAR RTTVAR (round-trip time variation), and RTO
 *                           are as follows" :
 *
 *                               - (A) RFC #2988, Section 2.2 states that for "the first RTT measurement R ...
 *                           the host MUST set" :
 *
 *                               - (1) SRTT    <-  R
 *                               - (2) RTTVAR  <-  R/2
 *                               - (3) RTO     <-  SRTT  +  max(G, K * RTTVAR)
 *
 *                           where
 *                           SRTT                    RTT Smoothed Average
 *                           RTTVAR                  RTT Variance/Deviation
 *                           RTO                         Retransmission Timeout
 *                           R                       RTT First Measurement
 *                               - (4)             R   = R * 1             RTT First Average   Gain
 *                               - (5)             R/2 = R * 1/2           RTT First Deviation Gain
 *                           G                       RTT Clock Granularity (resolution)
 *                               - (6)             K = 4                   RTT-RTO Gain
 *
 *                               - (B) RFC #2988, Section 2.3 states that for "subsequent RTT measurement R' ...
 *                           a host MUST set" :
 *
 *                               - (1) RTTVAR  <-  (1 - beta ) * RTTVAR  +  beta  * |SRTT - R'|
 *                               - (2) SRTT    <-  (1 - alpha) * SRTT    +  alpha * R'
 *                               - (3) RTO     <-  SRTT  +  max(G, K * RTTVAR)
 *
 *                           where
 *                           SRTT                    RTT Smoothed Average
 *                           RTTVAR                  RTT Variance/Deviation
 *                           RTO                         Retransmission Timeout
 *                           R'                      RTT Subsequent Measurement(s)
 *                               - (4)             alpha = 1/8             RTT-Average    Gain
 *                               - (5)             beta  = 1/4             RTT-Deviation  Gain
 *                           G                       RTT Clock Granularity (resolution)
 *                               - (6)             K = 4                   RTT-RTO Gain
 *
 *                               - (a) RFC #2988, Section 2.3 states tht "updating RTTVAR and SRTT MUST be
 *                           computed in ... order ... [since] the value of SRTT used in the update
 *                           to RTTVAR is its value before updating SRTT itself".
 *
 *                               - (b) To reduce the total number of operations for both RTT calculations,
 *                           the equations SHOULD be factored & rearranged as follows :
 *
 *                               - (1) (A) RTTVAR  <-       (1 - beta) * RTTVAR  +  beta * |SRTT - R'|
 *
 *                               - (B) RTTVAR  <-  RTTVAR  -  beta * RTTVAR  +  beta * |SRTT - R'|
 *
 *                               - (C) RTTVAR  <-  RTTVAR  +  beta * (|SRTT - R'| - RTTVAR)
 *
 *                               - (D) RTTVAR  <-  RTTVAR  +  beta * (|R' - SRTT| - RTTVAR)
 *
 *                               - (2) (A) SRTT    <-     (1 - alpha) * SRTT  +  alpha * R'
 *
 *                               - (B) SRTT    <-  SRTT  -  alpha * SRTT  +  alpha * R'
 *
 *                               - (C) SRTT    <-  SRTT  +  alpha * (R' - SRTT)
 *
 *                               - (2) (A) RFC #793, Section 3.7 'Data Communication : Retransmission Timeout' states
 *                           that "the Round Trip Time (RTT) ... [is] the elapsed time between" :
 *
 *                               - (1) "sending a data octet with a particular sequence number and"   ...
 *                               - (2) "receiving an acknowledgment that covers that sequence number" ...
 *                               - (3) "(segments sent do not have to match segments received)".
 *
 *                               - (B) (1) RFC #2988, Section 3 adds that :
 *
 *                               - (a) "Traditionally, TCP implementations have taken one RTT measurement at
 *                           a time (typically once per RTT)."
 *                               - (b) "A TCP implementation MUST take at least one RTT measurement per RTT
 *                           (unless that is not possible per Karn's algorithm) [see Note #2a5]".
 *                               - (c) "For fairly modest congestion window sizes research suggests that
 *                           timing each segment does not lead to a better RTT estimator."
 *                               - (d) "Additionally, when multiple samples are taken per RTT the alpha and
 *                           beta ... may keep an inadequate RTT history."
 *
 *                               - (2) RFC #2988, Section 1 states that "in some situations it may be beneficial
 *                           for a TCP sender to be more conservative than the algorithms detailed in
 *                           this document allow.  However, a TCP MUST NOT be more aggressive than the
 *                           ... algorithms allow".
 *
 *                           Thus the following TCP algorithm(s) are permitted; even if the algorithms
 *                           delay or decrease the number of received acknowledgements, which thereby
 *                           increases the measured time values for RTT samples :
 *
 *                               - (a) Karn's Algorithm                    See  Note #2a5
 *                               - (b) TCP Delayed Acknowledgements        See 'NetTCP_TxConnAck()  Note #6'
 *
 *                               - (3) Jacobson/Karels, "Congestion Avoidance and Control", Appendix A.2 states that RTT
 *                           calculations "should be done in integer arithmetic".  RFC #2988, Section 2.3 adds
 *                           that RTT calculations "SHOULD be computed using ... 1/8 and ... 1/4" gains (see
 *                           Notes #2a1B4 & #2a1B5).
 *
 *                               - (4) (A) (1) RFC #2988, Section 5 states "that a TCP implementation MAY clear SRTT and
 *                           RTTVAR after backing off the timer multiple times as it is likely that the
 *                           current SRTT and RTTVAR are bogus in this situation.  Once SRTT and RTTVAR
 *                           are cleared they should be initialized with the next RTT sample taken per
 *                           [Note #2a1A] rather than using [Note #2a1B]".
 *
 *                               - (2) RFC #2581, Section 4.1 states that "after TCP has been idle for ... an
 *                           interval exceeding the retransmission timeout ... use slow start to
 *                           restart transmission".
 *
 *                           Similarly, although NO RFC specifies that a TCP connection's RTT average
 *                           & deviation should be reset following a TCP transmit idle timeout; it
 *                           seems reasonable to reset a TCP connection's RTT average & deviation
 *                           controls whenever a TCP connection's transmit is idle for a period
 *                           exceeding the re-transmit timeout.
 *
 *                           See also 'NetTCP_TxConnTxQ_TimeoutIdle()  Note #2b'.
 *
 *                               - (B) However, a TCP connection's RTO timeout controls do NOT need to also be
 *                           explicitly reset since RFC #2988, Section 5 states that "once a new RTT
 *                           measurement is obtained (which can only happen when new data has been
 *                           sent and acknowledged), the computations ... of RTO ... are performed".
 *
 *                               - (5) RFC #2988, Section 3 states that "TCP MUST use Karn's algorithm ... for
 *                           taking RTT samples.  That is, RTT samples MUST NOT be made using segments
 *                           that were retransmitted (and thus for which it is ambiguous whether the
 *                           reply was for the first instance of the packet or a later instance)".
 *
 *                               - (b) (1) (A) (1) RFC #2988, Section 2.4 states that "whenever RTO is computed, if it
 *                           is less than 1 second then the RTO SHOULD be rounded up to 1 second".
 *
 *                               - (a) This amends RFC #1122, Section 4.2.3.1 which previously stated
 *                           that "the recommended ... RTO ... lower bound ... SHOULD be
 *                           measured in fractions of a second".
 *
 *                               - (2) RFC #2988, Section 4 states that "there is no requirement for the
 *                           clock granularity G used for computing RTT measurements ... However,
 *                           if the K*RTTVAR term in the RTO calculation equals zero, the variance
 *                           term MUST be rounded to G seconds".
 *
 *                           See also Notes #2a1A3 & #2a1B3.
 *
 *                               - (B) (1) RFC #2988, Section 2.4 adds that "a maximum value MAY be placed on
 *                           RTO provided it is at least 60 seconds".
 *
 *                               - (2) RFC #1122, Section 4.2.3.1 states that "the recommended ... RTO ...
 *                           upper bound should be 2*MSL".
 *
 *                               - (3) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2,
 *                           Page 299 states that "the timeout value ... [has] an upper limit of
 *                           64 seconds".
 *
 *                           See also 'net_tcp.c  NetTCP_TxConnRTO_CfgMaxTimeout()  Note #1'.
 *
 *                               - (2) RFC #1122, Section 4.2.3.1 reiterates that an "implementation MUST also
 *                           include 'exponential backoff' for successive RTO values for the same
 *                           segment".
 *
 *                               - (a) RFC #2988, Section 5.5 states that "when the retransmission timer
 *                           expires ... the host MUST set RTO <- RTO * 2 ('back off the timer')".
 *
 *                           Thus the TCP retransmission timer exponential back-off scalar
 *                           value is 2.
 *
 *                               - (b) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 21.2,
 *                           Page 299 reiterates that "this doubling is called an 'exponential
 *                           backoff'".
 *
 *                           See also 'NetTCP_TxConnRTO_CalcBackOff()  Note #1'.
 *******************************************************************************************************/
static void NetTCP_TxConnRTT_RTO_Calc(NET_TCP_CONN         *p_conn,
                                      NET_TCP_CALC_CODE    calc_code,
                                      NET_TCP_TX_RTT_TS_MS rtt_ts_txd_ms,
                                      NET_TCP_TX_RTT_TS_MS rtt_ts_rxd_ms)
{
  NET_TCP_TX_RTT_MS        rtt_cur_ms;
  NET_TCP_TX_RTT_MS_SCALED rtt_cur_ms_scaled;
  NET_TCP_TX_RTT_MS_SCALED rtt_err_ms_scaled;
  NET_TCP_TX_RTT_MS_SCALED rtt_err_ms_scaled_abs;
  NET_TCP_TX_RTT_MS_SCALED rtt_avg_ms_scaled;
  NET_TCP_TX_RTT_MS_SCALED rtt_dev_ms_scaled;
  NET_TCP_TX_RTT_MS_SCALED rtt_dev_ms_scaled_gain;
  NET_TCP_TX_RTT_MS_SCALED rtt_dev_ms_scaled_max;
  NET_TCP_TX_RTT_MS_SCALED rto_ms_scaled;
  CPU_INT32U               min_net_tmr_val_scaled;

  //                                                               ---------------- PERFORM CALC CODE -----------------
  switch (calc_code) {
    case NET_TCP_CONN_TX_RTT_RTO_CALC:
      break;

    case NET_TCP_CONN_TX_RTO_BACKOFF:                           // Back-off RTO (see Note #2b2).
      p_conn->TxRTT_RTO_ms = NetTCP_TxConnRTO_CalcBackOff(p_conn, p_conn->TxRTT_RTO_ms);
      NetTCP_TxConnRTO_CalcUpdate_ms(p_conn);
    //                                                             'break' intentionally omitted; MUST execute ...
    //                                                             ...  the following case (see Note #1c1A) :  ...
    //                                                             --------- ... 'NET_TCP_CONN_TX_RTT_RESET'. ---------
    //                                                             fallthrough
    case NET_TCP_CONN_TX_RTT_RESET:                             // See Note #2a4.
      NetTCP_TxConnRTT_Reset(p_conn);
      goto exit;

    case NET_TCP_CONN_TX_RTT_RTO_INIT:
    default:
      NetTCP_TxConnRTT_RTO_Init(p_conn);
      goto exit;
  }

  //                                                               ---------------- PREPARE RTT CALCS -----------------
  switch (p_conn->TxRTT_RTO_State) {
    case NET_TCP_TX_RTT_RTO_STATE_INIT:
    case NET_TCP_TX_RTT_RTO_STATE_RESET:
    case NET_TCP_TX_RTT_RTO_STATE_CALC:
      rtt_cur_ms = (NET_TCP_TX_RTT_MS)(rtt_ts_rxd_ms - rtt_ts_txd_ms);
      rtt_cur_ms_scaled = (NET_TCP_TX_RTT_MS_SCALED)(rtt_cur_ms    * NET_TCP_TX_RTT_SCALE);
      break;

    case NET_TCP_TX_RTT_RTO_STATE_NONE:
    case NET_TCP_TX_RTT_RTO_STATE_RE_TX:                        // See Note #2a5.
    default:
      goto exit;
  }

  //                                                               ---------------- PERFORM RTT CALCS -----------------
  switch (p_conn->TxRTT_RTO_State) {
    case NET_TCP_TX_RTT_RTO_STATE_INIT:                         // Init   RTT calcs (see Notes #2a1A1 & #2a1A2).
    case NET_TCP_TX_RTT_RTO_STATE_RESET:
      rtt_avg_ms_scaled = (rtt_cur_ms_scaled * NET_TCP_TX_RTT_GAIN_AVG_INIT_NUMER)
                          / NET_TCP_TX_RTT_GAIN_AVG_INIT_DENOM;

      rtt_dev_ms_scaled = (rtt_cur_ms_scaled * NET_TCP_TX_RTT_GAIN_DEV_INIT_NUMER)
                          / NET_TCP_TX_RTT_GAIN_DEV_INIT_DENOM;

      p_conn->TxRTT_RTO_State = NET_TCP_TX_RTT_RTO_STATE_CALC;
      break;

    case NET_TCP_TX_RTT_RTO_STATE_CALC:                         // Update RTT calcs (see Notes #2a1Bb1D & #2a1Bb2C).
      rtt_err_ms_scaled = rtt_cur_ms_scaled  - p_conn->TxRTT_Avg_ms_scaled;
      rtt_err_ms_scaled_abs = DEF_ABS(rtt_err_ms_scaled);

      rtt_dev_ms_scaled = p_conn->TxRTT_Dev_ms_scaled + (((rtt_err_ms_scaled_abs - p_conn->TxRTT_Dev_ms_scaled) * NET_TCP_TX_RTT_GAIN_DEV_NUMER)
                                                         / NET_TCP_TX_RTT_GAIN_DEV_DENOM);

      rtt_avg_ms_scaled = p_conn->TxRTT_Avg_ms_scaled +  ((rtt_err_ms_scaled                                   * NET_TCP_TX_RTT_GAIN_AVG_NUMER)
                                                          / NET_TCP_TX_RTT_GAIN_AVG_DENOM);
      break;

    case NET_TCP_TX_RTT_RTO_STATE_NONE:
    case NET_TCP_TX_RTT_RTO_STATE_RE_TX:                        // See Note #2a5.
    default:
      goto exit;
  }

  //                                                               -------------------- UPDATE RTT --------------------
  p_conn->TxRTT_Avg_ms_scaled = rtt_avg_ms_scaled;
  p_conn->TxRTT_Dev_ms_scaled = rtt_dev_ms_scaled;

#if 0
  NetTCP_TxConnRTT_CalcUpdate(p_conn);
#endif

  //                                                               --------------------- CALC RTO ---------------------
  //                                                               Calc  RTO     (see Note #2a1B3).
  rtt_dev_ms_scaled_gain = (p_conn->TxRTT_Dev_ms_scaled * NET_TCP_TX_RTT_GAIN_RTO_NUMER)
                           / NET_TCP_TX_RTT_GAIN_RTO_DENOM;

  //                                                               Limit RTT dev (see Note #2b1A2).
  min_net_tmr_val_scaled = NetTmr_ListMinTimeoutGet();
  if (min_net_tmr_val_scaled == DEF_INT_32U_MAX_VAL) {
    min_net_tmr_val_scaled = p_conn->TxRTT_RTO_ms;
  }
  min_net_tmr_val_scaled = min_net_tmr_val_scaled * NET_TCP_TX_RTT_SCALE;

  rtt_dev_ms_scaled_max = DEF_MAX(min_net_tmr_val_scaled,
                                  (CPU_INT32U)rtt_dev_ms_scaled_gain);

  rto_ms_scaled = p_conn->TxRTT_Avg_ms_scaled + rtt_dev_ms_scaled_max;

  //                                                               Limit RTO (see Note #2b1).
  if (rto_ms_scaled < NET_TCP_TX_RTO_MIN_TIMEOUT_MS_SCALED) {
    rto_ms_scaled = NET_TCP_TX_RTO_MIN_TIMEOUT_MS_SCALED;
  }
  if (rto_ms_scaled > p_conn->TxRTT_RTO_Max_ms_scaled) {
    rto_ms_scaled = p_conn->TxRTT_RTO_Max_ms_scaled;
  }

  //                                                               -------------------- UPDATE RTO --------------------
  p_conn->TxRTT_RTO_ms_scaled = rto_ms_scaled;

  NetTCP_TxConnRTO_CalcUpdate_ms_scaled(p_conn);

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_TxPktHandlerIPv4()
 *
 * @brief    (1) Prepare & transmit TCP packet(s) :
 *
 *           - (a) Validate transmit packet
 *           - (b) Transmit TCP packet
 *           - (c) Free   transmit packet buffer(s)
 *           - (d) Update transmit statistics
 *
 * @param    p_buf       Pointer to network buffer to transmit TCP packet.
 *
 * @param    src_addr    Source      IP  address.
 *
 * @param    src_port    Source      TCP port.
 *
 * @param    dest_addr   Destination IP  address.
 *
 * @param    dest_port   Destination TCP port.
 *
 * @param    seq_nbr     TCP segment                 sequence number.
 *
 * @param    ack_nbr     TCP segment acknowledgement sequence number.
 *
 * @param    win_size    TCP receive window advertisement size.
 *
 * @param    TOS         Specific TOS to transmit TCP/IP packet
 *                       (see Note #2a & 'net_ip.h  IP HEADER TYPE OF SERVICE (TOS) DEFINES').
 *
 * @param    TTL         Specific TTL to transmit TCP/IP packet
 *                       (see Note #2b & 'net_ip.h  IP HEADER TIME-TO-LIVE (TTL) DEFINES') :
 *                       NET_IP_TTL_MIN                  Minimum TTL transmit value   (1)
 *                       NET_IP_TTL_MAX                  Maximum TTL transmit value (255)
 *                       NET_IP_TTL_DFLT                 Default TTL transmit value (128)
 *                       NET_IP_TTL_NONE                 Replace with default TTL
 *
 * @param    flags_tcp   Flags to select TCP transmit options; bit-field flags logically OR'd :
 *                       NET_TCP_FLAG_NONE               No  TCP transmit flags selected.
 *                       NET_TCP_FLAG_TX_FIN             Set TCP 'FIN'    flag.
 *                       NET_TCP_FLAG_TX_SYNC            Set TCP 'SYN'    flag.
 *                       NET_TCP_FLAG_TX_RESET           Set TCP 'RESET'  flag.
 *                       NET_TCP_FLAG_TX_PUSH            Set TCP 'PUSH'   flag.
 *                       NET_TCP_FLAG_TX_ACK             Set TCP 'ACK'    flag.
 *                       NET_TCP_FLAG_TX_URGENT          Set TCP 'URGENT' flag.
 *
 * @param    flags_ip    Flags to select IP  transmit options; bit-field flags logically OR'd :
 *                       NET_IP_FLAG_NONE                No  IP transmit flags selected.
 *                       NET_IP_FLAG_TX_DONT_FRAG        Set IP 'Don't Frag' flag.
 *
 * @param    p_opts_tcp  Pointer to one or more TCP options configuration data structures :
 *                       NULL                            NO  TCP transmit         options configuration.
 *                       NET_TCP_OPT_CFG_MAX_SEG_SIZE    TCP Maximum Segment Size options configuration.
 *
 * @param    p_opts_ip   Pointer to one or more IP  options configuration data structures
 *                       (see Note #2c & 'net_ip.h  IP HEADER OPTION CONFIGURATION DATA TYPES') :
 *                       NULL                            NO IP transmit options configuration.
 *                       NET_IP_OPT_CFG_ROUTE_TS         Route &/or Internet Timestamp options configuration.
 *                       NET_IP_OPT_CFG_SECURITY         Security options configuration
 *                       (see 'net_ip.c  Note #1e').
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) The following parameters are configured & maintained by a TCP connection's network
 *                       connection (see 'net_conn.h  NETWORK CONNECTION DATA TYPE  Note #2') :
 *
 *                           - (a) RFC #1122, Section 4.2.4.2 states that :
 *
 *                           - (1) "The application layer MUST be able to specify the [IP] Type-of-Service (TOS)
 *                       for segments that are sent on a connection ... TCP SHOULD pass the current
 *                       TOS value without change to the IP layer, when it sends segments on the
 *                       connection."
 *
 *                           - (2) "It not required [sic], but the application SHOULD be able to change the [IP]
 *                       TOS during the connection lifetime."
 *
 *                           - (3) "The TOS will be specified independently in each direction on the connection,
 *                       so that the receiver application will specify the TOS used for ACK segments."
 *
 *                           - (b) RFC #1122, Section 4.2.2.19 states that "the [IP] TTL value used to send TCP
 *                       segments MUST be configurable".
 *
 *                           - (c) (1) (A) RFC #1122, Section 4.1.3.2 reiterates that "an application MUST be able
 *                       to specify IP options to be sent ... and ... MUST pass these options to
 *                       the IP layer".
 *
 *                           - (B) RFC #1122, Section 4.2.3.8 adds that :
 *
 *                           - (1) "A TCP MAY support the [IP] Time Stamp and Record Route options."
 *
 *                           - (2) (a) "An application MUST be able to specify a [IP] source route when
 *                       it actively opens a TCP connection, and this MUST take precedence
 *                       over a source route received in a datagram."
 *
 *                           - (b) (1) "When a ... connection is OPENed passively and a packet
 *                       arrives with a completed IP Source Route option (containing
 *                       a return route), ... all segments sent on this connection
 *                       ... MUST save ... and use ... [this] return route."
 *
 *                           - (2) "If a different source route arrives in a later segment, the
 *                       later definition SHOULD override the earlier one."
 *
 *                           - (2) IP transmit options currently NOT implemented      See 'net_tcp.c  Note #1d'
 *
 * @note     (3) Network buffer already freed by lower layer; only increment error counter.
 *******************************************************************************************************/
#ifdef  NET_IPv4_MODULE_EN
static void NetTCP_TxPktHandlerIPv4(NET_BUF          *p_buf,
                                    NET_IPv4_ADDR    src_addr,
                                    NET_TCP_PORT_NBR src_port,
                                    NET_IPv4_ADDR    dest_addr,
                                    NET_TCP_PORT_NBR dest_port,
                                    NET_TCP_SEQ_NBR  seq_nbr,
                                    NET_TCP_SEQ_NBR  ack_nbr,
                                    NET_TCP_WIN_SIZE win_size,
                                    NET_IPv4_TOS     TOS,
                                    NET_IPv4_TTL     TTL,
                                    NET_TCP_FLAGS    flags_tcp,
                                    NET_IPv4_FLAGS   flags_ip,
                                    void             *p_opts_tcp,
                                    void             *p_opts_ip,
                                    RTOS_ERR         *p_err)
{
  NET_BUF_HDR *p_buf_hdr = &p_buf->Hdr;

  //                                                               -------------------- TX TCP PKT --------------------
  NetTCP_TxPktIPv4(p_buf,
                   p_buf_hdr,
                   src_addr,
                   src_port,
                   dest_addr,
                   dest_port,
                   seq_nbr,
                   ack_nbr,
                   win_size,
                   TOS,
                   TTL,
                   flags_tcp,
                   flags_ip,
                   p_opts_tcp,
                   p_opts_ip,
                   p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit_discard;
  }

  NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegCtr);

  goto exit;

exit_discard:
  NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxPktDiscardedCtr);

exit:
  return;
}
#endif

/****************************************************************************************************//**
 *                                           NetTCP_TxPktHandlerIPv6()
 *
 * @brief    (1) Prepare & transmit TCP packet(s) :
 *
 *           - (a) Validate transmit packet
 *           - (b) Transmit TCP packet
 *           - (c) Free   transmit packet buffer(s)
 *           - (d) Update transmit statistics
 *
 * @param    p_buf           Pointer to network buffer to transmit TCP packet.
 *
 * @param    p_src_addr      Pointer to source IPv6 address.
 *
 * @param    src_port        Source      TCP port.
 *
 * @param    p_dest_addr     Pointer to destination IPv6 address.
 *
 * @param    dest_port       Destination TCP port.
 *
 * @param    seq_nbr         TCP segment                 sequence number.
 *
 * @param    ack_nbr         TCP segment acknowledgement sequence number.
 *
 * @param    win_size        TCP receive window advertisement size.
 *
 * @param    traffic_class   IPv6 traffic class value to use.
 *
 * @param    flow_label      IPv6 flow label value to use.
 *
 * @param    hop_lim         IPv6 hop limit value to use.
 *
 * @param    flags_tcp       Flags to select TCP transmit options; bit-field flags logically OR'd :
 *
 * @param    p_opts_tcp      Pointer to one or more TCP options configuration data structures :
 *
 * @param    p_err           Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) The following parameters are configured & maintained by a TCP connection's network
 *                           connection (see 'net_conn.h  NETWORK CONNECTION DATA TYPE  Note #2') :
 *
 *                               - (a) RFC #1122, Section 4.2.4.2 states that :
 *
 *                               - (1) "The application layer MUST be able to specify the [IP] Type-of-Service (TOS)
 *                           for segments that are sent on a connection ... TCP SHOULD pass the current
 *                           TOS value without change to the IP layer, when it sends segments on the
 *                           connection."
 *
 *                               - (2) "It not required [sic], but the application SHOULD be able to change the [IP]
 *                           TOS during the connection lifetime."
 *
 *                               - (3) "The TOS will be specified independently in each direction on the connection,
 *                           so that the receiver application will specify the TOS used for ACK segments."
 *
 *                               - (b) RFC #1122, Section 4.2.2.19 states that "the [IP] TTL value used to send TCP
 *                           segments MUST be configurable".
 *
 *                               - (c) (1) (A) RFC #1122, Section 4.1.3.2 reiterates that "an application MUST be able
 *                           to specify IP options to be sent ... and ... MUST pass these options to
 *                           the IP layer".
 *
 *                               - (B) RFC #1122, Section 4.2.3.8 adds that :
 *
 *                               - (1) "A TCP MAY support the [IP] Time Stamp and Record Route options."
 *
 *                               - (2) (a) "An application MUST be able to specify a [IP] source route when
 *                           it actively opens a TCP connection, and this MUST take precedence
 *                           over a source route received in a datagram."
 *
 *                               - (b) (1) "When a ... connection is OPENed passively and a packet
 *                           arrives with a completed IP Source Route option (containing
 *                           a return route), ... all segments sent on this connection
 *                           ... MUST save ... and use ... [this] return route."
 *
 *                               - (2) "If a different source route arrives in a later segment, the
 *                           later definition SHOULD override the earlier one."
 *
 *                               - (2) IP transmit options currently NOT implemented      See 'net_tcp.c  Note #1d'
 *
 * @note     (3) Network buffer already freed by lower layer; only increment error counter.
 *******************************************************************************************************/
#ifdef  NET_IPv6_MODULE_EN
static void NetTCP_TxPktHandlerIPv6(NET_BUF                *p_buf,
                                    NET_IPv6_ADDR          *p_src_addr,
                                    NET_TCP_PORT_NBR       src_port,
                                    NET_IPv6_ADDR          *p_dest_addr,
                                    NET_TCP_PORT_NBR       dest_port,
                                    NET_TCP_SEQ_NBR        seq_nbr,
                                    NET_TCP_SEQ_NBR        ack_nbr,
                                    NET_TCP_WIN_SIZE       win_size,
                                    NET_IPv6_TRAFFIC_CLASS traffic_class,
                                    NET_IPv6_FLOW_LABEL    flow_label,
                                    NET_IPv6_HOP_LIM       hop_lim,
                                    NET_TCP_FLAGS          flags_tcp,
                                    void                   *p_opts_tcp,
                                    RTOS_ERR               *p_err)
{
  NET_BUF_HDR *p_buf_hdr;

  p_buf_hdr = &p_buf->Hdr;
  DEF_BIT_SET(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME);

  //                                                               -------------------- TX TCP PKT --------------------
  NetTCP_TxPktIPv6(p_buf,
                   p_buf_hdr,
                   p_src_addr,
                   src_port,
                   p_dest_addr,
                   dest_port,
                   seq_nbr,
                   ack_nbr,
                   win_size,
                   traffic_class,
                   flow_label,
                   hop_lim,
                   flags_tcp,
                   p_opts_tcp,
                   p_err);
  if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
    goto exit_discard;
  }

  NET_CTR_STAT_INC(Net_StatCtrs.TCP.TxSegCtr);

  goto exit;

exit_discard:
  NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxPktDiscardedCtr);

exit:
  return;
}
#endif

/********************************************************************************************************
 *                                           NetTCP_TxPktIPv4
 *
 * Description : (1) Prepare TCP header & transmit TCP packet to network layer :
 *
 *                   (a) Prepare   TCP options (if any)
 *                   (b) Calculate TCP header buffer controls
 *                   (c) Prepare   TCP header
 *                   (d) Transmit  TCP packet
 *
 * Argument(s) : p_buf       Pointer to network buffer to transmit TCP packet.
 *
 *               p_buf_hdr   Pointer to network buffer header.
 *
 *               src_addr    Source      IP  address.
 *
 *               src_port    Source      TCP port.
 *
 *               dest_addr   Destination IP  address.
 *
 *               dest_port   Destination TCP port.
 *
 *               seq_nbr     TCP segment                 sequence number.
 *
 *               ack_nbr     TCP segment acknowledgement sequence number.
 *
 *               win_size    TCP receive window advertisement size.
 *
 *               TOS         Specific TOS to transmit TCP/IP packet
 *                               (see 'net_ip.h  IP HEADER TYPE OF SERVICE (TOS) DEFINES').
 *
 *               TTL         Specific TTL to transmit TCP/IP packet
 *                               (see 'net_ip.h  IP HEADER TIME-TO-LIVE (TTL) DEFINES') :
 *
 *                               NET_IP_TTL_MIN                  Minimum TTL transmit value   (1)
 *                               NET_IP_TTL_MAX                  Maximum TTL transmit value (255)
 *                               NET_IP_TTL_DFLT                 Default TTL transmit value (128)
 *                               NET_IP_TTL_NONE                 Replace with default TTL
 *
 *               flags_tcp   Flags to select TCP transmit options; bit-field flags logically OR'd :
 *               ---------
 *                               NET_TCP_FLAG_NONE               No  TCP transmit flags selected.
 *                               NET_TCP_FLAG_TX_FIN             Set TCP 'FIN'    flag.
 *                               NET_TCP_FLAG_TX_SYNC            Set TCP 'SYN'    flag.
 *                               NET_TCP_FLAG_TX_RESET           Set TCP 'RESET'  flag.
 *                               NET_TCP_FLAG_TX_PUSH            Set TCP 'PUSH'   flag.
 *                               NET_TCP_FLAG_TX_ACK             Set TCP 'ACK'    flag.
 *                               NET_TCP_FLAG_TX_URGENT          Set TCP 'URGENT' flag.
 *
 *               flags_ip    Flags to select IP  transmit options; bit-field flags logically OR'd :
 *
 *                               NET_IP_FLAG_NONE                No  IP transmit flags selected.
 *                               NET_IP_FLAG_TX_DONT_FRAG        Set IP 'Don't Frag' flag.
 *
 *               p_opts_tcp  Pointer to one or more TCP options configuration data structures :
 *               ---------
 *                               NULL                            NO  TCP transmit         options configuration.
 *                               NET_TCP_OPT_CFG_MAX_SEG_SIZE    TCP Maximum Segment Size options configuration.
 *
 *               p_opts_ip   Pointer to one or more IP  options configuration data structures
 *                               (see 'net_ip.h  IP HEADER OPTION CONFIGURATION DATA TYPES') :
 *
 *                               NULL                            NO IP transmit options configuration.
 *                               NET_IP_OPT_CFG_ROUTE_TS         Route &/or Internet Timestamp options configuration.
 *                               NET_IP_OPT_CFG_SECURITY         Security options configuration
 *                                                                   (see 'net_ip.c  Note #1e').
 *
 *               p_err       Pointer to variable that will receive the return error code from this function.
 *
 * Return(s)   : none.
 *
 * Note(s)     : none.
 *******************************************************************************************************/

#ifdef  NET_IPv4_MODULE_EN
static void NetTCP_TxPktIPv4(NET_BUF          *p_buf,
                             NET_BUF_HDR      *p_buf_hdr,
                             NET_IPv4_ADDR    src_addr,
                             NET_TCP_PORT_NBR src_port,
                             NET_IPv4_ADDR    dest_addr,
                             NET_TCP_PORT_NBR dest_port,
                             NET_TCP_SEQ_NBR  seq_nbr,
                             NET_TCP_SEQ_NBR  ack_nbr,
                             NET_TCP_WIN_SIZE win_size,
                             NET_IPv4_TOS     TOS,
                             NET_IPv4_TTL     TTL,
                             NET_TCP_FLAGS    flags_tcp,
                             NET_IPv4_FLAGS   flags_ip,
                             void             *p_opts_tcp,
                             void             *p_opts_ip,
                             RTOS_ERR         *p_err)
{
  CPU_INT08U       tcp_opt_len_size;
  CPU_INT16U       tcp_hdr_len_size;
  NET_TCP_OPT_SIZE tcp_hdr_opts[NET_TCP_HDR_OPT_NBR_MAX];

  //                                                               ----------------- PREPARE TCP OPTS -----------------
  if (p_opts_tcp != DEF_NULL) {
    tcp_opt_len_size = NetTCP_TxPktPrepareOpt(p_opts_tcp,
                                              (CPU_INT08U *)&tcp_hdr_opts[0],
                                              p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
  } else {
    tcp_opt_len_size = 0u;
  }

  //                                                               ---------------- CALC TCP HDR CTRLS ----------------
  //                                                               Calc tot TCP hdr len (in octets).
  tcp_hdr_len_size = (CPU_INT16U)(NET_TCP_HDR_SIZE_MIN + tcp_opt_len_size);
  RTOS_ASSERT_DBG_ERR_SET((tcp_hdr_len_size <= NET_TCP_HDR_SIZE_MAX), *p_err, RTOS_ERR_INVALID_ARG,; );

  //                                                               ----------------- PREPARE TCP HDR ------------------
  NetTCP_TxPktPrepareHdr(p_buf,
                         p_buf_hdr,
                         tcp_hdr_len_size,
                         tcp_opt_len_size,
                         sizeof(NET_IPv4_ADDR),
                         &src_addr,
                         src_port,
                         &dest_addr,
                         dest_port,
                         seq_nbr,
                         ack_nbr,
                         win_size,
                         flags_tcp,
                         &tcp_hdr_opts[0]);

  //                                                               -------------------- TX TCP PKT --------------------
  NetIPv4_Tx(p_buf,
             src_addr,
             dest_addr,
             TOS,
             TTL,
             flags_ip,
             p_opts_ip,
             p_err);

exit:
  return;
}
#endif

/****************************************************************************************************//**
 *                                           NetTCP_TxPktIPv6()
 *
 * Description : (1) Prepare TCP header & transmit TCP packet to network layer :
 *
 *                   (a) Prepare   TCP options (if any)
 *                   (b) Calculate TCP header buffer controls
 *                   (c) Prepare   TCP header
 *                   (d) Transmit  TCP packet
 *
 * Argument(s) : p_buf           Pointer to network buffer to transmit TCP packet.
 *
 *               p_buf_hdr       Pointer to network buffer header.
 *
 *               p_src_addr      Pointer to source IPv6 address.
 *
 *               src_port        Source TCP port.
 *
 *               p_dest_addr     Pointer to destination IPv6 address.
 *
 *               dest_port       Destination TCP port.
 *
 *               seq_nbr         TCP segment sequence number.
 *
 *               ack_nbr         TCP segment acknowledgement sequence number.
 *
 *               win_size        TCP receive window advertisement size.
 *
 *               traffic_class   IPv6 traffic class value to use.
 *
 *               flow_label      IPv6 flow label value to use.
 *
 *               hop_lim         IPv6 hop limit value to use.
 *
 *               flags_tcp       Flags to select TCP transmit options; bit-field flags logically OR'd :
 *
 *               p_opts_tcp      Pointer to one or more TCP options configuration data structures :
 *
 *               p_err           Pointer to variable that will receive the return error code from this function.
 *
 * Return(s)   : none.
 *
 * Note(s)     : none.
 *******************************************************************************************************/
#ifdef  NET_IPv6_MODULE_EN
static void NetTCP_TxPktIPv6(NET_BUF                *p_buf,
                             NET_BUF_HDR            *p_buf_hdr,
                             NET_IPv6_ADDR          *p_src_addr,
                             NET_TCP_PORT_NBR       src_port,
                             NET_IPv6_ADDR          *p_dest_addr,
                             NET_TCP_PORT_NBR       dest_port,
                             NET_TCP_SEQ_NBR        seq_nbr,
                             NET_TCP_SEQ_NBR        ack_nbr,
                             NET_TCP_WIN_SIZE       win_size,
                             NET_IPv6_TRAFFIC_CLASS traffic_class,
                             NET_IPv6_FLOW_LABEL    flow_label,
                             NET_IPv6_HOP_LIM       hop_lim,
                             NET_TCP_FLAGS          flags_tcp,
                             void                   *p_opts_tcp,
                             RTOS_ERR               *p_err)
{
  CPU_INT08U       tcp_opt_len_size;
  CPU_INT16U       tcp_hdr_len_size;
  NET_TCP_OPT_SIZE tcp_hdr_opts[NET_TCP_HDR_OPT_NBR_MAX];

  //                                                               ----------------- PREPARE TCP OPTS -----------------
  if (p_opts_tcp != DEF_NULL) {
    tcp_opt_len_size = NetTCP_TxPktPrepareOpt(p_opts_tcp,
                                              (CPU_INT08U *)&tcp_hdr_opts[0],
                                              p_err);
    if (RTOS_ERR_CODE_GET(*p_err) != RTOS_ERR_NONE) {
      goto exit;
    }
  } else {
    tcp_opt_len_size = 0u;
  }

  //                                                               ---------------- CALC TCP HDR CTRLS ----------------
  //                                                               Calc tot TCP hdr len (in octets).
  tcp_hdr_len_size = (CPU_INT16U)(NET_TCP_HDR_SIZE_MIN + tcp_opt_len_size);
  RTOS_ASSERT_DBG_ERR_SET((tcp_hdr_len_size <= NET_TCP_HDR_SIZE_MAX), *p_err, RTOS_ERR_INVALID_ARG,; );

  //                                                               ----------------- PREPARE TCP HDR ------------------
  NetTCP_TxPktPrepareHdr(p_buf,
                         p_buf_hdr,
                         tcp_hdr_len_size,
                         tcp_opt_len_size,
                         sizeof(NET_IPv6_ADDR),
                         p_src_addr,
                         src_port,
                         p_dest_addr,
                         dest_port,
                         seq_nbr,
                         ack_nbr,
                         win_size,
                         flags_tcp,
                         &tcp_hdr_opts[0]);

  //                                                               -------------------- TX TCP PKT --------------------

  NetIPv6_Tx(p_buf,
             p_src_addr,
             p_dest_addr,
             DEF_NULL,
             traffic_class,
             flow_label,
             hop_lim,
             p_err);

exit:
  return;
}
#endif

/****************************************************************************************************//**
 *                                           NetTCP_TxPktPrepareOpt()
 *
 * @brief    (1) Prepare TCP header with TCP transmit options :
 *
 *           - (a) Prepare ALL TCP options from configuration
 *                       data structure(s)
 *           - (b) Pad remaining TCP header octets                     See RFC #793, Section 3.1
 *                                                                           'Header Format : Padding'
 *
 *       - (2) TCP transmit options MUST be configured by appropriate options configuration data
 *               structure(s) passed via 'p_opts_tcp'; see 'net_tcp.h  TCP HEADER OPTION CONFIGURATION
 *               DATA TYPES' for TCP options configuration.
 *
 * @param    p_opts_tcp  Pointer to one or more TCP options configuration data structures :
 *
 * @param    ---------   NULL                            NO  TCP transmit         options configuration.
 *                               NET_TCP_OPT_CFG_MAX_SEG_SIZE    TCP Maximum Segment Size options configuration.
 *
 * @param    p_opt_hdr   Pointer to TCP transmit option buffer to prepare TCP options.
 *
 * @param    p_err       Pointer to variable that will receive the return error code from this function.
 *
 * @return   Total TCP option length (in octets), if NO error(s).
 *           0, otherwise.
 *
 * @note     (3) (a) See 'net_tcp.h  TCP HEADER OPTIONS DEFINES' for   supported TCP options' summary.
 *
 *           - (b) See 'net_tcp.c  Note #1c'                   for unsupported TCP options.
 *
 * @note     (4) TCP header allows for a maximum option size of 40 octets (see 'net_tcp.h  TCP HEADER
 *               OPTIONS DEFINES  Note #3').
 *
 * @note     (5) (a) RFC # 793, Section 3.1 'Options' states that each option is "a multiple of 8 bits
 *                   in length" and "may begin on any octet boundary".
 *
 *           - (b) Since TCP options are NOT required or guaranteed to align multi-octet words on
 *                   appropriate word boundaries, ALL TCP options are prepared a single octet at a time.
 *******************************************************************************************************/
static CPU_INT08U NetTCP_TxPktPrepareOpt(void       *p_opts_tcp,
                                         CPU_INT08U *p_opt_hdr,
                                         RTOS_ERR   *p_err)
{
  CPU_INT08U       tcp_opt_len_tot = 0u;
  CPU_INT08U       tcp_opt_len = 0u;
  CPU_INT08U       *p_opt_cfg_hdr = p_opt_hdr;
  NET_TCP_OPT_TYPE *p_opt_cfg_type = DEF_NULL;
  void             *p_opt_next = DEF_NULL;
  void             *p_opt_cfg = p_opts_tcp;

  //                                                               ----------------- PREPARE TCP OPTS -----------------
  while (p_opt_cfg != DEF_NULL) {                               // Prepare ALL cfg'd TCP opts (see Note #1a).
    p_opt_cfg_type = (NET_TCP_OPT_TYPE *)p_opt_cfg;
    switch (*p_opt_cfg_type) {
      case NET_TCP_OPT_TYPE_MAX_SEG_SIZE:
        NetTCP_TxPktPrepareOptMaxSegSize(p_opt_cfg, p_opt_cfg_hdr, &tcp_opt_len, &p_opt_next);
        break;
      //                                                           --------------- UNSUPPORTED TCP OPTS ---------------
      //                                                           See Note #3b.
      case NET_TCP_OPT_TYPE_WIN_SCALE:
      case NET_TCP_OPT_TYPE_SACK_PERMIT:
      case NET_TCP_OPT_TYPE_SACK:
      case NET_TCP_OPT_TYPE_ECHO_REQ:
      case NET_TCP_OPT_TYPE_ECHO_REPLY:
      case NET_TCP_OPT_TYPE_TS:
      case NET_TCP_OPT_TYPE_NONE:                               // ----------------- INVALID TCP OPTS -----------------
      default:
        tcp_opt_len_tot = 0u;
        NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxOptTypeCtr);
        RTOS_ERR_SET(*p_err, RTOS_ERR_INVALID_TYPE);
        goto exit;
    }

    if (tcp_opt_len_tot > NET_TCP_HDR_OPT_SIZE_MAX) {           // See Note #4b.
      tcp_opt_len_tot = 0u;
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrOptLenCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_TX);
      goto exit;
    }

    tcp_opt_len_tot += tcp_opt_len;
    p_opt_cfg_hdr += tcp_opt_len;

    p_opt_cfg = p_opt_next;                                     // Prepare next cfg opt.
  }

  //                                                               ------------------- PAD TCP HDR --------------------
  if (tcp_opt_len_tot > 0) {
    //                                                             Pad rem'ing TCP hdr octets (see Note #1b).
    while ((tcp_opt_len_tot %  NET_TCP_HDR_OPT_SIZE_WORD)
           && (tcp_opt_len_tot <= NET_TCP_HDR_OPT_SIZE_MAX)) {
      *p_opt_cfg_hdr = NET_TCP_HDR_OPT_PAD;
      p_opt_cfg_hdr++;
      tcp_opt_len_tot++;
    }

    if (tcp_opt_len_tot > NET_TCP_HDR_OPT_SIZE_MAX) {           // See Note #4b.
      tcp_opt_len_tot = 0u;
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.TxHdrOptLenCtr);
      RTOS_ERR_SET(*p_err, RTOS_ERR_TX);
      goto exit;
    }
  }

exit:
  return (tcp_opt_len_tot);
}

/****************************************************************************************************//**
 *                                   NetTCP_TxPktPrepareOptMaxSegSize()
 *
 * @brief    (1) Prepare TCP header with TCP Maximum Segment Size option :
 *
 *           - (a) Prepare TCP Maximum Segment Size option
 *           - (b) Return option values
 *
 * @param    p_opts_tcp  Pointer to TCP Maximum Segment Size option configuration data structure.
 *
 * @param    p_opt_hdr   Pointer to TCP transmit option buffer to prepare TCP Maximum Segment Size option.
 *
 * @param    p_opt_len   Pointer to variable that will receive the returned TCP option length (in octets).
 *
 * @param    p_opt_next  Pointer to variable that will receive the pointer to the next TCP transmit option.
 *
 * @note     (2) See 'net_tcp.h  TCP HEADER OPTIONS DEFINES  Note #2b1' for TCP Maximum Segment Size
 *                       option summary.
 *
 * @note     (3) (a) RFC # 793, Section 3.1 'Options' states that each option is "a multiple of 8 bits
 *                       in length" and "may begin on any octet boundary".
 *
 *                           - (b) Since TCP options are NOT required or guaranteed to align multi-octet words on
 *                       appropriate word boundaries, ALL TCP options are prepared a single octet at a time.
 *******************************************************************************************************/
static void NetTCP_TxPktPrepareOptMaxSegSize(void       *p_opts_tcp,
                                             CPU_INT08U *p_opt_hdr,
                                             CPU_INT08U *p_opt_len,
                                             void       **p_opt_next)
{
  NET_TCP_OPT_CFG_MAX_SEG_SIZE *p_opt_cfg_max_seg_size;
  CPU_INT08U                   *p_opt_cfg_hdr;
  CPU_INT08U                   opt_len;
  CPU_INT08U                   max_seg_size_hi;
  CPU_INT08U                   max_seg_size_lo;

  //                                                               ------------- PREPARE MAX SEG SIZE OPT -------------
  p_opt_cfg_max_seg_size = (NET_TCP_OPT_CFG_MAX_SEG_SIZE *)p_opts_tcp;
  p_opt_cfg_hdr = p_opt_hdr;

  opt_len = NET_TCP_HDR_OPT_LEN_MAX_SEG_SIZE;
  max_seg_size_hi = (CPU_INT08U)(p_opt_cfg_max_seg_size->MaxSegSize >> DEF_OCTET_NBR_BITS);
  max_seg_size_lo = (CPU_INT08U) p_opt_cfg_max_seg_size->MaxSegSize;

  *p_opt_cfg_hdr = NET_TCP_HDR_OPT_MAX_SEG_SIZE;                // Prepare opt type.
  p_opt_cfg_hdr++;

  *p_opt_cfg_hdr = opt_len;                                     // Prepare opt len.
  p_opt_cfg_hdr++;

  *p_opt_cfg_hdr = max_seg_size_hi;                             // Prepare max seg size val.
  p_opt_cfg_hdr++;

  *p_opt_cfg_hdr = max_seg_size_lo;

  //                                                               ------------------- RTN OPT VALS -------------------
  *p_opt_len = opt_len;
  *p_opt_next = p_opt_cfg_max_seg_size->NextOptPtr;
}

/****************************************************************************************************//**
 *                                           NetTCP_TxPktPrepareHdr()
 *
 * @brief    (1) Prepare TCP header :
 *
 *           - (a) Update network buffer's protocol index & length controls
 *
 *           - (b) Prepare the transmit packet's following TCP header fields :
 *
 *               - (1) Source      Port
 *               - (2) Destination Port
 *               - (3) Sequence        Number
 *               - (4) Acknowledgement Number
 *               - (5) Header Length/Flags
 *               - (6) Window Advertisement
 *               - (7) Check-Sum                                       See Note #3
 *               - (8) Urgent Pointer                                  See Note #2
 *               - (9) Options
 *
 *           - (c) Convert the following TCP header fields from host-order to network-order :
 *
 *               - (1) Source      Port
 *               - (2) Destination Port
 *               - (3) Sequence        Number
 *               - (4) Acknowledgement Number
 *               - (5) Header Length/Flags
 *               - (6) Window Advertisement
 *               - (7) Check-Sum                                       See Note #3e
 *               - (8) Urgent Pointer                                  See Note #2
 *
 *           - (d) Get TCP packet RTT timestamp transmitted            See 'NetTCP_TxConnRTT_RTO_Calc()
 *                                                                               Note #2a2A1'
 *
 * @param    p_buf               Pointer to network buffer to transmit TCP packet.
 *
 * @param    p_buf_hdr           Pointer to network buffer header.
 *
 * @param    tcp_hdr_len_tot     Total TCP header length.
 *
 * @param    tcp_opt_len_tot     Total TCP header options' length.
 *
 * @param    src_addr            Source IP  address.
 *
 * @param    src_port            Source TCP port.
 *
 * @param    dest_addr           Destination IP  address.
 *
 * @param    dest_port           Destination TCP port.
 *
 * @param    seq_nbr             TCP segment sequence number.
 *
 * @param    ack_nbr             TCP segment acknowledgment sequence number.
 *
 * @param    win_size            TCP receive window advertisement size.
 *
 * @param    flags_tcp           Flags to select TCP transmit options; bit-field flags logically OR'd :
 *
 * @param    ---------        NET_TCP_FLAG_NONE               No  TCP transmit flags selected.
 *                                           NET_TCP_FLAG_TX_FIN             Set TCP 'FIN'    flag.
 *                                           NET_TCP_FLAG_TX_SYNC            Set TCP 'SYN'    flag.
 *                                           NET_TCP_FLAG_TX_RESET           Set TCP 'RESET'  flag.
 *                                           NET_TCP_FLAG_TX_PUSH            Set TCP 'PUSH'   flag.
 *                                           NET_TCP_FLAG_TX_ACK             Set TCP 'ACK'    flag.
 *                                           NET_TCP_FLAG_TX_URGENT          Set TCP 'URGENT' flag.
 *
 * @param    p_tcp_hdr_opts      Pointer to TCP options buffer.
 *
 * @param    p_err               Pointer to variable that will receive the return error code from this function.
 *
 * @note     (2) Urgent pointer & data NOT supported (see 'net_tcp.c  Note #1b').
 *
 * @note     (3) (a) TCP header Check-Sum MUST be calculated AFTER the entire TCP header has been prepared.
 *                               In addition, ALL multi-octet words are converted from host-order to network-order
 *                               since "the sum of 16-bit integers can be computed in either byte order" [RFC #1071,
 *                               Section 2.(B)].
 *
 *                                   - (b) TCP header Check-Sum field MUST be cleared to '0' BEFORE the TCP header Check-Sum is
 *                               calculated (see RFC #793, Section 3.1 'Header Format : Checksum').
 *
 *                                   - (c) (1) In addition to the TCP segment header & data, the TCP Check-Sum calculation
 *                               includes "a 96-bit pseudo header conceptually prefixed to the TCP header ...
 *                               [which] contains the Source Address, the Destination Address, the Protocol,
 *                               and TCP length" (see RFC #793, Section 3.1 'Header Format : Checksum').
 *
 *                                   - (2) Since network check-sum functions REQUIRE that 16-bit one's-complement check-
 *                               sum calculations be performed on headers & data arranged in network-order (see
 *                               'net_util.c  NetUtil_16BitOnesCplChkSumDataCalc()  Note #3'), TCP pseudo-header
 *                               values MUST be set or converted to network-order.
 *
 *                                   - (d) RFC #793, Section 3.1 'Header Format : Checksum' specifies that "if a segment contains
 *                               an odd number of header and text octets ... the last octet is padded ... with zeros to
 *                               form a 16-bit word for checksum purposes".
 *
 *                               See also 'net_util.c  NetUtil_16BitSumDataCalc()  Note #8'.
 *
 *                                   - (e) The TCP header Check-Sum field is returned in network-order & MUST NOT be re-
 *                               converted back to host-order (see 'net_util.c  NetUtil_16BitOnesCplChkSumDataCalc()
 *                               Note #4').
 *******************************************************************************************************/
static void NetTCP_TxPktPrepareHdr(NET_BUF          *p_buf,
                                   NET_BUF_HDR      *p_buf_hdr,
                                   CPU_INT16U       tcp_hdr_len_tot,
                                   CPU_INT08U       tcp_opt_len_tot,
                                   CPU_INT16U       addr_size,
                                   void             *p_src_addr,
                                   NET_TCP_PORT_NBR src_port,
                                   void             *p_dest_addr,
                                   NET_TCP_PORT_NBR dest_port,
                                   NET_TCP_SEQ_NBR  seq_nbr,
                                   NET_TCP_SEQ_NBR  ack_nbr,
                                   NET_TCP_WIN_SIZE win_size,
                                   NET_TCP_FLAGS    flags_tcp,
                                   CPU_INT32U       *p_tcp_hdr_opts)
{
  PP_UNUSED_PARAM(p_src_addr);
  PP_UNUSED_PARAM(p_dest_addr);                                 // To avoid warnings

#if ((defined(NET_IPv4_MODULE_EN)) \
  && (!defined(NET_TCP_CHK_SUM_OFFLOAD_TX)))
  NET_IPv4_ADDR      *p_src_addrv4;
  NET_IPv4_ADDR      *p_dest_addrv4;
  NET_TCP_PSEUDO_HDR tcp_pseudo_hdr;
#endif
#if (defined(NET_IPv6_MODULE_EN) \
  && (!defined(NET_TCP_CHK_SUM_OFFLOAD_TX)))
  NET_IPv6_PSEUDO_HDR ipv6_pseudo_hdr;
#endif
  NET_TCP_HDR       *p_tcp_hdr;
  CPU_INT16U        tcp_hdr_len;
  NET_TCP_HDR_FLAGS tcp_flags;
  NET_TCP_HDR_FLAGS tcp_hdr_len_flags;
  CPU_INT16U        tcp_opt_ix;
  NET_CHK_SUM       tcp_chk_sum = 0u;

  //                                                               ----------------- UPDATE BUF CTRLS -----------------
  p_buf_hdr->TransportHdrLen = tcp_hdr_len_tot;
  p_buf_hdr->TransportHdrIx = p_buf_hdr->DataIx - p_buf_hdr->TransportHdrLen;

  p_buf_hdr->TotLen += (NET_BUF_SIZE)p_buf_hdr->TransportHdrLen;
  p_buf_hdr->TransportTotLen = (CPU_INT16U)p_buf_hdr->TotLen;
  p_buf_hdr->TransportDataLen = (CPU_INT16U)p_buf_hdr->DataLen;

  //                                                               ----------------- PREPARE TCP HDR ------------------
  p_tcp_hdr = (NET_TCP_HDR *)&p_buf->DataPtr[p_buf_hdr->TransportHdrIx];

  //                                                               ---------------- PREPARE TCP PORTS -----------------
  NET_UTIL_VAL_COPY_SET_NET_16(&p_tcp_hdr->PortSrc, &src_port);
  NET_UTIL_VAL_COPY_SET_NET_16(&p_tcp_hdr->PortDest, &dest_port);

  //                                                               --------------- PREPARE TCP SEQ NBRS ---------------
  NET_UTIL_VAL_COPY_SET_NET_32(&p_tcp_hdr->SeqNbr, &seq_nbr);
  NET_UTIL_VAL_COPY_SET_NET_32(&p_tcp_hdr->AckNbr, &ack_nbr);

  //                                                               ------------ PREPARE TCP HDR LEN/FLAGS -------------
  tcp_hdr_len = p_buf_hdr->TransportHdrLen / NET_TCP_HDR_LEN_WORD_SIZE;
  tcp_hdr_len <<= NET_TCP_HDR_LEN_SHIFT;

  tcp_flags = (NET_TCP_HDR_FLAGS)NET_TCP_HDR_FLAG_NONE;
  tcp_flags |= (NET_TCP_HDR_FLAGS)flags_tcp;

  tcp_hdr_len &= NET_TCP_HDR_LEN_MASK;
  tcp_flags &= NET_TCP_HDR_FLAG_MASK;

  tcp_hdr_len_flags = (NET_TCP_HDR_FLAGS)tcp_hdr_len  | tcp_flags;
  NET_UTIL_VAL_COPY_SET_NET_16(&p_tcp_hdr->HdrLen_Flags, &tcp_hdr_len_flags);

  //                                                               ----------------- PREPARE TCP WIN ------------------
  NET_UTIL_VAL_COPY_SET_NET_16(&p_tcp_hdr->WinSize, &win_size);

  //                                                               -------------- PREPARE TCP URGENT PTR --------------
  //                                                               See Note #2.
  NET_UTIL_VAL_SET_NET_16(&p_tcp_hdr->UrgentPtr, NET_TCP_HDR_URG_PTR_NONE);

  //                                                               ----------------- PREPARE TCP OPTS -----------------
  if (tcp_opt_len_tot > 0) {
    tcp_opt_ix = p_buf_hdr->TransportHdrIx + NET_TCP_HDR_OPT_IX;
    NetBuf_DataWr(p_buf,
                  tcp_opt_ix,
                  tcp_opt_len_tot,
                  (CPU_INT08U *) p_tcp_hdr_opts);
  }

  //                                                               --------------- PREPARE TCP CHK SUM ----------------
  NET_UTIL_VAL_SET_NET_16(&p_tcp_hdr->ChkSum, 0x0000u);         // Clr TCP chk sum            (see Note #3b).
                                                                // Cfg TCP chk sum pseudo-hdr (see Note #3c).
  if (DEF_BIT_IS_CLR(p_buf_hdr->Flags, NET_BUF_FLAG_IPv6_FRAME)) {
#ifdef  NET_IPv4_MODULE_EN
    p_buf_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V4;
    p_buf_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V4;

#ifdef NET_TCP_CHK_SUM_OFFLOAD_TX
    tcp_chk_sum = 0u;
#else
    p_src_addrv4 = (NET_IPv4_ADDR *)p_src_addr;
    p_dest_addrv4 = (NET_IPv4_ADDR *)p_dest_addr;
    tcp_pseudo_hdr.AddrSrc = (NET_IPv4_ADDR)NET_UTIL_HOST_TO_NET_32(*p_src_addrv4);
    tcp_pseudo_hdr.AddrDest = (NET_IPv4_ADDR)NET_UTIL_HOST_TO_NET_32(*p_dest_addrv4);
    tcp_pseudo_hdr.Zero = 0x00u;
    tcp_pseudo_hdr.Protocol = NET_IP_HDR_PROTOCOL_TCP;
    tcp_pseudo_hdr.TotLen = NET_UTIL_HOST_TO_NET_16(p_buf_hdr->TransportTotLen);
    //                                                             Calc TCP chk sum.
    tcp_chk_sum = NetUtil_16BitOnesCplChkSumDataCalc(p_buf,
                                                     &tcp_pseudo_hdr,
                                                     NET_TCP_PSEUDO_HDR_SIZE);
#endif
#endif
  } else {
#ifdef  NET_IPv6_MODULE_EN
    p_buf_hdr->ProtocolHdrType = NET_PROTOCOL_TYPE_TCP_V6;
    p_buf_hdr->ProtocolHdrTypeTransport = NET_PROTOCOL_TYPE_TCP_V6;

    Mem_Copy(&p_buf_hdr->IPv6_AddrSrc, p_src_addr, NET_IPv6_ADDR_SIZE);
    Mem_Copy(&p_buf_hdr->IPv6_AddrDest, p_dest_addr, NET_IPv6_ADDR_SIZE);

#ifdef NET_TCP_CHK_SUM_OFFLOAD_TX
    tcp_chk_sum = 0u;
#else
    ipv6_pseudo_hdr.AddrSrc = p_buf_hdr->IPv6_AddrSrc;
    ipv6_pseudo_hdr.AddrDest = p_buf_hdr->IPv6_AddrDest;
    ipv6_pseudo_hdr.UpperLayerPktLen = (CPU_INT32U)NET_UTIL_HOST_TO_NET_32(p_buf_hdr->TransportTotLen);
    ipv6_pseudo_hdr.Zero = (CPU_INT16U)0x00u;
    ipv6_pseudo_hdr.NextHdr = (CPU_INT32U)NET_UTIL_HOST_TO_NET_16(NET_IP_HDR_PROTOCOL_TCP);

    tcp_chk_sum = NetUtil_16BitOnesCplChkSumDataCalc(p_buf,
                                                     &ipv6_pseudo_hdr,
                                                     NET_IPv6_PSEUDO_HDR_SIZE);
#endif
#endif
  }

  NET_UTIL_VAL_COPY_16(&p_tcp_hdr->ChkSum, &tcp_chk_sum);       // Copy TCP chk sum in net order (see Note #3e).

  //                                                               ---------------- GET TCP RTT TX TS -----------------
  p_buf_hdr->TCP_RTT_TS_Txd_ms = (NET_TCP_TX_RTT_TS_MS)NetUtil_TS_Get_ms();

  PP_UNUSED_PARAM(addr_size);
}

/****************************************************************************************************//**
 *                                           NetTCP_TxPktFree()
 *
 * @brief    Free network buffer(s).
 *
 * @param    p_buf_q     Pointer to network buffer queue.
 *
 * @note     (1) (a) Although TCP Transmit initially requests the network buffer for transmit, the
 *                       TCP layer maintains a reference to the buffer for possible retransmission.
 *
 *                           - (b) Therefore, even though the network interface transmit deallocation task frees
 *                       ALL unreferenced buffers after successful transmission, the TCP layer MUST free
 *                       buffers which are still referenced.
 *******************************************************************************************************/
static NET_BUF_QTY NetTCP_TxPktFree(NET_BUF *p_buf_q)
{
  NET_BUF_QTY qty;

  qty = NetBuf_FreeBufQ_PrimList(p_buf_q, DEF_NULL);

  return (qty);
}

/****************************************************************************************************//**
 *                                           NetTCP_TxPktDiscard()
 *
 * @brief    On any TCP transmit packet error(s), discard TCP packet(s) & buffer(s).
 *
 * @param    p_buf   Pointer to network buffer.
 *
 * @note     (1) Since some TCP Transmit packets are passed the network buffer from other TCP functions,
 *                   they may NOT be the buffers' only references & MUST therefore check buffers' reference
 *                   counter before freeing buffers.
 *******************************************************************************************************/
static void NetTCP_TxPktDiscard(NET_BUF *p_buf)
{
  NET_CTR *p_ctr;

#if (NET_CTR_CFG_ERR_EN == DEF_ENABLED)
  p_ctr = &Net_ErrCtrs.TCP.TxPktDiscardedCtr;
#else
  p_ctr = DEF_NULL;
#endif
  (void)NetBuf_FreeBufQ_PrimList(p_buf, p_ctr);
}

/****************************************************************************************************//**
 *                                               NetTCP_ConnCfg()
 *
 * @brief    (1) Configure TCP connection's controls :
 *
 *           - (a) Configure  TCP connection's connection maximum segment size         See Note #2
 *           - (b) Configure  TCP connection's receive  window controls                See Note #3
 *           - (c) Configure  TCP connection's transmit window controls                See Note #4
 *           - (d) Initialize TCP connection's transmit round-trip time &
 *                                           re-transmit timeout controls
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    cfg_code    Select which close action(s) to perform; bit-field flags logically OR'd :
 *                       NET_TCP_CONN_CFG_NONE                   Perform NO  configuration actions.
 *                       NET_TCP_CONN_CFG_ALL                    Perform ALL configuration actions.
 *                       NET_TCP_CONN_CFG_MAX_SEG_SIZE_LOCAL     Configure local      maximum segment size.
 *                       NET_TCP_CONN_CFG_MAX_SEG_SIZE_REMOTE    Configure remote     maximum segment size.
 *                       NET_TCP_CONN_CFG_MAX_SEG_SIZE_CONN      Configure connection maximum segment size.
 *                       NET_TCP_CONN_CFG_MAX_SEG_SIZE_ALL       Configure ALL        maximum segment sizes.
 *                       NET_TCP_CONN_CFG_WIN_SIZE_RX            Configure receive    window size(s).
 *                       NET_TCP_CONN_CFG_WIN_SIZE_TX            Configure transmit   window size(s).
 *                       NET_TCP_CONN_CFG_WIN_SIZE_CONN          Configure connection window size(s).
 *                       NET_TCP_CONN_CFG_WIN_SIZE_ALL           Configure ALL        window sizes.
 *                       NET_TCP_CONN_CFG_TX_RTT_RTO             Configure transmit round-trip time (RTT)
 *                       & re-transmit timeout (RTO) control(s).
 *                       See also 'TCP CONNECTION CONFIGURATION CODE DEFINES'.
 *
 * @note     (2) A TCP connection's connection maximum segment size should NOT be updated until
 *                       after certain other TCP connection control(s) have been configured.
 *
 *                       See also 'NetTCP_ConnCfgMaxSegSize()   Note #3'.
 *
 * @note     (3) A TCP connection's receive  window controls should NOT be updated until after
 *                       certain other TCP connection control(s) have been configured.
 *
 *                       See also 'NetTCP_RxConnWinSizeCfg()    Note #2'.
 *
 * @note     (4) A TCP connection's transmit window controls should NOT be updated until after
 *                       certain other TCP connection control(s) have been configured.
 *
 *                       See also 'NetTCP_TxConnWinSizeCfg()    Note #2'.
 *
 * @note     (5) A TCP connection's transmit round-trip time & re-transmit timeout controls
 *                       should NOT be updated until after certain other TCP connection control(s)
 *                       have been configured.
 *
 *                       See also 'NetTCP_TxConnRTT_RTO_Init()  Note #1'.
 *******************************************************************************************************/
static void NetTCP_ConnCfg(NET_TCP_CONN     *p_conn,
                           NET_TCP_CFG_CODE cfg_code)
{
  CPU_BOOLEAN cfg_conn_max_seg_size;
  CPU_BOOLEAN cfg_conn_win_size;
  CPU_BOOLEAN cfg_conn_tx_rtt_rto;

  cfg_conn_max_seg_size = DEF_BIT_IS_SET(cfg_code, NET_TCP_CONN_CFG_MAX_SEG_SIZE_CONN);
  if (cfg_conn_max_seg_size == DEF_YES) {
    NetTCP_ConnCfgMaxSegSize(p_conn);                           // Cfg  conn max seg size  (see Note #2).
  }

  cfg_conn_win_size = DEF_BIT_IS_SET(cfg_code, NET_TCP_CONN_CFG_WIN_SIZE_RX);
  if (cfg_conn_win_size == DEF_YES) {
    NetTCP_RxConnWinSizeCfg(p_conn);                            // Cfg  rx win ctrls       (see Note #3).
  }

  cfg_conn_win_size = DEF_BIT_IS_SET(cfg_code, NET_TCP_CONN_CFG_WIN_SIZE_TX);
  if (cfg_conn_win_size == DEF_YES) {
    NetTCP_TxConnWinSizeCfg(p_conn);                            // Cfg  tx win ctrls       (see Note #4).
  }

  cfg_conn_tx_rtt_rto = DEF_BIT_IS_SET(cfg_code, NET_TCP_CONN_CFG_TX_RTT_RTO);
  if (cfg_conn_tx_rtt_rto == DEF_YES) {
    NetTCP_TxConnRTT_RTO_Init(p_conn);                          // Init tx RTT / RTO ctrls (see Note #5).
  }
}

/****************************************************************************************************//**
 *                                       NetTCP_ConnCfgMaxSegSize()
 *
 * @brief    Configure TCP connection's maximum segment size.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) RFC #1122, Section 4.2.2.6 states that "the maximum size of a segment that TCP really
 *                   sends, the 'effective send MSS', MUST be the smaller of the send MSS ... and ... less
 *                   than or equal to ... the maximum size ... that can be received".
 *
 * @note     (2) In order to avoid transmit window deadlock with a remote host's receive window, the
 *                   TCP connection's connection maximum segment size MUST be configured to ensure that
 *                   full, maximum-segment-sized segments will transmit even for receive windows less than
 *                   the default maximum segment size.
 *
 *                       - (a) RFC #1122, Section 4.2.3.4.(3) states to "send data ... if at least a fraction Fs
 *                   of the maximum window can be sent ... Fs is a fraction whose recommended value is
 *                   1/2".
 *
 *                   Thus it seems reasonable to calculate & limit the remote host's maximum window
 *                   size by a similar fraction.
 *
 * @note     (3) A TCP connection's connection maximum segment size should NOT be updated until after
 *                   the following TCP connection control(s) have been configured :
 *
 *                       - (a) TCP connection's local  maximum segment size ('MaxSegSizeLocal')
 *                   [see 'NetTCP_ConnClr()  Note #3a']
 *
 *                       - (b) TCP connection's remote maximum segment size ('MaxSegSizeRemote')
 *                   [see 'NetTCP_RxPktConnHandlerListen()   Note #7'
 *                   & 'NetTCP_RxPktConnHandlerSyncTxd()  Note #3']
 *
 *                       - (c) TCP connection's maximum transmit remote window size ('TxWinSizeRemoteMax')
 *                   [see 'NetTCP_RxPktConnHandlerTxWinRemote()   Note  #1a2A'
 *                   & 'NetTCP_TxConnWinSizeHandlerCongCtrl()  Notes #3a2A & #3b']
 *******************************************************************************************************/
static void NetTCP_ConnCfgMaxSegSize(NET_TCP_CONN *p_conn)
{
  NET_TCP_WIN_SIZE remote_win_size_th;
  NET_TCP_SEG_SIZE remote_max_seg_size;

  //                                                               Calc remote max seg size (see Note #2).
  remote_win_size_th = (NET_TCP_WIN_SIZE)(((CPU_INT32U)p_conn->TxWinSizeRemoteMax * NET_TCP_TX_SILLY_WIN_NUMER)
                                          / NET_TCP_TX_SILLY_WIN_DENOM);
  remote_max_seg_size = (NET_TCP_SEG_SIZE)DEF_MIN(p_conn->MaxSegSizeRemote,
                                                  remote_win_size_th);

  //                                                               Cfg conn max seg size    (see Note #1).
  p_conn->MaxSegSizeConn = (NET_TCP_SEG_SIZE)DEF_MIN(p_conn->MaxSegSizeLocalActual,
                                                     remote_max_seg_size);
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnIdleTimeout()
 *
 * @brief    (1) Handle an idle TCP connection on timeout :
 *
 *           - (a) Clear TCP connection's idle connection timer            See Notes #4a1A & #4a2
 *
 *           - (b) (1) If enabled,  handle TCP connection keep-alive for the following states :
 *
 *                   - (A) ESTABLISHED                                     See Note  #2b1
 *                   - (B) CLOSE-WAIT                                      See Note  #2b2
 *
 *               - (2) Otherwise, close TCP connection
 *
 *
 * Argument(s) : p_conn_timeout       Pointer to a TCP connection (see Note #3b).
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) RFC #1122, Section 4.2.3.6 states that "TCP ... MAY ... periodically [probe]
 *                   the other end of a connection when the connection is ... idle".
 *
 *                   (a) Stevens, TCP/IP Illustrated, Volume 1, 8th Printing, Section 23.2,
 *                       Pages 332-333 adds that "if there is no activity on a given connection
 *                       for 2 hours", TCP "sends a [keep-alive] probe segment to the" remote host.
 *
 *                   (b) Wright/Stevens, TCP/IP Illustrated, Volume 2, 3rd Printing, Section 25.6
 *                       'Connection Establishment and Keepalive Timers : Keepalive timer expires
 *                       after 2 hours of idle time', Page 829 states that TCP "keepalive probes
 *                       ... are sent only if the connection is in the" :
 *
 *                       (1) "ESTABLISHED or" ...
 *                       (2) "CLOSE_WAIT states."
 *
 *                   (c) Although NO RFC explicitly states that a TCP connection should or should
 *                       not transmit a TCP reset segment when  a TCP connection is closed due to
 *                       a lack of response to all keep-alive probe segments from the remote host,
 *                       it seems implied & reasonable that a TCP reset is unnecessary since the
 *                       remote host has not replied to any TCP keep-alive probe segments.
 *
 *                       See also 'NetTCP_TxConnKeepAlive()  Note #2c2B'.
 *
 *                   See also 'NetTCP_TxConnKeepAlive()  Note #2'.
 *
 *               (3) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
 *                   type functions -- even though network timer API functions cast callback functions
 *                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
 *
 *                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
 *                           to an object ... may be converted to a pointer to a different object ...
 *                           [but] if the resulting pointer is not correctly aligned ... the behavior
 *                           is undefined".
 *
 *                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
 *                           pointer arguments, network timer callback functions MUST avoid incorrect
 *                           pointer conversion behavior between 'void' pointer parameters & non-'void'
 *                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
 *
 *                               - (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
 *                           to or from a pointer to any ... object ... A pointer to any ... object ...
 *                           may be converted to a pointer to void and back again; the result shall
 *                           compare equal to the original pointer".
 *
 *                               - (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
 *                           network object pointer objects, network timer callback functions MUST :
 *
 *                               - (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
 *                               - (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
 *                               - (A) in this case, a 'NET_TCP_CONN' pointer.
 *
 *                           See also 'net_tmr.c  NetTmr_Get()  Note #3'.
 *
 * @note     (4) This function is a network timer callback function :
 *
 *                               - (a) (1) For the following connection timer(s) ... :
 *
 *                               - (A) TCP connection timeout timer ('TimeoutTmr')
 *
 *                               - (2) (A) Clear the timer pointer ... :
 *                               - (1) Cleared prior to next handler function(s).
 *
 *                               - (B) but do NOT re-free the timer.
 *
 *                               - (b) Do NOT set the following close timer flag(s) :
 *
 *                               - (1) NET_TCP_CONN_CLOSE_TMR_TIMEOUT
 *******************************************************************************************************/
static void NetTCP_ConnIdleTimeout(void *p_conn_timeout)
{
  NET_TCP_CONN       *p_conn;
  NET_TCP_CLOSE_CODE close_code;
  CPU_BOOLEAN        used;
  RTOS_ERR           local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  p_conn = (NET_TCP_CONN *)p_conn_timeout;                      // See Note #3b2A.

  used = DEF_BIT_IS_SET(p_conn->Flags, NET_TCP_FLAG_USED);
  if (used != DEF_YES) {
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
    goto exit;
  }

  //                                                               --------------- HANDLE IDLE TCP CONN ---------------
  close_code = NET_TCP_CONN_CLOSE_ALL;
  //                                                               See Note #4b1.
  DEF_BIT_CLR(close_code, (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_TMR_TIMEOUT);

  p_conn->TimeoutTmr = DEF_NULL;                                // Clr TCP conn tmr (see Note #4a2A1).

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidOpCtr);
      goto exit;
    //                                                             ----------- HANDLE TCP CONN KEEP-ALIVES ------------
    case NET_TCP_CONN_STATE_CONN:                               // See Note #1b1.
    case NET_TCP_CONN_STATE_CLOSE_WAIT:                         // See Note #1b2.
      if (p_conn->TxKeepAliveEn == DEF_ENABLED) {               // If en'd, ...
                                                                // See Note #2c.
        DEF_BIT_CLR(close_code, (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_CONN_TX_RESET);
        //                                                         ... handle keep-alives (see Note #2).
        NetTCP_TxConnKeepAlive(p_conn, close_code, &local_err);
        PP_UNUSED_PARAM(local_err);                             // Ignore ALL err(s), transitory or fatal.
        goto exit;
      }
    //                                                             'break' intentionally omitted; MUST ...
    //                                                             ... execute the following code block :
    //                                                             -------------- ... 'CLOSE TCP CONN'. ---------------
    //                                                             ------------------ CLOSE TCP CONN ------------------
    //                                                             fallthrough
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      if (p_conn->ConnCloseTimeoutFaultFlag != DEF_NO) {        // If TCP conn timeout fault, ...
                                                                // ... fault-close TCP conn.
        NetTCP_ConnClose(p_conn,
                         DEF_NULL,
                         p_conn->ConnCloseAppFlag,
                         close_code);
      } else {                                                  // Else      close TCP conn.
        NetTCP_ConnCloseHandler(p_conn,
                                p_conn->ConnCloseAppFlag,
                                close_code);
      }
      break;

    case NET_TCP_CONN_STATE_FREE:
    case NET_TCP_CONN_STATE_NONE:
    default:
      NetTCP_ConnClose(p_conn, DEF_NULL, DEF_YES, close_code);
      NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnInvalidStateCtr);
      goto exit;
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnClose()
 *
 * @brief    (1) Close a TCP connection due to TCP connection fault(s) :
 *
 *           - (a) Update   TCP connection close statistic(s)
 *           - (b) Transmit TCP connection reset to remote host                    See Note #4
 *           - (c) Close    TCP connection
 *
 *       - (2) TCP connection closed internally by TCP layer when certain TCP connection parameters
 *               are corrupted or when certain valid TCP connection operations fail.
 *
 *       - (3) Since the mechanisms of TCP connection close are independent of the application layer
 *               close; TCP connection MAY need to close application layer connection(s).
 *
 *               See also 'NetTCP_ConnCloseHandler()  Note #2b'.
 *
 * @param    p_conn          Pointer to a TCP connection.
 *
 * @param    p_buf_hdr       Pointer to network buffer header that received TCP packet.
 *
 * @param    close_conn_app  Indicate whether to close application connection (see Note #3):
 *                           DEF_YES                        Close application connection.
 *                           DEF_NO                  Do NOT close application connection.
 *
 * @param    close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
 *                           NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
 *                           NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
 *                           NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
 *                           NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
 *                           NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
 *                           NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
 *                           NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
 *                           See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *
 * @note     (4) Although NO RFC directly states to transmit a TCP reset segment when a TCP connection
 *                           fault-closes, it is inferred & seems reasonable that a TCP reset segment SHOULD be
 *                           transmitted whenever a TCP connection closes abnormally from any of the following
 *                           synchronization/connected/closing states :
 *
 *                               - (a) SYN-RECEIVED
 *                               - (b) SYN-SENT
 *                               - (c) ESTABLISHED
 *                               - (d) FIN-WAIT-1
 *                               - (e) FIN-WAIT-2
 *                               - (f) CLOSING
 *                               - (g) TIME_WAIT
 *                               - (h) CLOSE-WAIT
 *                               - (i) LAST-ACK
 *
 *                           See also 'NetTCP_TxConnReset()  Note #4b'.
 *
 * @note     (5) On any TCP connection handler function fault(s), TCP connection MUST NEVER be re-closed.
 *
 *                           See also 'NetTCP_ConnCloseHandler()  Note #4'.
 *******************************************************************************************************/
static void NetTCP_ConnClose(NET_TCP_CONN       *p_conn,
                             NET_BUF_HDR        *p_buf_hdr,
                             CPU_BOOLEAN        close_conn_app,
                             NET_TCP_CLOSE_CODE close_code)
{
  CPU_BOOLEAN tx_reset;
  RTOS_ERR    local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  //                                                               ---------------- UPDATE CLOSE STATS ----------------
  NET_CTR_ERR_INC(Net_ErrCtrs.TCP.ConnCloseCtr);

  //                                                               ---------------- TX TCP CONN RESET -----------------
  tx_reset = DEF_BIT_IS_SET(close_code, NET_TCP_CONN_CLOSE_CONN_TX_RESET);
  if (tx_reset == DEF_YES) {                                    // Tx TCP conn reset (see Note #4).
    NetTCP_TxConnReset(p_conn,
                       p_buf_hdr,
                       NET_TCP_CONN_TX_RESET_FAULT,
                       NET_TCP_CONN_CLOSE_NONE,                 // MUST NOT re-close TCP conn (see Note #5).
                       &local_err);
  }

  //                                                               ------------------ CLOSE TCP CONN ------------------
  NetTCP_ConnCloseHandler(p_conn, close_conn_app, close_code);
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnCloseHandler()
 *
 * @brief    (1) Close a TCP connection :
 *
 *           - (a) Close network connection(s)                                 See Note #2
 *           - (b) Free  TCP     connection
 *
 *       - (2) (a) TCP connection's network     connection(s) MUST be closed BEFORE the TCP connection
 *                   is closed/freed.
 *
 *           - (b) TCP connection's application connection(s) :
 *
 *               - (1) MAY be CLOSED &/or reset :
 *
 *                   - (A) For the following TCP connection condition(s), the TCP connection MUST
 *                           close the application connection(s) :
 *
 *                       - (1) (a) Invalid TCP connection parameters :
 *                               - (1) Invalid TCP connection state(s)
 *                               - (2) Invalid/corrupted TCP data queue(s) :
 *                                   - (A) Invalid sequence numbers
 *                                   - (B) Invalid segment  lengths
 *
 *                           - (b) Fatal TCP transmit     fault(s)
 *                           - (c) TCP connection closing fault(s)
 *
 *                       - (2) Invalid network connection configuration
 *
 *                   - (B) For the following TCP connection condition(s), the TCP connection SHOULD
 *                           close the application connection(s) based on its application close flag
 *                           ('ConnCloseAppFlag') :
 *
 *                       - (1) Valid TCP connection closing states/timeouts
 *
 *                   - (C) For the following TCP connection condition(s), the TCP connection MAY --
 *                           but is NOT required to -- close the application connection(s) :
 *
 *                       - (1) Initial TCP connection configuration/preparation
 *
 *               - (2) But possibly NOT freed, since some application connections have NO mechanism
 *                       or API to close an application's reference to the connection.
 *
 *                   See also specific application connection close function(s) for additional notes.
 *
 * @param    p_conn          Pointer to a TCP connection.
 *
 * @param    close_conn_app  Indicate whether to close application connection (see Note #2b):
 *                           DEF_YES                        Close application connection.
 *                           DEF_NO                  Do NOT close application connection.
 *
 * @param    close_code      Select which close action(s) to perform; bit-field flags logically OR'd :
 *                           NET_TCP_CONN_CLOSE_NONE                 Perform NO  close actions.
 *                           NET_TCP_CONN_CLOSE_ALL                  Perform ALL close actions.
 *                           NET_TCP_CONN_CLOSE_CONN_TX_RESET        Perform close connection transmit reset.
 *                           NET_TCP_CONN_CLOSE_CONN_ALL             Perform ALL   connection close    actions.
 *                           NET_TCP_CONN_CLOSE_TMR_TIMEOUT          Close connection                        timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_IDLE          Close    transmit idle                  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_SILLY_WIN     Close    transmit silly window persist  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_ZERO_WIN      Close    transmit zero  window persist  timer.
 *                           NET_TCP_CONN_CLOSE_TMR_TX_ACK_DLY       Close    transmit acknowledgement delay timer.
 *                           NET_TCP_CONN_CLOSE_TMR_RE_TX            Close re-transmit                       timer.
 *                           NET_TCP_CONN_CLOSE_TMR_ALL              Close ALL                               timers.
 *                           See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *
 * @note     (3) TCP connection free codes are identical to TCP connection close codes.
 *
 *                           See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES  Note #2'.
 *
 * @note     (4) On any TCP connection close, TCP connection MUST NEVER be re-closed.
 *******************************************************************************************************/
static void NetTCP_ConnCloseHandler(NET_TCP_CONN       *p_conn,
                                    CPU_BOOLEAN        close_conn_app,
                                    NET_TCP_CLOSE_CODE close_code)
{
  NET_CONN_ID       conn_id = p_conn->ID_Conn;
  NET_TCP_FREE_CODE free_code;

  switch (p_conn->ConnState) {
    case NET_TCP_CONN_STATE_CLOSED:
    case NET_TCP_CONN_STATE_LISTEN:
    case NET_TCP_CONN_STATE_SYNC_RXD:
    case NET_TCP_CONN_STATE_SYNC_RXD_PASSIVE:
    case NET_TCP_CONN_STATE_SYNC_RXD_ACTIVE:
    case NET_TCP_CONN_STATE_SYNC_TXD:
    case NET_TCP_CONN_STATE_CONN:
    case NET_TCP_CONN_STATE_FIN_WAIT_1:
    case NET_TCP_CONN_STATE_FIN_WAIT_2:
    case NET_TCP_CONN_STATE_CLOSING:
    case NET_TCP_CONN_STATE_TIME_WAIT:
    case NET_TCP_CONN_STATE_CLOSE_WAIT:
    case NET_TCP_CONN_STATE_LAST_ACK:
    case NET_TCP_CONN_STATE_CLOSING_DATA_AVAIL:
      break;

    case NET_TCP_CONN_STATE_NONE:                               // MUST NOT re-close TCP conn if already ...
    case NET_TCP_CONN_STATE_FREE:                               // ... freed/closed (see Note #4).
    default:
      return;
  }
  //                                                               ------------------ FREE TCP CONN -------------------
  free_code = (NET_TCP_FREE_CODE)close_code;                    // See Note #3.
  NetTCP_ConnFreeHandler(p_conn, free_code);

  //                                                               ------------------ CLOSE CONN(S) -------------------
  NetConn_CloseFromTransport(conn_id, close_conn_app);
}

/****************************************************************************************************//**
 *                                   NetTCP_ConnClosingTimeoutDataAvail()
 *
 * @brief    (1) Handle closing TCP connection with available application data :
 *
 *           - (a) If TCP connection's application receive queue is       now empty,
 *                       close the TCP connection
 *           - (b) If TCP connection's application receive queue is still NOT empty
 *                       after the time-wait timeout, set the user connection timeout
 *
 *               See also 'NetTCP_RxPktConnHandlerFinWait1()  Note #2f5A2b',
 *                       'NetTCP_RxPktConnHandlerFinWait2()  Note #2f5B2',
 *                       & 'NetTCP_RxPktConnHandlerClosing()   Note #2d2B2a1B2'.
 *
 *
 * Argument(s) : p_conn_timeout       Pointer to a TCP connection (see Note #2b).
 *
 * Return(s)   : none.
 *
 * Note(s)     : (2) Ideally, network timer callback functions could be defined as '[(void) (OBJECT *)]'
 *                   type functions -- even though network timer API functions cast callback functions
 *                   to generic 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]').
 *
 *                   (a) (1) Unfortunately, ISO/IEC 9899:TC2, Section 6.3.2.3.(7) states that "a pointer
 *                           to an object ... may be converted to a pointer to a different object ...
 *                           [but] if the resulting pointer is not correctly aligned ... the behavior
 *                           is undefined".
 *
 *                           And since compilers may NOT correctly convert 'void' pointers to non-'void'
 *                           pointer arguments, network timer callback functions MUST avoid incorrect
 *                           pointer conversion behavior between 'void' pointer parameters & non-'void'
 *                           pointer arguments & therefore CANNOT be defined as '[(void) (OBJECT *)]'.
 *
 *                               - (2) However, Section 6.3.2.3.(1) states that "a pointer to void may be converted
 *                           to or from a pointer to any ... object ... A pointer to any ... object ...
 *                           may be converted to a pointer to void and back again; the result shall
 *                           compare equal to the original pointer".
 *
 *                               - (b) Therefore, to correctly convert 'void' pointer objects back to appropriate
 *                           network object pointer objects, network timer callback functions MUST :
 *
 *                               - (1) Be defined as 'CPU_FNCT_PTR' type (i.e. '[(void) (void *)]'); &       ...
 *                               - (2) Explicitly cast 'void' pointer arguments to specific object pointers; ...
 *                               - (A) in this case, a 'NET_TCP_CONN' pointer.
 *
 *                           See also 'net_tmr.c  NetTmr_Get()  Note #3'.
 *
 * @note     (3) This function is a network timer callback function :
 *
 *                               - (a) (1) For the following connection timer(s) ... :
 *
 *                               - (A) TCP connection timeout timer ('TimeoutTmr')
 *
 *                               - (2) (A) Clear the timer pointer ... :
 *                               - (1) Cleared in NetTCP_ConnFreeTmr() via NetTCP_ConnCloseHandler(),
 *                           NetTCP_ConnClose(); or
 *                               - (2) Reset   by NetTmr_Get().
 *
 *                               - (B) but do NOT re-free the timer.
 *
 *                               - (b) Do NOT set the following close timer flag(s) :
 *
 *                               - (1) NET_TCP_CONN_CLOSE_TMR_TIMEOUT
 *
 * @note     (4) RFC #793, Section 3.9 'Event Processing : USER TIMEOUT : USER TIMEOUT' states that
 *                           "for any state if the user timeout expires, flush all queues, signal the user
 *                           'error : connection aborted due to user timeout' ... [and] enter the CLOSED state".
 *******************************************************************************************************/
static void NetTCP_ConnClosingTimeoutDataAvail(void *p_conn_timeout)
{
  NET_TCP_CONN       *p_conn;
  NET_TCP_CLOSE_CODE close_code;
  CPU_BOOLEAN        data_avail;
  CPU_BOOLEAN        used;
  CPU_INT32U         timeout_ms;
  RTOS_ERR           local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  p_conn = (NET_TCP_CONN *)p_conn_timeout;                      // See Note #2b2A.

  used = DEF_BIT_IS_SET(p_conn->Flags, NET_TCP_FLAG_USED);
  if (used != DEF_YES) {
    NET_CTR_ERR_INC(Net_ErrCtrs.TCP.NotUsedCtr);
    goto exit;
  }

  close_code = NET_TCP_CONN_CLOSE_ALL;
  //                                                               See Note #3b1.
  DEF_BIT_CLR(close_code, (NET_TCP_CLOSE_CODE)NET_TCP_CONN_CLOSE_TMR_TIMEOUT);

  p_conn->TimeoutTmr = DEF_NULL;

  //                                                               Closing data avail for half-closed conns ONLY.
  data_avail = ((p_conn->ConnCloseCode != NET_CONN_CLOSE_HALF)
                || ((p_conn->RxQ_State == NET_TCP_RX_Q_STATE_CLOSED)
                    && (p_conn->RxQ_App_Head == DEF_NULL))) ? DEF_NO : DEF_YES;

  if (data_avail != DEF_YES) {                                  // If NO app data avail, ...
                                                                // ... close TCP conn  (see Note  #1a).
    NetTCP_ConnCloseHandler(p_conn,
                            p_conn->ConnCloseAppFlag,
                            close_code);
  } else {                                                      // Else reset user tmr (see Notes #1b & #4).
    timeout_ms = p_conn->TimeoutUser_sec * DEF_TIME_NBR_mS_PER_SEC;
    p_conn->TimeoutTmr = NetTmr_Get(NetTCP_ConnIdleTimeout,
                                    p_conn,
                                    timeout_ms,
                                    NET_TMR_OPT_NONE,
                                    &local_err);
    if (RTOS_ERR_CODE_GET(local_err) != RTOS_ERR_NONE) {
      NetTCP_ConnClose(p_conn, DEF_NULL, p_conn->ConnCloseAppFlag, close_code);
      goto exit;
    }

    p_conn->ConnCloseAppFlag = DEF_YES;
  }

exit:
  return;
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnFreeHandler()
 *
 * @brief    (1) Free a TCP connection :
 *
 *           - (a) Free   TCP connection timers
 *           - (b) Free   TCP connection packet buffer queues
 *           - (c) Clear  TCP connection controls
 *           - (d) Free   TCP connection back to TCP connection pool
 *           - (e) Update TCP connection pool statistics
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    free_code   Select which free action(s) to perform; bit-field flags logically OR'd :
 *                       NET_TCP_CONN_FREE_TMR_NONE              Free NO                                timers.
 *                       NET_TCP_CONN_FREE_TMR_ALL               Free ALL                               timers.
 *                       NET_TCP_CONN_FREE_TMR_TIMEOUT           Free connection                        timer.
 *                       NET_TCP_CONN_FREE_TMR_TX_IDLE           Free    transmit idle                  timer.
 *                       NET_TCP_CONN_FREE_TMR_TX_SILLY_WIN      Free    transmit silly window persist  timer.
 *                       NET_TCP_CONN_FREE_TMR_TX_ZERO_WIN       Free    transmit zero  window persist  timer.
 *                       NET_TCP_CONN_FREE_TMR_TX_ACK_DLY        Free    transmit acknowledgement delay timer.
 *                       NET_TCP_CONN_FREE_TMR_RE_TX             Free re-transmit                       timer.
 *                       See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *
 * @note     (2) ALL network resources linked to the TCP connection MUST be freed PRIOR to TCP connection
 *                       free or discard so that no network resources are lost.
 *******************************************************************************************************/
static void NetTCP_ConnFreeHandler(NET_TCP_CONN      *p_conn,
                                   NET_TCP_FREE_CODE free_code)
{
  RTOS_ERR local_err;

  RTOS_ERR_SET(local_err, RTOS_ERR_NONE);

  //                                                               FREE TCP CONN TMR's
  NetTCP_ConnFreeTmr(p_conn, free_code);

  //                                                               FREE TCP CONN Q's
  NetTCP_ConnFreeBufQ(&p_conn->RxQ_Transport_Head, &p_conn->RxQ_Transport_Tail);
  NetTCP_ConnFreeBufQ(&p_conn->RxQ_App_Head, &p_conn->RxQ_App_Tail);
  NetTCP_ConnFreeBufQ(&p_conn->TxQ_Head, &p_conn->TxQ_Tail);
  NetTCP_ConnFreeBufQ(&p_conn->ReTxQ_Head, &p_conn->ReTxQ_Tail);

  NetTCP_RxQ_Abort(p_conn->ID);                                 // Abort wait on TCP conn rx Q.

  NetTCP_RxQ_Clr(p_conn->ID);                                   // Clr TCP conn rx Q.

  NetTCP_TxQ_Abort(p_conn->ID);                                 // Abort wait on TCP conn tx Q.

  NetTCP_TxQ_Clr(p_conn->ID);                                   // Clr TCP conn tx Q.

  //                                                               ------------------- CLR TCP CONN -------------------
  p_conn->ConnState = NET_TCP_CONN_STATE_FREE;                  // Set TCP conn as freed/NOT used.
  DEF_BIT_CLR(p_conn->Flags, (NET_TCP_FLAGS)NET_TCP_FLAG_USED);

#if (NET_DBG_CFG_MEM_CLR_EN == DEF_ENABLED)
  NetTCP_ConnClr(p_conn);
#endif

  p_conn->ID_Conn = NET_CONN_ID_NONE;                           // Clr TCP conn's net conn id.

  //                                                               ------------------ FREE TCP CONN -------------------
  p_conn->NextPtr = NetTCP_ConnPoolPtr;
  NetTCP_ConnPoolPtr = p_conn;

#if (NET_STAT_POOL_TCP_CONN_EN == DEF_ENABLED)
  //                                                               ------------ UPDATE TCP CONN POOL STATS ------------
  NetStat_PoolEntryUsedDec(&NetTCP_ConnPoolStat, &local_err);
#endif

  PP_UNUSED_PARAM(local_err);
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnFreeTmr()
 *
 * @brief    Clear TCP connection's timers.
 *
 * @param    p_conn      Pointer to a TCP connection.
 *
 * @param    free_code   Select which free action(s) to perform; bit-field flags logically OR'd :
 *                       NET_TCP_CONN_FREE_TMR_NONE              Free NO                                timers.
 *                       NET_TCP_CONN_FREE_TMR_ALL               Free ALL                               timers.
 *                       NET_TCP_CONN_FREE_TMR_TIMEOUT           Free connection                        timer.
 *                       NET_TCP_CONN_FREE_TMR_TX_IDLE           Free    transmit idle                  timer.
 *                       NET_TCP_CONN_FREE_TMR_TX_SILLY_WIN      Free    transmit silly window persist  timer.
 *                       NET_TCP_CONN_FREE_TMR_TX_ZERO_WIN       Free    transmit zero  window persist  timer.
 *                       NET_TCP_CONN_FREE_TMR_TX_ACK_DLY        Free    transmit acknowledgement delay timer.
 *                       NET_TCP_CONN_FREE_TMR_RE_TX             Free re-transmit                       timer.
 *                       See also 'TCP CONNECTION CLOSE/FREE CODE DEFINES'.
 *******************************************************************************************************/
static void NetTCP_ConnFreeTmr(NET_TCP_CONN      *p_conn,
                               NET_TCP_FREE_CODE free_code)
{
  CPU_BOOLEAN free_tmr;

  free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_TIMEOUT);
  if (free_tmr == DEF_YES) {
    if (p_conn->TimeoutTmr != DEF_NULL) {
      NetTmr_Free(p_conn->TimeoutTmr);
      p_conn->TimeoutTmr = DEF_NULL;
    }
  }

  free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_TX_IDLE);
  if (free_tmr == DEF_YES) {
    if (p_conn->TxQ_IdleTmr != DEF_NULL) {
      NetTmr_Free(p_conn->TxQ_IdleTmr);
      p_conn->TxQ_IdleTmr = DEF_NULL;
    }
  }

  free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_TX_SILLY_WIN);
  if (free_tmr == DEF_YES) {
    if (p_conn->TxQ_SillyWinTmr != DEF_NULL) {
      NetTmr_Free(p_conn->TxQ_SillyWinTmr);
      p_conn->TxQ_SillyWinTmr = DEF_NULL;
    }
  }

  free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_TX_ZERO_WIN);
  if (free_tmr == DEF_YES) {
    if (p_conn->TxQ_ZeroWinTmr != DEF_NULL) {
      NetTmr_Free(p_conn->TxQ_ZeroWinTmr);
      p_conn->TxQ_ZeroWinTmr = DEF_NULL;
    }
  }

  free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_TX_ACK_DLY);
  if (free_tmr == DEF_YES) {
    if (p_conn->TxAckDlyTmr != DEF_NULL) {
      NetTmr_Free(p_conn->TxAckDlyTmr);
      p_conn->TxAckDlyTmr = DEF_NULL;
    }
  }

  free_tmr = DEF_BIT_IS_SET(free_code, NET_TCP_CONN_FREE_TMR_RE_TX);
  if (free_tmr == DEF_YES) {
    if (p_conn->ReTxQ_Tmr != DEF_NULL) {
      NetTmr_Free(p_conn->ReTxQ_Tmr);
      p_conn->ReTxQ_Tmr = DEF_NULL;
    }
  }
}

/****************************************************************************************************//**
 *                                           NetTCP_ConnFreeBufQ()
 *
 * @brief    Free a TCP connection's buffer queue.
 *
 * @param    p_buf_q_head    Pointer to a TCP connection buffer queue's head pointer.
 *
 * @param    p_buf_q_tail    Pointer to a TCP connection buffer queue's tail pointer.
 *******************************************************************************************************/
static void NetTCP_ConnFreeBufQ(NET_BUF **p_buf_q_head,
                                NET_BUF **p_buf_q_tail)
{
  NET_BUF *p_buf_q;

  //                                                               Free buf Q.
  p_buf_q = *p_buf_q_head;
  (void)NetBuf_FreeBufQ_PrimList(p_buf_q, DEF_NULL);
  //                                                               Clr  buf Q ptrs to NULL.
  *p_buf_q_head = DEF_NULL;
  *p_buf_q_tail = DEF_NULL;
}

/****************************************************************************************************//**
 *                                               NetTCP_ConnClr()
 *
 * @brief    Clear TCP connection controls.
 *
 * @param    p_conn  Pointer to a TCP connection.
 *
 * @note     (1) Configured in NetTCP_ConnCfg() :
 *
 *                       - (a) Configured  in NetTCP_ConnCfgMaxSegSize().
 *
 *                       - (b) Configured  in NetTCP_RxConnWinSizeCfg() :
 *                       - (1) Configured in NetTCP_RxConnWinSizeCfgUpdateTh().
 *
 *                       - (c) Configured  in NetTCP_TxConnWinSizeCfg() :
 *                       - (1) Configured in NetTCP_TxConnWinSizeCfgCongCtrl().
 *                       - (2) Configured in NetTCP_TxConnWinSizeCfgMinTh().
 *
 *                       - (d) Initialized in NetTCP_TxConnRTT_RTO_Init().
 *                       - (1) Configured in NetTCP_TxConnRTO_CfgMaxTimeout().
 *
 * @note     (2) See 'NetTCP_RxPktConnHandler()  Note #3c'.
 *
 * @note     (3) (a) See 'net_tcp.h  TCP SEGMENT SIZE DEFINES  Note #1b1'.
 *                       - (b) See 'net_tcp.h  TCP SEGMENT SIZE DEFINES  Note #1b2'.
 *
 * @note     (4) See 'net_cfg.h  TRANSMISSION CONTROL PROTOCOL LAYER CONFIGURATION  Note #2'.
 *
 * @note     (5) See 'NetTCP_TxConnTxQ()  Note #6b2B'.
 *
 * @note     (6) See 'net_tcp.h  TCP CONGESTION CONTROL DEFINES  Note #5b4'.
 *
 * @note     (7) See 'NetTCP_TxConnWinSizeZeroWinHandler()  Note #1b'.
 *
 * @note     (8) See 'net_tcp.h  TCP CONGESTION CONTROL DEFINES  Note #6b'.
 *
 * @note     (9) See 'NetTCP_TxConnAck()  Note #4a4A1'.
 *
 *                   10) (a) See 'NetTCP_TxConnKeepAlive()  Note #2a2'.
 *                       - (b) See 'net_tcp.h  TCP CONNECTION KEEP-ALIVE & PROBE DEFINES  Note #1a1'.
 *                       - (c) See 'net_tcp.h  TCP CONNECTION KEEP-ALIVE & PROBE DEFINES  Note #1a2'.
 *
 *                   11) See 'net_tcp.h  TCP CONGESTION CONTROL DEFINES  Note #7'.
 *
 *                   12) See 'NetTCP_ConnCfgReTxMaxTimeout()  Note #3'.
 *
 *                   13) (a) See 'net_tcp.h  TCP CONNECTION TIMEOUT DEFINES  Note #2'.
 *                       - (b) See 'net_tcp.h  TCP CONNECTION TIMEOUT DEFINES  Note #1b'.
 *                       - (c) See 'NetTCP_RxPktConnHandlerConn()  Note #3a'.
 *******************************************************************************************************/
static void NetTCP_ConnClr(NET_TCP_CONN *p_conn)
{
  NET_TCP_CONN_ID conn_id_tcp;

  conn_id_tcp = p_conn->ID;

  //                                                               -------------- CLR/INIT TCP CONN VALS --------------
  p_conn->NextPtr = DEF_NULL;

  p_conn->ID_Conn = NET_CONN_ID_NONE;

  p_conn->ConnState = NET_TCP_CONN_STATE_FREE;

  p_conn->ConnCloseCode = NET_CONN_CLOSE_FULL;                  // See Note #2.
  p_conn->ConnCloseAppFlag = DEF_YES;
  p_conn->ConnCloseTimeoutFaultFlag = DEF_YES;

  p_conn->MaxSegSizeLocalCfgd = NET_TCP_MAX_SEG_SIZE_DFLT_RX;             // See Note #3a.
  p_conn->MaxSegSizeLocalActual = p_conn->MaxSegSizeLocalCfgd;
  p_conn->MaxSegSizeRemote = NET_TCP_MAX_SEG_SIZE_DFLT_TX;                // See Note #3b.
#if 0                                                           // See Note #1a.
  p_conn->MaxSegSizeConn = NET_TCP_MAX_SEG_SIZE_NONE;
#endif

  p_conn->RxSeqNbrSync = NET_TCP_SEQ_NBR_NONE;
  p_conn->RxSeqNbrNext = NET_TCP_SEQ_NBR_NONE;
  p_conn->RxSeqNbrLast = NET_TCP_SEQ_NBR_NONE;
  p_conn->RxSeqNbrClose = NET_TCP_SEQ_NBR_NONE;
  p_conn->RxWinSizeCfgd = NET_TCP_DFLT_RX_WIN_SIZE_OCTET;                   // See Note #4.
#if 0                                                           // See Note #1b.
  p_conn->RxWinSizeCalcd = p_conn->RxWinSizeCfgd;
  p_conn->RxWinSizeActual = p_conn->RxWinSizeCfgd;
  p_conn->RxWinSizeUpdateTh = NET_TCP_WIN_SIZE_NONE;               // See Note #1b1.
#endif

  p_conn->RxQ_State = NET_TCP_RX_Q_STATE_CLOSED;
  p_conn->RxQ_Transport_Head = DEF_NULL;
  p_conn->RxQ_Transport_Tail = DEF_NULL;
  p_conn->RxQ_App_Head = DEF_NULL;
  p_conn->RxQ_App_Tail = DEF_NULL;

  p_conn->TxSeqNbrSync = NET_TCP_SEQ_NBR_NONE;
  p_conn->TxSeqNbrNext = NET_TCP_SEQ_NBR_NONE;
  p_conn->TxSeqNbrNextQ = NET_TCP_SEQ_NBR_NONE;
  p_conn->TxSeqNbrUnReTxd = NET_TCP_SEQ_NBR_NONE;
  p_conn->TxSeqNbrUnAckd = NET_TCP_SEQ_NBR_NONE;
  p_conn->TxSeqNbrUnAckdPrev = NET_TCP_SEQ_NBR_NONE;
  p_conn->TxSeqNbrUnAckdAlignDelta = 0u;
  p_conn->TxSeqNbrLast = NET_TCP_SEQ_NBR_NONE;
  p_conn->TxSeqNbrClose = NET_TCP_SEQ_NBR_NONE;

  p_conn->TxWinUpdateSeqNbr = NET_TCP_SEQ_NBR_NONE;
  p_conn->TxWinUpdateAckNbr = NET_TCP_ACK_NBR_NONE;
  p_conn->TxWinUpdateWinSize = NET_TCP_WIN_SIZE_NONE;
  p_conn->TxWinSizeCfgd = NET_TCP_DFLT_TX_WIN_SIZE_OCTET;                   // See Note #4.
  p_conn->TxWinSizeRemote = NET_TCP_WIN_SIZE_NONE;
  p_conn->TxWinSizeRemoteMax = p_conn->TxWinSizeRemote;
  p_conn->TxWinSizeRemoteActual = p_conn->TxWinSizeRemote;
  p_conn->TxWinSizeRemoteRem = p_conn->TxWinSizeRemote;
  p_conn->TxWinSizeNagleEn = DEF_ENABLED;                       // See Note #5.
  p_conn->TxWinSillyWinTimeout_ms = NET_TCP_TX_SILLY_WIN_TIMEOUT_DFLT_MS;         // See Note #6.
  p_conn->TxWinZeroWinTimeout_ms = 0u;                          // See Note #7.
#if 0                                                           // See Note #1c.
  p_conn->TxWinSizeCfgdRem = p_conn->TxWinSizeCfgd;
  p_conn->TxWinRxdAckDupCtr = 0u;
  p_conn->TxWinRxdLastSeqNbr = NET_TCP_SEQ_NBR_NONE;
  p_conn->TxWinRxdLastAckNbr = NET_TCP_ACK_NBR_NONE;
  p_conn->TxWinRxdLastWinSize = NET_TCP_WIN_SIZE_NONE;
  p_conn->TxWinSizeSlowStartTh = NET_TCP_WIN_SIZE_NONE;
  p_conn->TxWinSizeSlowStartThInit = NET_TCP_WIN_SIZE_NONE;
  p_conn->TxWinSizeCongInit = NET_TCP_WIN_SIZE_NONE;
  p_conn->TxWinSizeCongCalcdActual = NET_TCP_WIN_SIZE_NONE;
  p_conn->TxWinSizeCongCalcdCur = NET_TCP_WIN_SIZE_NONE;
  p_conn->TxWinSizeCongRem = NET_TCP_WIN_SIZE_NONE;
  p_conn->TxWinSizeAvail = NET_TCP_WIN_SIZE_NONE;
  p_conn->TxWinSizeMinTh = NET_TCP_WIN_SIZE_NONE;
#endif

  NetTCP_ConnCfgTxAckDlyTimeoutHandler(conn_id_tcp,
                                       NET_TCP_DFLT_TIMEOUT_CONN_ACK_DLY_MS);   // See Note #8.

  p_conn->TxAckDlyTmr = DEF_NULL;
  p_conn->TxAckDlyCnt = 0u;

  p_conn->TxAckImmedRxdPushEn = DEF_ENABLED;                    // See Note #9.

  p_conn->TxKeepAliveEn = DEF_DISABLED;                         // See Note #10a.
  p_conn->TxKeepAliveCtr = 0u;
  p_conn->TxKeepAliveTh = NET_TCP_TX_KA_TH_DFLT;                   // See Note #10b.
  p_conn->TxKeepAliveRetryTimeout_sec = NET_TCP_TX_KA_RETRY_TIMEOUT_DFLT_SEC;     // See Note #10c.

  p_conn->TxSegReTxTh = NET_TCP_RE_TX_TH_DFLT;                     // See Note #11.

  p_conn->TxRTT_RTO_Max_sec = NET_TCP_TX_RTO_MAX_TIMEOUT_DFLT_SEC;               // See Note #12.
#if 0                                                           // See Note #1d.
  p_conn->TxRTT_Avg_ms_scaled = NET_TCP_TX_RTT_NONE;
  p_conn->TxRTT_Dev_ms_scaled = NET_TCP_TX_RTT_NONE;
  p_conn->TxRTT_RTO_ms_scaled = NET_TCP_TX_RTO_NONE;
  p_conn->TxRTT_RTO_Max_ms_scaled = NET_TCP_TX_RTO_NONE;        // See Note #1d1.
  p_conn->TxRTT_Avg_ms = NET_TCP_TX_RTT_NONE;
  p_conn->TxRTT_Dev_ms = NET_TCP_TX_RTT_NONE;
  p_conn->TxRTT_RTO_ms = NET_TCP_TX_RTO_NONE;
  p_conn->TxRTT_RTO_Max_ms = NET_TCP_TX_RTO_NONE;               // See Note #1d1.
  p_conn->TxRTT_RTO_sec = NET_TCP_TX_RTO_NONE;
  p_conn->TxRTT_RTO_tick = NET_TMR_TIME_0S;
  p_conn->TxRTT_RTO_State = NET_TCP_TX_RTT_RTO_STATE_NONE;
#endif

  p_conn->TxQ_State = NET_TCP_TX_Q_STATE_CLOSED;
  p_conn->TxQ_Head = DEF_NULL;
  p_conn->TxQ_Tail = DEF_NULL;
  p_conn->TxQ_IdleTmr = DEF_NULL;
  p_conn->TxQ_SillyWinTmr = DEF_NULL;
  p_conn->TxQ_ZeroWinTmr = DEF_NULL;
  p_conn->ReTxQ_Head = DEF_NULL;
  p_conn->ReTxQ_Tail = DEF_NULL;
  p_conn->ReTxQ_Tmr = DEF_NULL;

  p_conn->TimeoutTmr = DEF_NULL;
  p_conn->TimeoutConn_sec = NET_TCP_CONN_TIMEOUT_IDLE_DFLT_SEC;                 // See Note #13a.
  p_conn->TimeoutUser_sec = NET_TCP_CONN_TIMEOUT_USER_DFLT_SEC;                 // See Note #13c.
  p_conn->TimeoutMaxSeg_sec = NET_TCP_DFLT_TIMEOUT_CONN_MAX_SEG_SEC;               // See Note #13b.

  p_conn->Flags = NET_TCP_FLAG_NONE;

  p_conn->FnctAppListenQ_IsAvail = DEF_NULL;
  p_conn->FnctAppPostRx = DEF_NULL;
  p_conn->FnctAppPostTx = DEF_NULL;

  NetTCP_ConnCfg(p_conn, NET_TCP_CONN_CFG_ALL);                 // See Note #1.

  //                                                               -------------- CFG DFLT TIMEOUT VALS ---------------
  NetTCP_RxQ_TimeoutDflt(conn_id_tcp);
  NetTCP_TxQ_TimeoutDflt(conn_id_tcp);
}

/****************************************************************************************************//**
 *                                               NetTCP_ConnCopy()
 *
 * @brief    (1) Copy/clone a TCP connection :
 *
 *           - (a) Copy connection parameters :
 *
 *               - (1) TCP connection state
 *
 *               - (2) Receive  parameters :
 *                   - (A)    Receive  window size
 *
 *               - (3) Transmit parameters :
 *                   - (A)    Transmit window size
 *                   - (B)    Transmit acknowledgement
 *                   - (C)    Transmit keep-alive
 *
 *                   - (D) Re-transmit parameters :
 *                       - (1) Threshold
 *                       - (2) Maximum timeout
 *
 *                   - (E) IP transmit parameters :
 *                       - (1) TOS
 *                       - (2) TTL
 *                       - (3) IP flags
 *
 *               - (4) TCP connection timeout values
 *
 *           - (b) Configure copied connection parameters :
 *
 *               - (1)    Receive  controls
 *               - (2)    Transmit controls
 *               - (3) Re-transmit controls
 *
 * @param    p_conn_dest     Pointer to TCP connection to receive TCP connection copy.
 *
 * @param    p_conn_src      Pointer to TCP connection to copy.
 *******************************************************************************************************/
static void NetTCP_ConnCopy(NET_TCP_CONN *p_conn_dest,
                            NET_TCP_CONN *p_conn_src)
{
  NET_TCP_CFG_CODE cfg_code;

  p_conn_dest->ConnState = p_conn_src->ConnState;

  p_conn_dest->MaxSegSizeLocalCfgd = p_conn_src->MaxSegSizeLocalCfgd;

  p_conn_dest->RxWinSizeCfgd = p_conn_src->RxWinSizeCfgd;

  p_conn_dest->TxWinSizeCfgd = p_conn_src->TxWinSizeCfgd;
  p_conn_dest->TxWinSizeNagleEn = p_conn_src->TxWinSizeNagleEn;

  p_conn_dest->TxAckDlyTimeout_ms = p_conn_src->TxAckDlyTimeout_ms;
  p_conn_dest->TxAckImmedRxdPushEn = p_conn_src->TxAckImmedRxdPushEn;

  p_conn_dest->TxKeepAliveEn = p_conn_src->TxKeepAliveEn;
  p_conn_dest->TxKeepAliveTh = p_conn_src->TxKeepAliveTh;
  p_conn_dest->TxKeepAliveRetryTimeout_sec = p_conn_src->TxKeepAliveRetryTimeout_sec;

  p_conn_dest->TxSegReTxTh = p_conn_src->TxSegReTxTh;
  p_conn_dest->TxRTT_RTO_Max_sec = p_conn_src->TxRTT_RTO_Max_sec;

  p_conn_dest->TimeoutConn_sec = p_conn_src->TimeoutConn_sec;
  p_conn_dest->TimeoutUser_sec = p_conn_src->TimeoutUser_sec;
  p_conn_dest->TimeoutMaxSeg_sec = p_conn_src->TimeoutMaxSeg_sec;

  NetConn_Copy(p_conn_dest->ID_Conn,
               p_conn_src->ID_Conn);

  //                                                               Cfg conn (see Note #1b).
  cfg_code = NET_TCP_CONN_CFG_NONE
             | NET_TCP_CONN_CFG_WIN_SIZE_ALL
             | NET_TCP_CONN_CFG_TX_RTT_RTO;
  NetTCP_ConnCfg(p_conn_dest, cfg_code);
}

/****************************************************************************************************//**
 *                                           NetUDP_GetTxDataIx()
 *
 * @brief    Get the offset of a buffer at which the TCP data CAN be written.
 *
 * @param    if_nbr              Interface number on which data will be transmit.
 *
 * @param    protocol            Network protocol to use:
 *                               NET_PROTOCOL_TYPE_TCP_V4
 *                               NET_PROTOCOL_TYPE_TCP_V6
 *
 * @param    additial_hdr_size   Size of the additional headers.
 *
 * @param    data_len            Data length to send
 *
 * @param    p_conn              Pointer to TCP connection.
 *
 * @param    p_ix                Pointer to the current protocol index.
 *******************************************************************************************************/
static void NetTCP_GetTxDataIx(NET_IF_NBR        if_nbr,
                               NET_PROTOCOL_TYPE protocol,
                               CPU_INT16U        additial_hdr_size,
                               CPU_INT16U        data_len,
                               NET_TCP_CONN      *p_conn,
                               CPU_INT16U        *p_ix)
{
  NET_MTU mtu;

  *p_ix += (NET_TCP_HDR_SIZE_MIN + additial_hdr_size);

#if 0
  remove extra tcp header option length.
#endif

  switch (protocol) {
#ifdef  NET_IPv4_MODULE_EN
    case NET_PROTOCOL_TYPE_TCP_V4:
      mtu = NetIF_MTU_GetProtocol(if_nbr, NET_PROTOCOL_TYPE_TCP_V4, NET_IF_FLAG_NONE);

      NetIPv4_TxIxDataGet(if_nbr,
                          data_len,
                          mtu,
                          p_ix);
      break;
#endif
#ifdef  NET_IPv6_MODULE_EN
    case NET_PROTOCOL_TYPE_TCP_V6:
      mtu = NetIF_MTU_GetProtocol(if_nbr, NET_PROTOCOL_TYPE_TCP_V6, NET_IF_FLAG_NONE);

      NetIPv6_GetTxDataIx(if_nbr,
                          DEF_NULL,
                          data_len,
                          mtu,
                          p_ix);
      break;
#endif

    default:
      RTOS_CRITICAL_FAIL_EXEC(RTOS_ERR_ASSERT_CRITICAL_FAIL,; );
  }

  PP_UNUSED_PARAM(p_conn);
}

/********************************************************************************************************
 ********************************************************************************************************
 *                                   DEPENDENCIES & AVAIL CHECK(S) END
 ********************************************************************************************************
 *******************************************************************************************************/

#endif // NET_TCP_MODULE_EN
#endif // RTOS_MODULE_NET_AVAIL
